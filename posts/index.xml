<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts -</title><link>https://youngeun-in.github.io/posts/</link><description>All Posts |</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 05 Mar 2024 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>WebFlux, WebClient</title><link>https://youngeun-in.github.io/webflux-webclient/</link><pubDate>Tue, 05 Mar 2024 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/webflux-webclient/</guid><description>리액터(Reactor) 리액터(Reactor)란 리액티브 프로그래밍을 위한 리액티브 라이브러리이다. Reactive Streams 스펙을 구현한 구현체 중 하나이다. Spring 에코 시스템에서 Reactive Stack의 기반이 되며 Spring WebFlux 프레임워크에 포함이 되어 있다.
Spring Webflux Spring Webflux란 Spring 5부터 지원하는 리액티브 웹 프레임워크이다. 비동기 Non-Blocking I/O 방식으로 적은 수의 쓰레드를 사용한다. Spring Webflux는 Reactive Streams의 구현체 중에 하나인 Reactor에 의존하여 비동기 로직을 구성하고 리액티브 스트림을 제공한다.
Spring Webflux는 적은 수의 스레드를 사용하여 여러 클라이언트의 요청을 처리할수 있고, 자원(메모리,CPU)를 효율적으로 사용할수 있다.</description></item><item><title>프록시 패턴, 데코레이터 패턴</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</link><pubDate>Fri, 02 Feb 2024 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid><description><![CDATA[프록시 패턴 1 2 3 4  package hello.proxy.pureproxy.proxy.code; public interface Subject { String operation(); }   예제에서 Subject 인터페이스는 단순히 operation() 메서드 하나만 가지고 있다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package hello.proxy.pureproxy.proxy.code; import lombok.extern.slf4j.Slf4j; @Slf4j public class RealSubject implements Subject { @Override public String operation() { log.info(&#34;실제 객체 호출&#34;); sleep(1000); return &#34;data&#34;; } private void sleep(int millis) { try { Thread.]]></description></item><item><title>템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴</title><link>https://youngeun-in.github.io/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/</link><pubDate>Thu, 01 Feb 2024 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/</guid><description>템플릿 메서드 패턴 템플릿은 기준이 되는 거대한 틀이다. 템플릿이라는 틀에 변하지 않는 부분을 몰아둔다. 그리고 일부 변하는 부분을 별도로 호출해서 해결한다.
템플릿 메서드 패턴은 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 일부 변경되는 로직은 자식 클래스에 정의하는 것이다. 이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의할 수 있다. 결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것이다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package hello.</description></item><item><title>트랜잭션 전파 설정</title><link>https://youngeun-in.github.io/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/</link><pubDate>Mon, 20 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/</guid><description><![CDATA[Spring에서 사용하는 어노테이션 &lsquo;@Transactional&rsquo;은 해당 메서드를 하나의 트랜잭션 안에서 진행할 수 있도록 만들어주는 역할을 한다. 이때 트랜잭션 내부에서 트랜잭션을 또 호출한다면 스프링에서는 새로운 트랜잭션이 생성될 수도 있고, 이미 트랜잭션이 있다면 부모 트랜잭션에 합류할 수도 있을 것이다. 진행되고 있는 트랜잭션에서 다른 트랜잭션이 호출될 때 어떻게 처리할지 정하는 것을 &lsquo;트랜잭션의 전파 설정&rsquo;이라고 부른다.
전파 설정 옵션 트랜잭션의 전파 설정은 &lsquo;@Transactional&rsquo;의 옵션 &lsquo;propagation&rsquo;을 통해 설정할 수 있다. 각 옵션은 아래와 같다.
REQUIRED (기본값) 부모 트랜잭션이 존재한다면 부모 트랜잭션으로 합류한다.]]></description></item><item><title>Spring MVC 구조</title><link>https://youngeun-in.github.io/spring-mvc-%EA%B5%AC%EC%A1%B0/</link><pubDate>Sun, 12 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/spring-mvc-%EA%B5%AC%EC%A1%B0/</guid><description>DispatcherServlet 구조 스프링 MVC는 프론트 컨트롤러 패턴으로 구현되어 있다. 스프링 MVC의 프론트 컨트롤러가 디스패처 서블릿(DispatcherServlet)이다.
FrontController 패턴 특징은 다음과 같다.
프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호 입구를 하나로 하여 공통 처리 가능 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨 DispacherServlet는 부모 클래스에서 HttpServlet 을 상속 받아서 사용하고, 서블릿으로 동작한다.
상속관계는 다음과 같다. DispatcherServlet -&amp;gt; FrameworkServlet -&amp;gt; HttpServletBean -&amp;gt; HttpServlet</description></item><item><title>MVC 패턴</title><link>https://youngeun-in.github.io/mvc-%ED%8C%A8%ED%84%B4/</link><pubDate>Sat, 11 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/mvc-%ED%8C%A8%ED%84%B4/</guid><description>서블릿과 JSP의 한계 서블릿으로 개발할 때는 뷰(View)화면을 위한 HTML을 만드는 작업이 자바 코드에 섞여서 지저분하고 복잡했다.
JSP를 사용한 덕분에 뷰를 생성하는 HTML 작업을 깔끔하게 가져가고, 중간중간 동적으로 변경이 필요한 부분에만 자바 코드를 적용했다. 그러나 이러한 형태는 비즈니스 로직과 뷰 영역이 혼재되어 코드를 이해하기 어렵고 유지보수가 힘들어진다는 단점이 있다.
MVC 패턴 - 개요 하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면, 변경의 라이프 사이클이 다르기 때문에 유지보수하기 좋지 않다.</description></item><item><title>Web Server vs WAS</title><link>https://youngeun-in.github.io/web-server-vs-was/</link><pubDate>Fri, 10 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/web-server-vs-was/</guid><description>웹 서버(Web Server) HTTP 기반으로 동작 정적 리소스 제공, 기타 부가기능 정적(파일) HTML, CSS, JS, 이미지, 영상 예) NGINX, APACHE 웹 애플리케이션 서버(WAS - Web Application Server) HTTP 기반으로 동작 웹 서버 기능 포함+ (정적 리소스 제공 가능) 프로그램 코드를 실행해서 애플리케이션 로직 수행 동적 HTML, HTTP API(JSON) 서블릿, JSP, 스프링 MVC 예) 톰캣(Tomcat) Jetty, Undertow 웹 서버, 웹 애플리케이션 서버(WAS) 차이 웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직 사실은 둘의 용어도 경계도 모호함 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함 웹 애플리케이션 서버도 웹 서버의 기능을 제공함 자바는 서블릿 컨테이너 기능을 제공하면 WAS 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있음 WAS는 애플리케이션 코드를 실행하는데 더 특화 웹 시스템 구성 - WEB, WAS, DB 정적 리소스는 웹 서버가 처리 웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임 WAS는 중요한 애플리케이션 로직 처리 전담 효율적인 리소스 관리 정적 리소스가 많이 사용되면 Web 서버 증설 애플리케이션 리소스가 많이 사용되면 WAS 증설 WAS, DB 장애시 WEB 서버가 오류 화면 제공 가능 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽음 참고 https://www.</description></item><item><title>Servlet 동작 방식</title><link>https://youngeun-in.github.io/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/</link><pubDate>Thu, 09 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/</guid><description>서블릿 사용 시 HTTP 요청, 응답 흐름 HTTP 요청시 WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력 WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성 서블릿 컨테이너 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리 서블릿 객체는 싱글톤으로 관리 고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근 공유 변수 사용 주의 서블릿 컨테이너 종료시 함께 종료 JSP도 서블릿으로 변환 되어서 사용 동시 요청을 위한 멀티 쓰레드 처리 지원 웹 애플리케이션 서버의 요청 응답 구조 HttpServletRequest 역할 HTTP 요청 메시지를 개발자가 직접 파싱해서 사용해도 되지만, 매우 불편할 것이다.</description></item><item><title>사설IP, NAT, CIDR</title><link>https://youngeun-in.github.io/%EC%82%AC%EC%84%A4ip-nat-cidr/</link><pubDate>Sat, 04 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%82%AC%EC%84%A4ip-nat-cidr/</guid><description>사설 IP(Private IP) 사설 IP(Private IP)는 한정된 IP 주소를 최대한 활용하기 위해 IP주소를 분할하고자 만든 개념이다. IPV4 기준으로 최대 IP 개수는 약 43억개이다.
사설망 내부에는 외부 인터넷 망으로 통신이 불가능한 사설 IP가 구성된다. 그리고 외부로 통신할 때는 통신 가능한 공인 IP를 사용한다. 보통 하나의 망은 사설 IP를 부여받은 기기들과 NAT 기능을 갖춘 Gateway로 구성한다.
NAT(Network Address Translation) NAT(Network Address Translation)는 사설 IP가 공용 IP로 통신할 수 있도록 주소를 변환해주는 방법이다.</description></item><item><title>스프링 비동기</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/</link><pubDate>Sun, 29 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/</guid><description>외부 API에 작업 요청하고 외부 API서버에서 요청을 처리하는데 오랜시간이 걸리는 경우 비동기 방식으로 처리하면 효율적이다.
@EnableAsync @Async 는 비동기적으로 처리를 할 수 있게끔 스프링에서 제공하는 어노테이션이다. 해당 어노테이션을 붙이게 되면 각기 다른 쓰레드로 실행이 된다. 즉, 호출자는 해당 메서드가 완료되는 것을 기다릴 필요가 없다.
이 어노테이션을 사용하기 위해서는 @EnableAsync 가 달려있는 configuration 클래스가 우선적으로 필요하다. @EnableAsync 는 스프링의 @Async 어노테이션을 감지한다.
1 2 3 4 @Configuration @EnableAsync public class AsyncConfig { } @Async 어노테이션을 사용하기 위해서는 2가지 제약조건이 있다.</description></item></channel></rss>