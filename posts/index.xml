<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts -</title><link>https://youngeun-in.github.io/posts/</link><description>All Posts |</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 28 Jul 2023 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>연관관계 매핑</title><link>https://youngeun-in.github.io/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</link><pubDate>Fri, 28 Jul 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</guid><description>양방향 연관관계 양방향 매핑은 단방향 매핑에서 반대 방향으로 객체 조회(객체 그래프 탐색) 기능이 추가된 매핑 방법이다.
아래와 같은 연관 관계가 있다고 가정하자.
예제 시나리오 회원과 팀이 있다 회원은 하나의 팀에만 소속될 수 있다. 회원과 팀은 다대일 관계다. 위의 시나리오를 구현하기 위해서 Member(=회원), Team Entity를 작성해보자.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package hello.</description></item><item><title>영속성 컨텍스트</title><link>https://youngeun-in.github.io/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/</link><pubDate>Thu, 27 Jul 2023 00:01:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/</guid><description>영속성 컨텍스트 처음 생성된 엔티티 매니저 팩토리는 클라이언트의 요청에 따라 엔티티 매니저를 생성한다. 그리고 엔티티 매니저는 DB Connection Pool에 있는 Connection을 이용해서 DB에 접근한다.
영속성 컨텍스트란 엔티티를 영구 저장하는 환경이다. 영속성 컨텍스트는 논리적인 개념이며, 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.
엔티티의 생명주기 비영속(new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태. 객체를 단순히 생성한 상태 영속(managed) 영속성 컨텍스트에 의해 관리되는 상태 객체를 생성한 뒤 엔티티 매니저를 통해 persist 해주면 영속 상태가 된다.</description></item><item><title>JPA 소개</title><link>https://youngeun-in.github.io/jpa-%EC%86%8C%EA%B0%9C/</link><pubDate>Wed, 26 Jul 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/jpa-%EC%86%8C%EA%B0%9C/</guid><description>SQL 중심적인 개발의 문제점 SQL에 의존적인 개발을 피하기 어렵다. 패러다임의 불일치 (객체 vs 관계형 데이터베이스) 객체와 관계형 데이터베이스의 차이 상속 객체는 상속과 다형성을 사용 테이블은 상속 관계 안쓴다. 연관관계 객체는 참조를 사용 관계형 데이터베이스는 외래 키를 사용 연관관계 탐색 객체는 자유롭게 객체 그래프를 탐색할 수 있어야 한다. 관계형 데이터베이스는 처음 실행하는 SQL에 따라 탐색 범위 결정 데이터 식별 방법 관계형 데이터베이스는 처음 실행하는 SQL에 따라 탐색 범위 결정되기 때문에, 이는 엔티티 신뢰 문제를 발생시킨다.</description></item><item><title>JAVA NIO 기반의 입출력</title><link>https://youngeun-in.github.io/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/</link><pubDate>Sat, 22 Jul 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/</guid><description>NIO의 채널(Channel)과 버퍼(Buffer) 스트림과 채널의 공통점
스트림도 채널도 데이터의 입력 및 출력을 위한 통로가 된다. 스트림과 채널의 차이점
스트림은 한 방향으로만 데이터가 이동하지만 채널은 양방향으로 데이터 이동이 가능하다. 채널에만 존재하는 제약사항
채널은 반드시 버퍼에 연결해서 사용해야 한다. 채널 기반 데이터 입출력 경로
출력 경로: 데이터 ⇨ 버퍼 ⇨ 채널 ⇨ 파일 입력 경로: 데이터 ⇦ 버퍼 ⇦ 채널 ⇦ 파일 채널과 버퍼는 독립적이다.</description></item><item><title>프로세스, 스레드</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/</link><pubDate>Thu, 08 Jun 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/</guid><description>프로세스 프로세스는 실행 중에 있는 프로그램을 의미한다. 여러분이 게임을 즐기기 위해서 게임 실행파일을 더블클릭하면, 그 순간 프로그램 실행을 위해 메모리 할당이 이루어집니다. 그리고 이 메모리 공간으로 바이너리 코드가 올라가게 되며, 이 순간부터 프로그램은 프로세스라고 불리게 된다.
대부분의 사람들은 하나의 프로그램만 사용하기보다는, 여러 프로그램을 동시에 사용하고 싶어한다. 하지만 컴퓨터가 하나의 명령을 수행하기 위해서 CPU를 점유하고 있으면 다른 작업은 실행될 수 없다. 둘 이상의 프로그램이 동시에 실행이 가능했던 이유는 하나의 CPU가 여러 개의 프로세스를 번갈아가며 실행하기 때문이다.</description></item><item><title>Array vs ArrayList</title><link>https://youngeun-in.github.io/array-vs-arraylist/</link><pubDate>Sun, 15 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/array-vs-arraylist/</guid><description>Resizable Array Array는 static하다(길이 고정). Array 객체를 생성한 후에는 Array의 길이를 마음대로 변경할 수 없다. 따라서, 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어주어야 한다.
ArrayList ArrayList는 사이즈가 dynamic하다. 하지만 내부적으론 배열로 구성되어 있다. ArrayList는 Default로 10개의 공간을 가진 배열로 시작한다. 하지만 최적화(지연 초기화)로 인해 막 생성하면 0개의 사이즈로 시작된다.
각각의 ArrayList Object는 ArrayList의 size를 나타내는 capacity 인스턴스 변수를 가지고 있다. ArrayList에 요소들이 더해지면 ArrayList의 capacity 또한 자동적으로 늘어난다.</description></item><item><title>스프링의 싱글톤 설정</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/</link><pubDate>Tue, 03 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/</guid><description>싱글톤 패턴 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다. 싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 하지만 싱글톤 패턴은 다음과 같은 문제점들을 가지고 있다.
싱글톤 패턴 문제점 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다. 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다. 테스트하기 어렵다. 내부 속성을 변경하거나 초기화 하기 어렵다.</description></item><item><title>스프링이란?</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/</link><pubDate>Mon, 02 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/</guid><description>스프링(Spring)이란? 자바 플랫폼을 위한 자바 언어 기반의 오픈 소스 애플리케이션 프레임워크 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크 스프링 생태계 스프링 프레임워크 필수 항목 내용 코어 기술 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술 스프링 MVC, 스프링 WebFlux 데이터 접근 기술 트랜잭션, JDBC, ORM 지원, XML 지원 통합 기술 캐시, 이메일, 원격 접근, 스케줄링 선택 스프링 데이터 스프링 세션 스프링 시큐리티 스프링 Rest Docs 스프링 배치 스프링 클라우드 스프링의 특징 경량 컨테이너 &amp;amp; 자바 객체 직접 관리 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리한다.</description></item><item><title>Spring의 등장 배경</title><link>https://youngeun-in.github.io/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/</link><pubDate>Sun, 01 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/</guid><description>EJB(Enterprise Java Beans)와 POJO(Plain Old Java Object) EJB(Enterprise Java Beans) 개념 기업환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델 애플리케이션의 업무 로직을 가지고 있는 서버 애플리케이션 Java EE의 자바 API 중 하나 특징 동시 접속자 수가 많은 가운데 안정적인 트랜잭션이 필요한 사이트 구축시 사용하는 컴포넌트 기술 ex) 공공기관, 기상청, 병무청, 금융, 보험, 포털사이트, 게임사이트, 기업 등.. JSP, Beans를 사용한 시스템보다 속도는 느리지만, 개발시 개발자에게 많은 자동화된 기능을 제공하여 안정적인 분산 시스템 구축 및 제공을 용이하게 함 기초 기술(JSP, BEANS, RMI, Servlet, Serialization, Transaction, Connection Pooling)을 알면 학습 및 사용이 쉬움 EJB 규약을 집중적으로 습득하면 쉽게 EJB 컴포넌트 개발 가능 장단점 장점 단점 많은 동시접속자에 대한 안정성 지원 객체지향적이지 않음 처리 메소드를 컨테이너가 트랜잭션 자동 처리 복잡한 프로그래밍 모델 빈즈의 상태를 메모리에서 사용 여부에 따라 자동으로 활성화/비활성화 실행하여 관리 특정 환경·기술에 종속적인 코드 다층 구조 시스템 구축 가능 컨테이너 안에서만 동작할 수 있는 객체 구조 라이프 사이클, 보안, Threading 등의 서비스 제공 부족한 개발생산성 및 이동성 POJO(Plain Old Java Object) 특정 자바 모델이나 기능, 프레임워크 등에 종속되지 않고, 클래스 패스(class path)를 필요로 하지 않는 일반적인 Java Object 중량 프레임워크들(Java EE 등&amp;hellip;)을 사용하게 되면서 해당 프레임워크에 종속된 &amp;ldquo;무거운&amp;rdquo; 객체를 만들게 된 것에 반발해서 사용하게 됨 2000년 9월 마틴 파울러, 레베카 파슨, 조쉬 맥킨지 등에 의해 사용되기 시작함 Spring과 Hibernate의 등장 EJB의 단점들로 인해 대표적으로 2가지의 Open Source가 등장하게 되었다.</description></item><item><title>RAID</title><link>https://youngeun-in.github.io/raid/</link><pubDate>Tue, 13 Dec 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/raid/</guid><description>RAID (Redundant Array of Inexpensive/Independent Disk)는 저장장치(디스크) 여러 개를 묶어 고용량,고성능 저장 장치 한 개와 같은 효과를 얻기 위해 개발된 기법이다.
RAID는 여러개의 하드디스크를 함께 사용하는 방식을 말한다. 속도를 위해 함께 사용 할 수도 있고 안정성을 위해 함께 사용 할 수도 있고 둘다를 추구할 수도 있다.
RAID-0 속도 추구만을 위한 레이드 구성이다. 단순히 하드 여러개에 데이터를 분산시켜서 한꺼번에 입출력을 수행하는 것이다. 이를 스트라이핑(Disk striping) 기술이라고 한다.
예를 들면 1~10까지의 숫자를 저장하는데, 하드1에는 1 3 5 7 9, 하드2에는 2 4 6 8 10을 저장한다.</description></item></channel></rss>