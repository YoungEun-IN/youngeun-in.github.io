<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts -</title><link>https://youngeun-in.github.io/posts/</link><description>All Posts |</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 12 May 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>로드밸런싱</title><link>https://youngeun-in.github.io/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/</link><pubDate>Thu, 12 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/</guid><description>로드 밸런싱이란 서버가 처리해야 할 업무 혹은 요청(Load)을 여러 대의 서버로 나누어(Balancing) 처리하는 것을 의미한다. 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 하는 것이 목적이다.
서비스의 규모가 커지고, 이용자 수가 늘어나게 되면 기존의 서버만으로는 원활한 서비스 동작이 불가능하게 되고, 이에 대처할 수 있는 방법은 크게 두 가지로 나뉜다.
기존의 서버 성능을 확장하는 Scale-up 방식 기존의 서버와 동일하거나 낮은 성능의 서버를 증설하는 Scale-out 방식 이때 Scale-out 방식을 통해 증가한 트래픽에 대처하기로 했다면, 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드 밸런싱이 반드시 필요하다.</description></item><item><title>낙관적락, 비관적락</title><link>https://youngeun-in.github.io/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/</link><pubDate>Sun, 08 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/</guid><description>낙관적 락 낙관적 락은 대부분의 경우 트랜젝션의 충돌이 일어나지 않는다는 낙관적 가정을 하는 기법이다. 낙관적 락은 데이터베이스 자체에서 제공하는 것이 아니라 JPA 즉 어플리케이션에서 제공하는 기능이다. 낙관적 락은 충돌을 가정하지 않기 때문에 커밋이 된 이후에 충돌 여부를 알 수 있다.
JPA에서 낙관적 락 구현 JPA에서 낙관적 락을 사용하기 위해서는 엔티티 클래스에 @Version 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다.
1 2 3 4 5 6 7 8 9 10 @Entity public class Member { @Id private Long id; private String name; @Version private Integer version; } @Version을 명시할때는 다음과 같은 주의사항이 있다.</description></item><item><title>Filter, Interceptor, AOP</title><link>https://youngeun-in.github.io/filter-interceptor-aop/</link><pubDate>Sat, 07 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/filter-interceptor-aop/</guid><description>Filter Filter(필터)는 요청과 응답을 거른 뒤 정제하는 역할을 한다. 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러 가지 체크를 수행할 수 있다. 또한 자원의 처리가 끝난 후 응답 내용에 대해서도 변경하는 처리를 할 수가 있다. 즉 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS 방어 등의 요청에 대한 처리로 사용된다.
init(): 필터 인스턴스 초기화 doFilter(): 전/후 처리 destroy(): 필터 인스턴스 종료 Interceptor 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답을 처리한다.</description></item><item><title>Keep-Alive</title><link>https://youngeun-in.github.io/keep-alive/</link><pubDate>Fri, 06 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/keep-alive/</guid><description>TCP Keep-Alive 두 종단 간의 연결을 유지하는 것이 목적이다. 연결된 TCP 소켓을 체크할 수 있고 TCP 연결이 여전히 진행중인지 혹은 끊어졌는지를 결정한다.
TCP Keepalive는 연결된 세션의 재활용 측면에서만 아니라 좀비 커넥션의 삭제에도 도움을 준다. TCP 연결을 끊으려면 FIN 패킷이 필요하다. 하지만 다양한 이유로 FIN 패킷을 받을 수 없는 상황이 된다면 FIN을 전달할 수 없어 계속 연결된 것처럼 남아있게 된다. TCP Keepalive 옵션을 사용한다면 일정시간이 확인 패킷을 보내는 로직을 통해 일정시간 동안 응답이 없다면 연결을 종료하기 때문에 좀비 커넥션을 방지할 수 있다.</description></item><item><title>세션 하이재킹</title><link>https://youngeun-in.github.io/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/</link><pubDate>Mon, 02 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/</guid><description>서버는 로그인하는 시점에 보통 내부적으로 사용자 세션을 생성하고 이를 식별할 수 있는 식별자(세션 키 - 자바 웹 애플리케이션에서는 jsessionid라는 이름을 가진다)를 사용자에 보내는 응답에 포함시킨다. 브라우저는 이를 쿠키 형태로 가지고 있게 되며, 이 세션 키가 서버 입장에서 사용자의 identity를 식별할 수 있는 식별자가 된다.
이 때 누군가가 이 세션 키를 가로채서 알게 되면 마치 그 사람인 척 하고 서버에 요청을 보내도 서버에서는 이게 진짜 사용자가 보냈는지 아닌지를 판단할 수 없다. 이것을 세션 하이재킹이라고 한다.</description></item><item><title>JWT</title><link>https://youngeun-in.github.io/jwt/</link><pubDate>Sat, 30 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/jwt/</guid><description>JWT 는 유저를 인증하고 식별하기 위한 토큰(Token)기반 인증이다. RFC 7519 에 자세한 명세가 나와있다. 토큰은 세션과는 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.
JWT 가 가지는 핵심적인 특징이 있다면, 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보가 포함(Self-contained)된다는 것이다. 데이터가 많아지면 토큰이 커질 수 있으며 토큰이 한 번 발급된 이후 사용자의 정보를 바꾸더라도 토큰을 재발급하지 않는 이상 반영되지 않는다.</description></item><item><title>Java 스레드</title><link>https://youngeun-in.github.io/java-%EC%8A%A4%EB%A0%88%EB%93%9C/</link><pubDate>Fri, 22 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-%EC%8A%A4%EB%A0%88%EB%93%9C/</guid><description>스레드 모든 자바 어플리케이션은 Main Thread가 main() 메소드를 실행하면서 시작된다. Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 만들어 병렬로 코드를 실행할 수 있다. 싱글 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만, 멀티 스레드는 메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. 프로세스 내부에서의 멀티 스레드는 공유되는 자원이 있어 하나의 스레드에서 예외가 발생한다면 프로세스 자체가 종료될 수 있다.
Thread 생성 Thread 클래스로부터 직접 생성 new를 통해 Thread 클래스 객체를 생성 후 start 메서드를 통해 다른 스레드에서 할 작업을 할당하는 방법이다.</description></item><item><title>3 way handshake, 4 way handshake</title><link>https://youngeun-in.github.io/3-way-handshake-4-way-handshake/</link><pubDate>Tue, 19 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/3-way-handshake-4-way-handshake/</guid><description>3-Way Handshake 3-Way Handshake는 TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정이다. 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다. 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
작동 방식 Step 1 (SYN) 클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다.</description></item><item><title>Base64 Encoding</title><link>https://youngeun-in.github.io/base64-encoding/</link><pubDate>Sun, 17 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/base64-encoding/</guid><description>인코딩(encoding)은 파일에 저장된 정보의 형태나 형식을 데이터 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해서 다른 형태로 변환하는 처리 혹은 그 처리 방식을 말한다. 이메일 등의 전송, 동영상이나 이미지 영역에서 많이 사용되며, 반대말은 디코딩(decoding)이다.
Base64를 글자 그대로 직역하면 64진법이라는 뜻이다. 컴퓨터 분야에서 쓰이는 Base 64(베이스 육십사)란 8비트 이진 데이터(예를 들어 실행 파일이나, ZIP 파일 등)를 문자 코드에 영향을 받지 않는 공통 ASCII 영역의 문자들로만 이루어진 일련의 문자열로 바꾸는 인코딩 방식을 가리키는 개념이다.</description></item><item><title>HTTPS</title><link>https://youngeun-in.github.io/https/</link><pubDate>Fri, 15 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/https/</guid><description>HTTP와 HTTPS의 가장 큰 차이점은 SSL 인증서이다. SSL인증서는 클라이언트와 서버간의 통신을 공인된 제 3차 업체(CA)가 보증해주는 전자화된 문서이다. SSL 인증서는 사용자가 사이트에서 제공하는 정보를 암호화한다. 암호화되어 전송되는 데이터는 중간에 누가 훔치거나 조작하려해도 암호화 되어있어서 해독할 수 없다.
HTTPS 방식은 공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 함께 사용한다. 데이터를 대칭키 방식으로 암복호화하고, 공개키 방식으로 대칭키를 전달한다.
HTTPS의 동작과정 클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색 Client Hello : 클라이언트가 서버에게 전송할 데이터</description></item></channel></rss>