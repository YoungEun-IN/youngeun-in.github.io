<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts -</title><link>https://youngeun-in.github.io/posts/</link><description>All Posts |</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 13 Dec 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>RAID</title><link>https://youngeun-in.github.io/raid/</link><pubDate>Tue, 13 Dec 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/raid/</guid><description>RAID (Redundant Array of Inexpensive/Independent Disk)는 저장장치(디스크) 여러 개를 묶어 고용량,고성능 저장 장치 한 개와 같은 효과를 얻기 위해 개발된 기법이다.
RAID는 여러개의 하드디스크를 함께 사용하는 방식을 말한다. 속도를 위해 함께 사용 할 수도 있고 안정성을 위해 함께 사용 할 수도 있고 둘다를 추구할 수도 있다.
RAID-0 속도 추구만을 위한 레이드 구성이다. 단순히 하드 여러개에 데이터를 분산시켜서 한꺼번에 입출력을 수행하는 것이다. 이를 스트라이핑(Disk striping) 기술이라고 한다.
예를 들면 1~10까지의 숫자를 저장하는데, 하드1에는 1 3 5 7 9, 하드2에는 2 4 6 8 10을 저장한다.</description></item><item><title>객체지향 설계 5원칙 SOLID</title><link>https://youngeun-in.github.io/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/</link><pubDate>Sat, 10 Dec 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/</guid><description>SRP (Single Responsibility Principle) - 단일 책임 원칙 SRP 원칙은 클래스가 하나의 기능만을 가지며, 어떤 변화에 의해 클래스를 변경해야하는 이유는 오직 하나 뿐이어야 한다는 원칙이다.
SRP에서는 책임자체가 분명해지기 때문에, 변경에 의한 연쇄 작용에서 자유로워 질 수가 있다.
OCP (Open-Closed Principle) - 개방-폐쇄 원칙 OCP 원칙은 변경을 위한 비용은 줄이고, 확장을 위한 비용은 늘려야 한다는 원칙이다.
요구사항의 변경이나 추가사항이 발생해도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성요소를 쉽게 확장하여 재사용가능하도록 만들어야 한다.</description></item><item><title>Bean vs Component</title><link>https://youngeun-in.github.io/bean-vs-component/</link><pubDate>Thu, 01 Dec 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/bean-vs-component/</guid><description>@Bean @Bean은 메소드 레벨에서 선언하며, 반환되는 객체(인스턴스)를 개발자가 수동으로 빈으로 등록하는 애노테이션이다.
1 2 3 4 5 6 7 @Configuration public class AppConfig { @Bean public MemberService memberService() { return new MemberServiceImpl(); } } @Component @Component는 클래스 레벨에서 선언함으로써 스프링이 런타임시에 컴포넌트스캔을 하여 자동으로 빈을 찾고(detect) 등록하는 애노테이션이다.
1 2 3 4 @Component public class Utility { // ... } @Bean vs @Component @Bean의 경우 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우에 사용된다.</description></item><item><title>스핀락, 분산락</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%95%80%EB%9D%BD-%EB%B6%84%EC%82%B0%EB%9D%BD/</link><pubDate>Wed, 26 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%95%80%EB%9D%BD-%EB%B6%84%EC%82%B0%EB%9D%BD/</guid><description>스핀 락 (Spin lock) 바쁜 대기의 개념을 이용한 락으로, 임계 구역(critical section)에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식으로 구현된 락이다.
스핀락이라는 이름은 락을 획득할 때까지 해당 스레드가 빙빙 돌고 있다(spinning)는 것에서 유래한다.
뮤텍스 락과의 차이점은 락을 얻을 수 없을때 스레드 슬립 모드로 빠지지 않고, 반복문을 계속 돌며 락을 얻으려는 시도를 한다는 것으로, 락이 해제될 때 별도의 스레드 문맥교환(context switching)에 대한 오버헤드 없이 임계구역에 접근을 한다는 점이다.</description></item><item><title>RuntimeException &amp; IOException</title><link>https://youngeun-in.github.io/runtimeexception-ioexception/</link><pubDate>Mon, 17 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/runtimeexception-ioexception/</guid><description>RuntimeException : Unchecked Exception 프로그램 실행 도중 발생하는 예외로, 프로그래머의 잘못으로 발생한다고 볼 수 있다.
배열의 범위를 넘어선 접근, Null 객채에 대한 접근, 잘못된 형 변환 등을 예로 들 수가 있다,
이러한 예외는 처리에 있어서 강제성을 띄지 않는다.
IOException : Checked Exception 런타임 예외는 언제 에러가 발생하는지 알 수 없기 때문에 처리를 하지 않아도 되지만,
IOException은 예외가 발생할 시점과 종류를 알 수 있기 때문에 반드시 처리를 해주어야 하는 강제성을 띄게 된다.</description></item><item><title>RestClientException</title><link>https://youngeun-in.github.io/restclientexception/</link><pubDate>Sat, 15 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/restclientexception/</guid><description>NestedRuntimeException RuntimeException의 root cause를 다루기 쉽게 래핑한 예외 클래스 내부적으로는 NestedExceptionUtils 라는 유틸리티 클래스를 이용한다. RestClientException 클라이언트 사이드의 HTTP 에러를 만났을 때 던져지는 기본 예외 클래스 RestClientResponseException 실제 HTTP 응답 데이터를 포함하고 있는 예외클래스들의 공통 기반 클래스 int 타입의 rawStatusCode를 가지고 있다. int rawStatusCode String statusText byte[] responseBody: getResponseBodyAsString() 메서드로 읽어올 수 있다. HttpHeaders responseHeaders String responseCharset HttpStatusCodeException HttpStatus (enum)를 기반으로 하여 만든 추상 클래스 getStatusCode() 메서드를 통해 HttpStatus를 읽어올 수 있다.</description></item><item><title>Lombok 어노테이션</title><link>https://youngeun-in.github.io/lombok-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/</link><pubDate>Mon, 10 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/lombok-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/</guid><description>생성자 자동 생성 Lombok을 사용하면 생성자를 자동으로 생성할 수 있다. @NoArgsConstructor 어노테이션은 파라미터가 없는 기본 생성자를 생성해주고, @AllArgsConstructor 어노테이션은 모든 필드 값을 파라미터로 받는 생성자를 만들어준다. 마지막으로 @RequiredArgsConstructor 어노테이션은 final이나 @NonNull인 필드 값만 파라미터로 받는 생성자를 만들어준다.
@RequiredArgsConstructor 이 어노테이션은 초기화 되지않은 final 필드나, @NonNull 이 붙은 필드에 대해 생성자를 생성해 준다. 주로 의존성 주입(Dependency Injection) 편의성을 위해서 사용된다.
@RequiredArgsConstructor 어노테이션은 스프링 의존성 주입의 특징 중 한가지를 이용하는데 이는 다음과 같다.</description></item><item><title>프레임워크 vs 라이브러리 vs API</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-vs-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-vs-api/</link><pubDate>Sat, 01 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-vs-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-vs-api/</guid><description>프레임워크 개발할 때에 빈번히 쓰여지는 범용 기능을 한꺼번에 제공해 개발 효율의 향상을 목표하는 소프트웨어 환경
특징 공통적인 개발환경을 제공한다. 개발할 수 있는 범위가 정해져 있다. 제어의 역전이 발생한다. (어플리케이션이 수동적으로 동작한다. ex: Spring, Django, Node.js) 라이브러리 재사용 가능한 코드의 집합
특징 개발하는데 필요한 것들을 모아 둔 일종의 저장소 필요할 때 호출해서 사용한다. 흐름을 제어한다. API 다른 프로그램이 제공하는 기능을 제어할 수 있게 만든 인터페이스
특징 다른 프로그램이나 서비스와 연결해 주는 다리 역할 구현이 아닌 제어의 역할 API를 조합해서 원하는 프로그램을 만들 수도 있다.</description></item><item><title>암호</title><link>https://youngeun-in.github.io/%EC%95%94%ED%98%B8/</link><pubDate>Thu, 01 Sep 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%95%94%ED%98%B8/</guid><description>암호 암호는 중요한 정보를읽기 어려운 값으로 변환하여 제 3자가 볼수 있도록 하는 기술이다.
암호로 가능한 것 기밀성 : 허가되지 않은 사용자는 암호화된 데이터의 원본을 볼 수 없는 성질
무결성 : 허락되지 않은 사용자가 암호화 데이터를 함부로 변조를 불가능하게 하거나 변조가 된 후에 데이터를 검증할 수 있는 성질
인증 : 정상적인 암호화 복호화 과정에서 정체성을 식별
부인 방지 : 정보를 보낸 사람이 정보를 보냈다는 사실을 부인하지 못하게 하는 성질</description></item><item><title>IPC(Inter Process Communication)</title><link>https://youngeun-in.github.io/ipcinter-process-communication/</link><pubDate>Tue, 07 Jun 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/ipcinter-process-communication/</guid><description>프로세스는 독립적으로 실행된다. 즉, 독립 되어있다는 것은 다른 프로세스에게 영향을 받지 않는다고 말할 수 있다. (스레드는 프로세스 안에서 자원을 공유하므로 영향을 받는다)
이런 독립적 구조를 가진 프로세스 간의 통신을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 IPC 통신이다.
프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다.
커널 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다. IPC 종류 익명 PIPE 파이프는 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다.</description></item></channel></rss>