<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts -</title><link>https://youngeun-in.github.io/posts/</link><description>All Posts |</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 11 Nov 2023 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>MVC 패턴</title><link>https://youngeun-in.github.io/mvc-%ED%8C%A8%ED%84%B4/</link><pubDate>Sat, 11 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/mvc-%ED%8C%A8%ED%84%B4/</guid><description>서블릿과 JSP의 한계 서블릿으로 개발할 때는 뷰(View)화면을 위한 HTML을 만드는 작업이 자바 코드에 섞여서 지저분하고 복잡했다.
JSP를 사용한 덕분에 뷰를 생성하는 HTML 작업을 깔끔하게 가져가고, 중간중간 동적으로 변경이 필요한 부분에만 자바 코드를 적용했다. 그러나 이러한 형태는 비즈니스 로직과 뷰 영역이 혼재되어 코드를 이해하기 어렵고 유지보수가 힘들어진다는 단점이 있다.
MVC 패턴 - 개요 하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면, 변경의 라이프 사이클이 다르기 때문에 유지보수하기 좋지 않다.</description></item><item><title>Web Server vs WAS</title><link>https://youngeun-in.github.io/web-server-vs-was/</link><pubDate>Fri, 10 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/web-server-vs-was/</guid><description>웹 서버(Web Server) HTTP 기반으로 동작 정적 리소스 제공, 기타 부가기능 정적(파일) HTML, CSS, JS, 이미지, 영상 예) NGINX, APACHE 웹 애플리케이션 서버(WAS - Web Application Server) HTTP 기반으로 동작 웹 서버 기능 포함+ (정적 리소스 제공 가능) 프로그램 코드를 실행해서 애플리케이션 로직 수행 동적 HTML, HTTP API(JSON) 서블릿, JSP, 스프링 MVC 예) 톰캣(Tomcat) Jetty, Undertow 웹 서버, 웹 애플리케이션 서버(WAS) 차이 웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직 사실은 둘의 용어도 경계도 모호함 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함 웹 애플리케이션 서버도 웹 서버의 기능을 제공함 자바는 서블릿 컨테이너 기능을 제공하면 WAS 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있음 WAS는 애플리케이션 코드를 실행하는데 더 특화 웹 시스템 구성 - WEB, WAS, DB 정적 리소스는 웹 서버가 처리 웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임 WAS는 중요한 애플리케이션 로직 처리 전담 효율적인 리소스 관리 정적 리소스가 많이 사용되면 Web 서버 증설 애플리케이션 리소스가 많이 사용되면 WAS 증설 WAS, DB 장애시 WEB 서버가 오류 화면 제공 가능 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽음 참고 https://www.</description></item><item><title>Servlet 동작 방식</title><link>https://youngeun-in.github.io/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/</link><pubDate>Thu, 09 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/</guid><description>서블릿 사용 시 HTTP 요청, 응답 흐름 HTTP 요청시 WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력 WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성 서블릿 컨테이너 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리 서블릿 객체는 싱글톤으로 관리 고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근 공유 변수 사용 주의 서블릿 컨테이너 종료시 함께 종료 JSP도 서블릿으로 변환 되어서 사용 동시 요청을 위한 멀티 쓰레드 처리 지원 웹 애플리케이션 서버의 요청 응답 구조 HttpServletRequest 역할 HTTP 요청 메시지를 개발자가 직접 파싱해서 사용해도 되지만, 매우 불편할 것이다.</description></item><item><title>사설IP, NAT, CIDR</title><link>https://youngeun-in.github.io/%EC%82%AC%EC%84%A4ip-nat-cidr/</link><pubDate>Sat, 04 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%82%AC%EC%84%A4ip-nat-cidr/</guid><description>사설 IP(Private IP) 사설 IP(Private IP)는 한정된 IP 주소를 최대한 활용하기 위해 IP주소를 분할하고자 만든 개념이다. IPV4 기준으로 최대 IP 개수는 약 43억개이다.
사설망 내부에는 외부 인터넷 망으로 통신이 불가능한 사설 IP가 구성된다. 그리고 외부로 통신할 때는 통신 가능한 공인 IP를 사용한다. 보통 하나의 망은 사설 IP를 부여받은 기기들과 NAT 기능을 갖춘 Gateway로 구성한다.
NAT(Network Address Translation) NAT(Network Address Translation)는 사설 IP가 공용 IP로 통신할 수 있도록 주소를 변환해주는 방법이다.</description></item><item><title>스프링 비동기</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/</link><pubDate>Sun, 29 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/</guid><description>외부 API에 작업 요청하고 외부 API서버에서 요청을 처리하는데 오랜시간이 걸리는 경우 비동기 방식으로 처리하면 효율적이다.
@EnableAsync @Async 는 비동기적으로 처리를 할 수 있게끔 스프링에서 제공하는 어노테이션이다. 해당 어노테이션을 붙이게 되면 각기 다른 쓰레드로 실행이 된다. 즉, 호출자는 해당 메서드가 완료되는 것을 기다릴 필요가 없다.
이 어노테이션을 사용하기 위해서는 @EnableAsync 가 달려있는 configuration 클래스가 우선적으로 필요하다. @EnableAsync 는 스프링의 @Async 어노테이션을 감지한다.
1 2 3 4 @Configuration @EnableAsync public class AsyncConfig { } @Async 어노테이션을 사용하기 위해서는 2가지 제약조건이 있다.</description></item><item><title>쿠버네티스 컴포넌트</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</link><pubDate>Thu, 12 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</guid><description>쿠버네티스 클러스터의 전체 구조 마스터에는 etcd, kube-apiserver, kube-scheduler, kube-controller-manager,kubelet, kube-proxy, docker 등의 컴포넌트가 실행된다. 컴포넌트 각각이 다른 마스터나 노드 서버에서 별개로 실행되어도 실제 쿠버네티스 클러스터를 운영하는 데 이상은 없다. 하지만 마스터가 서버 1대라면 방금 소개한 프로세스 한 묶음을 해당 서버에서 같이 실행하는 것이 일반적인 구성이다.
마스터는 보통 고가용성을 만족하고자 서버 3대 정도 구성해서 운영한다. 평소 실제 클러스터를 관리하는 리더 마스터는 1대고 나머지 2대는 대기한다. 리더 마스터에 장애가 발생하면자연스럽게 나머지 2대 중 1대가 리더 역할을 맡다.</description></item><item><title>쿠버네티스 관리 도구</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/</link><pubDate>Wed, 11 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/</guid><description>쿠버네티스를 제대로 활용하려면 여러 대 서버를 클러스터로 구성해 사용해야 한다. 서버 자원에 쿠버네티스 클러스터를 직접 구성할 때 활용하는 도구는 Kubeadm, Kubespray가 있다.
Kubeadm Kubeadm은 쿠버네티스에서 공식 제공하는 클러스터 생성/관리 도구이다. 여러 대 서버를 쿠버네티스 클러스터로 손쉽게 구성할 수 있다.
특징은 다음과 같다.
쿠버네티스에서 직접 제공하는 클러스터 생성 tool 클러스터 생성을 위해 필요한 기초 생성, 관리 명령어들이 포함된다. 클러스터를 관리하기 위한 것이므로 개별 node 에 대한 container runtime, kublet, cni 등은 알아서 설치가 필요하다.</description></item><item><title>쿠버네티스와 클라우드 네이티브</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/</link><pubDate>Mon, 25 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/</guid><description>클라우드 네이티브 클라우드 네이티브란 클라우드의 장점을 최대한 활용하여 정보 시스템을 구축 및 실행하는 환경이다.
클라우드 네이티브 기술은 조직이 퍼블릭, 프라이빗, 그리고 하이브리드 클라우드와 같은 현대적이고 동적인 환경에서 확장 가능한 애플리케이션을 개발하고 실행할 수 있게 해준다. 컨테이너, 서비스 메쉬, 마이크로서비스, 불변(Immutable) 인프라, 그리고 선언형(Declarative) API가 이러한 접근 방식의 예시들이다.
이 기술은 회복성, 관리 편의성, 가시성을 갖춘 느슨하게 결합된 시스템을 가능하게 한다. 견고한 자동화 기능을 함께 사용하면 엔지니어는 영향이 큰 변경을 최소한의 노력으로 예측 가능하게 수행할 수 있다.</description></item><item><title>하드링크, 심볼릭링크</title><link>https://youngeun-in.github.io/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/</link><pubDate>Mon, 11 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/</guid><description>inode 리눅스에는 inode 라는 개념이 있다. inode는 유닉스 계통의 파일 시스템에서 사용하는 자료 구조이다.
모든 파일과 디렉토리는 inode를 하나씩 가지고 있다. 그리고 여기에는 해당 파일의 허가권, 소유권, 파일의 실제 위치 등 중요한 정보들이 들어있다.
inode는 실제 파일의 내용을 갖고 있지는 않다. inode는 데이터의 우편번호 역할을 한다고 볼 수 있다. 즉, 파일의 내용을 갖고 있는 주소를 포함할 뿐이다.
리눅스 파일 링크 종류 하드 링크 (Hard link) 하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킨다.</description></item><item><title>HTTP</title><link>https://youngeun-in.github.io/http/</link><pubDate>Wed, 06 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/http/</guid><description>HTTP HTTP는 HyperText Transfer Protocol의 약자로, HTML, text, image, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터를 전송 가능한 프로토콜이다.
HTTP 특징 클라이언트-서버 구조 클라이언트는 서버에 요청을 보내고, 응답을 대기한다. 서버는 요청에 대한 결과를 만들어서 응답한다.
무상태 프로토콜(Stateless)) 서버가 클라이언트의 상태를 보존하지 않는다.
장점: 서버 확장성 높음(스케일 아웃) 단점: 클라이언트가 추가 데이터 전송 모든 것을 무상태로 설계 할 수 없는 경우에는 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지를 함으로써 무상태 프로토콜의 한계를 극복할 수 있다.</description></item></channel></rss>