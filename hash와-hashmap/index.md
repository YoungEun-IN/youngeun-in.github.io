# Hash와 HashMap


## 해싱

해싱은 **산술적인 연산을 이용하여 키가 있는 위치를 계산하여 찾아가는 검색 방식**이다. 키값을 원소 위치로 변환하는 함수를 해시 함수(Hash Function)라 한다. 해시 함수에 의해 계산된 주소에 저장할 값을 저장한 표를 해시 테이블(Hash Table)이라 한다. 해시 테이블은 빠른 검색 속도를 제공하는데 이유는 내부적으로 버킷(배열)을 사용하여 데이터를 저장하기 때문이다. 해시 테이블은 각각의 key 값에 해시 함수를 적용해 배열의 고유한 인덱스를 생성한 후 인덱스를 이용해 값을 저장한다. 실제 값이 저장되는 장소를 버킷이라 한다.

![image](https://user-images.githubusercontent.com/63634505/140446636-2d26f699-3b5d-495e-8439-f2d8d29adbc0.png)

어떤 수업을 듣는 10명의 학생에게 자리를 배정한다고 생각해보자. 이때 자리가 딱 10자리가 있고 10명의 학생은 각각 다른 이름을 가지고 있다. 그리고 좌석 번호를 생성하는 번호 생성기에 이름을 입력하면 좌석 번호가 나오게 된다. 이때 번호 생성기가 해시 함수의 역할을 한다. 그리고 좌석 번호와 학생 정보를 기록한 테이블은 해시 테이블이 된다.

## 해시 충돌

앞서 번호 생성기를 통하여 10명의 학생을 각각 자리에 앉혔다. 10명의 학생을 각각의 자리에 안내할 수 있었던 것은 사실 번호 생성기의 성능이 좋아 겹치지 않았다. 하지만 수업의 퀄리티가 좋아져 학생의 수가 갑자기 엄청나게 늘어났다. 기존의 번호 생성기는 0~20까지의 번호밖에 만들지 못했는데 학생의 수가 어느덧 30명이 되었다. 이제 필연적으로 겹치는 번호가 생성될 수밖에 없다. 그럼 이미 좌석 배정이 받은 학생이 있는 자리에 새로운 학생을 배정하게 되는데 이러한 경우가 해시 충돌 상황이다.

이러한 해시 충돌을 해결하는 방법에는 크게 두 가지 방법이 있다.

- Open Addressing
- Separate Chaining

**Open Addressing은 이미 자리에 누군가가 있으면 다른 곳으로 배정하는 방식**이다. 다른 곳에 배정하는 방식에 따라 Linear Probing과 Quadratic Probing 등의 방법이 있다.

**Separate Chaining은 해시 테이블의 구조를 변경하여 하나 이상의 키값을 저장할 수 있도록 하는 방법**이다. 이때 주로 사용하는 자료구조로 연결 리스트를 사용한다.

## HashMap 에서의 Separate Chaining

HashMap에서 사용하는 충돌기법 방식은 Separate Chaining이다. Java 8 이전에의 HashMap에서는 단순히 연결 리스트를 사용하였다. 하지만 **Java 8 이후부터는 데이터의 개수가 많아지면 연결 리스트가 아닌 트리 자료구조를 사용한다.** 정확히 말하자면 레드 블랙 트리 자료구조이다. 그렇다면 데이터의 개수가 많아진다는 기준점은 무엇일까?

하나의 해시 버킷에 8개의 키-값 쌍이 모이면 연결 리스트를 트리로 변경하게 된다. 또한 버킷의 데이터를 삭제하여 개수가 6개에 이르면 다시 연결 리스트로 변경한다. 그럼 왜 6과 7 또는 7과 8이 아닌 6과 8이 기준이겠냐는 의문이 생길 수 있다. 이유는 차이가 1일 경우 삽입/삭제가 반복되어 일어나면 불필요하게 트리와 연결 리스트로 변경하는 일이 발생하기 때문이다.

## 해시 버킷의 확장

버킷은 결국 배열로 구성되어 있다. 우리가 HashMap을 구현할 때 **따로 버킷의 개수를 지정 해주지 않았다면 기본값인 16으로 버킷의 개수가 지정된다. 해시 버킷의 개수가 일정 개수 이상이 되면 버킷의 개수를 2배로 늘리게 된다.** 버킷을 늘리면 해시 충돌의 가능성도 낮아져 해시 충돌로 인한 문제를 해결할 수도 있다. 하지만 두 배로 증가할 때마다 새로운 Separate Chaining을 구성해야 하는 문제가 있다. 가장 좋은 것은 버킷의 개수를 예측할 수 있다면 지정하여 HashMap을 생성하는 것이다. 따라서 데이터의 개수가 예측 가능하다면 지정하여 생성자의 인자로 넣어주면 불필요한 Separate Chaining을 줄일 수 있다.

### Load Factor

버킷의 수를 두 배로 늘릴 때 해시 버킷의 개수는 어떻게 정할까?  HashMap 클래스에 들어가 load factor 부분을 살펴보면 0.75f이라고 설정된 것을 볼 수 있다.

![image](https://user-images.githubusercontent.com/63634505/140446706-681ff318-2a7c-418a-9028-e46a3e8810dd.png)

이 의미는 데이터의 개수가 현재 버킷 개수의 0.75 즉 3/4 이 되었을 때 두 배로 확장한다는 뜻이다.

## 참고
https://tecoble.techcourse.co.kr/post/2021-11-05-hash-hashmap/

