<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>docker/kubernetes - Category -</title><link>https://youngeun-in.github.io/categories/docker/kubernetes/</link><description>docker/kubernetes - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="https://youngeun-in.github.io/categories/docker/kubernetes/" rel="self" type="application/rss+xml"/><item><title>쿠버네티스 컴포넌트</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</link><pubDate>Thu, 12 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</guid><description>쿠버네티스 클러스터의 전체 구조 마스터에는 etcd, kube-apiserver, kube-scheduler, kube-controller-manager,kubelet, kube-proxy, docker 등의 컴포넌트가 실행된다. 컴포넌트 각각이 다른 마스터나 노드 서버에서 별개로 실행되어도 실제 쿠버네티스 클러스터를 운영하는 데 이상은 없다. 하지만 마스터가 서버 1대라면 방금 소개한 프로세스 한 묶음을 해당 서버에서 같이 실행하는 것이 일반적인 구성이다.
마스터는 보통 고가용성을 만족하고자 서버 3대 정도 구성해서 운영한다. 평소 실제 클러스터를 관리하는 리더 마스터는 1대고 나머지 2대는 대기한다. 리더 마스터에 장애가 발생하면자연스럽게 나머지 2대 중 1대가 리더 역할을 맡다.</description></item><item><title>쿠버네티스 관리 도구</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/</link><pubDate>Wed, 11 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/</guid><description>쿠버네티스를 제대로 활용하려면 여러 대 서버를 클러스터로 구성해 사용해야 한다. 서버 자원에 쿠버네티스 클러스터를 직접 구성할 때 활용하는 도구는 Kubeadm, Kubespray가 있다.
Kubeadm Kubeadm은 쿠버네티스에서 공식 제공하는 클러스터 생성/관리 도구이다. 여러 대 서버를 쿠버네티스 클러스터로 손쉽게 구성할 수 있다.
특징은 다음과 같다.
쿠버네티스에서 직접 제공하는 클러스터 생성 tool 클러스터 생성을 위해 필요한 기초 생성, 관리 명령어들이 포함된다. 클러스터를 관리하기 위한 것이므로 개별 node 에 대한 container runtime, kublet, cni 등은 알아서 설치가 필요하다.</description></item><item><title>쿠버네티스와 클라우드 네이티브</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/</link><pubDate>Mon, 25 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/</guid><description>클라우드 네이티브 클라우드 네이티브란 클라우드의 장점을 최대한 활용하여 정보 시스템을 구축 및 실행하는 환경이다.
클라우드 네이티브 기술은 조직이 퍼블릭, 프라이빗, 그리고 하이브리드 클라우드와 같은 현대적이고 동적인 환경에서 확장 가능한 애플리케이션을 개발하고 실행할 수 있게 해준다. 컨테이너, 서비스 메쉬, 마이크로서비스, 불변(Immutable) 인프라, 그리고 선언형(Declarative) API가 이러한 접근 방식의 예시들이다.
이 기술은 회복성, 관리 편의성, 가시성을 갖춘 느슨하게 결합된 시스템을 가능하게 한다. 견고한 자동화 기능을 함께 사용하면 엔지니어는 영향이 큰 변경을 최소한의 노력으로 예측 가능하게 수행할 수 있다.</description></item><item><title>Dockerfile 명령어</title><link>https://youngeun-in.github.io/dockerfile-%EB%AA%85%EB%A0%B9%EC%96%B4/</link><pubDate>Tue, 12 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dockerfile-%EB%AA%85%EB%A0%B9%EC%96%B4/</guid><description><![CDATA[Dockerfile 포맷 하나의 Dockerfile은 기본적으로 다음과 같은 구조를 가진 여러 개의 명령문으로 구성되어 있다.
1 2  # 주석(Comment) 명령어(INSTRUCTION) 인자(arguments)   각 명령문은 명령어로 시작하고 여러 개의 인자가 따라올 수 있으며, 해당 명령문에 대한 주석도 달 수 있다. 인자와 구분이 쉽도록 명령어는 모두 영문 대문자로 써주는 것이 관례이다.
Dockerfile 명령문   FROM 명령문
  1 2  FROM &lt;이미지&gt; FROM &lt;이미지&gt;:&lt;태그&gt;    하나의 Docker 이미지는 base 이미지부터 시작해서 기존 이미지위에 새로운 이미지를 중첩해서 여러 단계의 이미지 층(layer)을 쌓아가며 만들어진다.]]></description></item><item><title>도커 명령어</title><link>https://youngeun-in.github.io/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/</link><pubDate>Mon, 11 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/</guid><description>Docker build 명령어 1 docker build -t 이미지명[:태그명] . -t 또는 &amp;ndash;tag 옵션은 새로 생성할 이미지의 이름을 지정할 때 사용하는 옵션이다. -t 옵션 뒤에 이미지명:태그를 적는다.
마지막에 있는 구둣점(.)은 도커파일(Dockerfile)이 현재 디렉토리에 있다는 뜻이다.
Docker run 명령어 이미지가 OS일 경우 이미지를 백그라운드 인터렉션 모드로 실행 1 docker run -dit 이미지명 bash 컨테이너에 접속 1 docker attach 컨테이너아이디 이미지가 Program일 경우 이미지를 백그라운드로 실행 1 docker run -d 이미지명 컨테이너에 인터렉션 모드로 접속 1 docker exec -it 컨테이너아이디 bash Docker run 옵션 종류 옵션 설명 -i, &amp;ndash;interactive - 표준 입력(stdin)을 활성화하며, 컨테이너와 연결(attach)되어 있지 않더라도 표준 입력을 유지한다.</description></item><item><title>도커</title><link>https://youngeun-in.github.io/%EB%8F%84%EC%BB%A4/</link><pubDate>Sun, 10 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%8F%84%EC%BB%A4/</guid><description>VM vs 컨테이너 VM 하드웨어 인프라스트러처 위에 VMWare나 VirtualBox와 같은 HyperVisor 소프트웨어를 이용해서 각각의 가상의 머신을 만들 수 있다. 한 운영체제 위에서 동일한 어플리케이션을 각각의 고립된 다른 환경에서 구동하기 위해서는 가상 머신을 이용해서 어플리케이션을 구동해야 했다. 이 가상 머신은 각각의운영체제를 포함하고 있기 때문에 맥이라는 OS 위에서 가상머신을 이용하면 윈도와 리눅스를 동시에 구동할 수 있다.
고립된 환경에서 애플리케이션을 구동하기 위해서 VM을 사용하면 운영 체제를 포함하고 있기 때문에 굉장히 무겁고 그리고 시작하는 데도 오래 걸리고 또 컴퓨터 운영체제 인프라스트럭처 리소스를 많이 잡아먹는 범인이 될 수도 있다.</description></item></channel></rss>