<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>spring - Category -</title><link>https://youngeun-in.github.io/categories/spring/</link><description>spring - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 11 Nov 2023 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/spring/" rel="self" type="application/rss+xml"/><item><title>MVC 패턴</title><link>https://youngeun-in.github.io/mvc-%ED%8C%A8%ED%84%B4/</link><pubDate>Sat, 11 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/mvc-%ED%8C%A8%ED%84%B4/</guid><description>서블릿과 JSP의 한계 서블릿으로 개발할 때는 뷰(View)화면을 위한 HTML을 만드는 작업이 자바 코드에 섞여서 지저분하고 복잡했다.
JSP를 사용한 덕분에 뷰를 생성하는 HTML 작업을 깔끔하게 가져가고, 중간중간 동적으로 변경이 필요한 부분에만 자바 코드를 적용했다. 그러나 이러한 형태는 비즈니스 로직과 뷰 영역이 혼재되어 코드를 이해하기 어렵고 유지보수가 힘들어진다는 단점이 있다.
MVC 패턴 - 개요 하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면, 변경의 라이프 사이클이 다르기 때문에 유지보수하기 좋지 않다.</description></item><item><title>스프링 비동기</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/</link><pubDate>Sun, 29 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/</guid><description>외부 API에 작업 요청하고 외부 API서버에서 요청을 처리하는데 오랜시간이 걸리는 경우 비동기 방식으로 처리하면 효율적이다.
@EnableAsync @Async 는 비동기적으로 처리를 할 수 있게끔 스프링에서 제공하는 어노테이션이다. 해당 어노테이션을 붙이게 되면 각기 다른 쓰레드로 실행이 된다. 즉, 호출자는 해당 메서드가 완료되는 것을 기다릴 필요가 없다.
이 어노테이션을 사용하기 위해서는 @EnableAsync 가 달려있는 configuration 클래스가 우선적으로 필요하다. @EnableAsync 는 스프링의 @Async 어노테이션을 감지한다.
1 2 3 4 @Configuration @EnableAsync public class AsyncConfig { } @Async 어노테이션을 사용하기 위해서는 2가지 제약조건이 있다.</description></item><item><title>스프링 시큐리티 Filter</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/</link><pubDate>Fri, 05 May 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/</guid><description>DelegatingFilterProxy와 FilterChainProxy DelegatingFilterProxy 일반적인 서블릿 필터이며, 서블릿 필터 처리를 스프링에 들어있는 빈으로 위임할 때 사용한다. 타겟 빈 이름을 설정할 수 있다.
스프링 부트 없이 스프링 시큐리티 설정할 때는 AbstractSecurityWebApplicationInitializer를 사용해서 등록해서 사용하며, 스프링 부트를 사용할 때는 자동으로 등록 된다. (SecurityFilterAutoConfiguration)
FilterChainProxy 스프링부트에서 &amp;ldquo;springSecurityFilterChain&amp;rdquo; 이라는 이름의 빈으로 등록된다.
스프링 시큐리티 Filter 스프링 시큐리티가 제공하는 필터들은 다음과 같다. 이 모든 필터는 FilterChainProxy가 호출한다.
WebAsyncManagerIntegrationFilter 스프링 MVC의 Async 기능을 사용할 때에도 SecurityContext를 공유하도록 도와주는 필터이다.</description></item><item><title>스프링 시큐리티 주요 개념</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link><pubDate>Thu, 04 May 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</guid><description>다음은 스프링 시큐리티에서 사용하는 주요 개념에 대한 설명이다.
SecurityContextHolder 지정된 SecurityContext를 현재 실행 스레드와 연결한다. 이 클래스는 SecurityContextHolderStrategy 인스턴스에 위임하는 일련의 정적 메서드를 제공한다.
클래스의 목적은 주어진 JVM에 사용해야 하는 전략을 지정하는 편리한 방법을 제공하는 것이다. 기본적으로 ThreadLocal을 사용한다.
SecurityContext 현재 실행 스레드와 관련된 최소 보안 정보를 정의하는 인터페이스이다. 보안 컨텍스트는 SecurityContextHolder에 저장되며, Authentication을 제공한다.
1 2 3 4 public interface SecurityContext extends Serializable { Authentication getAuthentication(); void setAuthentication(Authentication authentication); } AuthenticationManager 스프링 시큐리티에서 인증을 하는 주체이다.</description></item><item><title>Filter vs Interceptor vs AOP</title><link>https://youngeun-in.github.io/filter-vs-interceptor-vs-aop/</link><pubDate>Tue, 07 Mar 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/filter-vs-interceptor-vs-aop/</guid><description>Filter Filter(필터)는 요청과 응답을 거른 뒤 정제하는 역할을 한다. 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러 가지 체크를 수행할 수 있다. 또한 자원의 처리가 끝난 후 응답 내용에 대해서도 변경하는 처리를 할 수가 있다. 즉 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS 방어 등의 요청에 대한 처리로 사용된다.
init(): 필터 인스턴스 초기화 doFilter(): 전/후 처리 destroy(): 필터 인스턴스 종료 Interceptor 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답을 처리한다.</description></item><item><title>Dependency Injection</title><link>https://youngeun-in.github.io/dependency-injection/</link><pubDate>Sun, 05 Mar 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dependency-injection/</guid><description>Dependency Injection Dependency Injection은 말 그대로 의존성 주입을 말한다. 이는 객체 간의 의존성을 외부에서 주입하여 관리하겠다라는 개념이다. 의존성이 높으면 코드의 재사용성이 떨어지고 변경에 유연하지 못하며 테스트 코드를 작성하기 어려워진다.
외부에서 의존을 주입받으면 의존을 내부에서 정의하지 않기 때문에 객체 간의 의존성을 줄여주고 코드의 재사용성도 증가하며 변화에 민감하지 않을 수 있다. 이때 변화에 민감하다는 말은 객체 자신이 아니라 의존하고 있는 다른 객체의 변경으로부터 민감한 정도를 말한다. 의존의 정도가 작을수록 의존 객체의 변경에 크게 영향을 받지 않는다.</description></item><item><title>Spring PSA</title><link>https://youngeun-in.github.io/spring-psa/</link><pubDate>Wed, 15 Feb 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/spring-psa/</guid><description>PSA란 환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하는 추상화 구조를 말한다. POJO원칙을 철저히 따른 Spring의 기능으로 Spring에서 동작할 수 있는 Library들은 POJO원칙을 지키게끔 PSA형태의 추상화가 되어있음을 의미한다.
추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이다. 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다.
PSA 예시 Spring Web MVC 원래 Servlet을 사용하려면 HttpServlet을 상속받은 클래스를 만들고 Get, Post 등에 대한 메소드를 오버라이딩하여 사용해야 한다.</description></item><item><title>Bean vs Component</title><link>https://youngeun-in.github.io/bean-vs-component/</link><pubDate>Wed, 01 Feb 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/bean-vs-component/</guid><description>@Bean @Bean은 메소드 레벨에서 선언하며, 반환되는 객체(인스턴스)를 개발자가 수동으로 빈으로 등록하는 애노테이션이다.
1 2 3 4 5 6 7 @Configuration public class AppConfig { @Bean public MemberService memberService() { return new MemberServiceImpl(); } } @Component @Component는 클래스 레벨에서 선언함으로써 스프링이 런타임시에 컴포넌트스캔을 하여 자동으로 빈을 찾고(detect) 등록하는 애노테이션이다.
1 2 3 4 @Component public class Utility { // ... } @Bean vs @Component @Bean의 경우 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우에 사용된다.</description></item><item><title>RequestBody, ModelAttribute, RequestParam</title><link>https://youngeun-in.github.io/requestbody-modelattribute-requestparam/</link><pubDate>Fri, 20 Jan 2023 11:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/requestbody-modelattribute-requestparam/</guid><description>@RequestBody 클라이언트가 body에 JSON 또는 XML 형태로 값(보통 객체)을 담아 전송하면, body의 내용을 다시 Java Object(객체)로 변환해주는 역할을 수행한다. 이 데이터는 Spring에서 관리하는 MessageConverter들 중 하나인 Jackson2HttpMessageConverter를 통해 Java 객체로 변환된다.
DTO에 기본 생성자가 필요한 이유 RestController에서 @RequestBody의 바인딩은 Jackson라이브러리의 ObjectMapper가 해준다. ObjectMapper는 @RequestBody가 Property로 구현되어 있거나 생성을 위임한 경우가 아니라면 기본 생성자로 생성한다. 따라서 두 상황이 아니라면 기본 생성자는 꼭 필요하다.
Setter가 필요없는 이유 ObjectMapper는 Setter 또는 Getter로 DTO의 필드를 가져온다.</description></item><item><title>Bean Scope</title><link>https://youngeun-in.github.io/bean-scope/</link><pubDate>Wed, 04 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/bean-scope/</guid><description>Bean은 스프링에서 사용하는 POJO 기반 객체다. 상황과 필요에 따라 Bean을 사용할 때 하나만 만들어야 할 수도 있고, 여러개가 필요할 때도 있고, 어떤 한 시점에서만 사용해야할 때가 있을 수 있다. 이를 위해 Scope를 설정해서 Bean의 사용 범위를 개발자가 설정할 수 있다.
우선 따로 설정을 해주지 않으면, Spring에서 Bean은 Singleton으로 생성된다. 특정 타입의 Bean을 딱 하나만 만들고 모두 공유해서 사용하기 위함이다. 보통은 Bean을 이렇게 하나만 만들어 사용하는 경우가 대부분이지만, 요구사항이나 구현에 따라 아닐 수도 있을 것이다.</description></item></channel></rss>