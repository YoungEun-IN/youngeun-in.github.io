<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>spring - Category -</title><link>https://youngeun-in.github.io/categories/spring/</link><description>spring - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 29 Oct 2023 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/spring/" rel="self" type="application/rss+xml"/><item><title>스프링 비동기</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/</link><pubDate>Sun, 29 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/</guid><description>외부 API에 작업 요청하고 외부 API서버에서 요청을 처리하는데 오랜시간이 걸리는 경우 비동기 방식으로 처리하면 효율적이다.
@EnableAsync @Async 는 비동기적으로 처리를 할 수 있게끔 스프링에서 제공하는 어노테이션이다. 해당 어노테이션을 붙이게 되면 각기 다른 쓰레드로 실행이 된다. 즉, 호출자는 해당 메서드가 완료되는 것을 기다릴 필요가 없다.
이 어노테이션을 사용하기 위해서는 @EnableAsync 가 달려있는 configuration 클래스가 우선적으로 필요하다. @EnableAsync 는 스프링의 @Async 어노테이션을 감지한다.
1 2 3 4 @Configuration @EnableAsync public class AsyncConfig { } @Async 어노테이션을 사용하기 위해서는 2가지 제약조건이 있다.</description></item><item><title>스프링 시큐리티 Filter</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/</link><pubDate>Fri, 05 May 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/</guid><description>DelegatingFilterProxy와 FilterChainProxy DelegatingFilterProxy 일반적인 서블릿 필터이며, 서블릿 필터 처리를 스프링에 들어있는 빈으로 위임할 때 사용한다. 타겟 빈 이름을 설정할 수 있다.
스프링 부트 없이 스프링 시큐리티 설정할 때는 AbstractSecurityWebApplicationInitializer를 사용해서 등록해서 사용하며, 스프링 부트를 사용할 때는 자동으로 등록 된다. (SecurityFilterAutoConfiguration)
FilterChainProxy 스프링부트에서 &amp;ldquo;springSecurityFilterChain&amp;rdquo; 이라는 이름의 빈으로 등록된다.
스프링 시큐리티 Filter 스프링 시큐리티가 제공하는 필터들은 다음과 같다. 이 모든 필터는 FilterChainProxy가 호출한다.
WebAsyncManagerIntegrationFilter 스프링 MVC의 Async 기능을 사용할 때에도 SecurityContext를 공유하도록 도와주는 필터이다.</description></item><item><title>스프링 시큐리티 주요 개념</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link><pubDate>Thu, 04 May 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</guid><description>다음은 스프링 시큐리티에서 사용하는 주요 개념에 대한 설명이다.
SecurityContextHolder 지정된 SecurityContext를 현재 실행 스레드와 연결한다. 이 클래스는 SecurityContextHolderStrategy 인스턴스에 위임하는 일련의 정적 메서드를 제공한다.
클래스의 목적은 주어진 JVM에 사용해야 하는 전략을 지정하는 편리한 방법을 제공하는 것이다. 기본적으로 ThreadLocal을 사용한다.
SecurityContext 현재 실행 스레드와 관련된 최소 보안 정보를 정의하는 인터페이스이다. 보안 컨텍스트는 SecurityContextHolder에 저장되며, Authentication을 제공한다.
1 2 3 4 public interface SecurityContext extends Serializable { Authentication getAuthentication(); void setAuthentication(Authentication authentication); } AuthenticationManager 스프링 시큐리티에서 인증을 하는 주체이다.</description></item><item><title>Bean Scope</title><link>https://youngeun-in.github.io/bean-scope/</link><pubDate>Wed, 04 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/bean-scope/</guid><description>Bean은 스프링에서 사용하는 POJO 기반 객체다. 상황과 필요에 따라 Bean을 사용할 때 하나만 만들어야 할 수도 있고, 여러개가 필요할 때도 있고, 어떤 한 시점에서만 사용해야할 때가 있을 수 있다. 이를 위해 Scope를 설정해서 Bean의 사용 범위를 개발자가 설정할 수 있다.
우선 따로 설정을 해주지 않으면, Spring에서 Bean은 Singleton으로 생성된다. 특정 타입의 Bean을 딱 하나만 만들고 모두 공유해서 사용하기 위함이다. 보통은 Bean을 이렇게 하나만 만들어 사용하는 경우가 대부분이지만, 요구사항이나 구현에 따라 아닐 수도 있을 것이다.</description></item><item><title>스프링의 싱글톤 설정</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/</link><pubDate>Tue, 03 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/</guid><description>싱글톤 패턴 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다. 싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 하지만 싱글톤 패턴은 다음과 같은 문제점들을 가지고 있다.
싱글톤 패턴 문제점 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다. 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다. 테스트하기 어렵다. 내부 속성을 변경하거나 초기화 하기 어렵다.</description></item><item><title>스프링이란?</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/</link><pubDate>Mon, 02 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/</guid><description>스프링(Spring)이란? 자바 플랫폼을 위한 자바 언어 기반의 오픈 소스 애플리케이션 프레임워크 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크 스프링 생태계 스프링 프레임워크 필수 항목 내용 코어 기술 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술 스프링 MVC, 스프링 WebFlux 데이터 접근 기술 트랜잭션, JDBC, ORM 지원, XML 지원 통합 기술 캐시, 이메일, 원격 접근, 스케줄링 선택 스프링 데이터 스프링 세션 스프링 시큐리티 스프링 Rest Docs 스프링 배치 스프링 클라우드 스프링의 특징 경량 컨테이너 &amp;amp; 자바 객체 직접 관리 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리한다.</description></item><item><title>Spring의 등장 배경</title><link>https://youngeun-in.github.io/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/</link><pubDate>Sun, 01 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/</guid><description>EJB(Enterprise Java Beans)와 POJO(Plain Old Java Object) EJB(Enterprise Java Beans) 개념 기업환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델 애플리케이션의 업무 로직을 가지고 있는 서버 애플리케이션 Java EE의 자바 API 중 하나 특징 동시 접속자 수가 많은 가운데 안정적인 트랜잭션이 필요한 사이트 구축시 사용하는 컴포넌트 기술 ex) 공공기관, 기상청, 병무청, 금융, 보험, 포털사이트, 게임사이트, 기업 등.. JSP, Beans를 사용한 시스템보다 속도는 느리지만, 개발시 개발자에게 많은 자동화된 기능을 제공하여 안정적인 분산 시스템 구축 및 제공을 용이하게 함 기초 기술(JSP, BEANS, RMI, Servlet, Serialization, Transaction, Connection Pooling)을 알면 학습 및 사용이 쉬움 EJB 규약을 집중적으로 습득하면 쉽게 EJB 컴포넌트 개발 가능 장단점 장점 단점 많은 동시접속자에 대한 안정성 지원 객체지향적이지 않음 처리 메소드를 컨테이너가 트랜잭션 자동 처리 복잡한 프로그래밍 모델 빈즈의 상태를 메모리에서 사용 여부에 따라 자동으로 활성화/비활성화 실행하여 관리 특정 환경·기술에 종속적인 코드 다층 구조 시스템 구축 가능 컨테이너 안에서만 동작할 수 있는 객체 구조 라이프 사이클, 보안, Threading 등의 서비스 제공 부족한 개발생산성 및 이동성 POJO(Plain Old Java Object) 특정 자바 모델이나 기능, 프레임워크 등에 종속되지 않고, 클래스 패스(class path)를 필요로 하지 않는 일반적인 Java Object 중량 프레임워크들(Java EE 등&amp;hellip;)을 사용하게 되면서 해당 프레임워크에 종속된 &amp;ldquo;무거운&amp;rdquo; 객체를 만들게 된 것에 반발해서 사용하게 됨 2000년 9월 마틴 파울러, 레베카 파슨, 조쉬 맥킨지 등에 의해 사용되기 시작함 Spring과 Hibernate의 등장 EJB의 단점들로 인해 대표적으로 2가지의 Open Source가 등장하게 되었다.</description></item><item><title>Bean vs Component</title><link>https://youngeun-in.github.io/bean-vs-component/</link><pubDate>Thu, 01 Dec 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/bean-vs-component/</guid><description>@Bean @Bean은 메소드 레벨에서 선언하며, 반환되는 객체(인스턴스)를 개발자가 수동으로 빈으로 등록하는 애노테이션이다.
1 2 3 4 5 6 7 @Configuration public class AppConfig { @Bean public MemberService memberService() { return new MemberServiceImpl(); } } @Component @Component는 클래스 레벨에서 선언함으로써 스프링이 런타임시에 컴포넌트스캔을 하여 자동으로 빈을 찾고(detect) 등록하는 애노테이션이다.
1 2 3 4 @Component public class Utility { // ... } @Bean vs @Component @Bean의 경우 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우에 사용된다.</description></item><item><title>Filter, Interceptor, AOP</title><link>https://youngeun-in.github.io/filter-interceptor-aop/</link><pubDate>Sat, 07 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/filter-interceptor-aop/</guid><description>Filter Filter(필터)는 요청과 응답을 거른 뒤 정제하는 역할을 한다. 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러 가지 체크를 수행할 수 있다. 또한 자원의 처리가 끝난 후 응답 내용에 대해서도 변경하는 처리를 할 수가 있다. 즉 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS 방어 등의 요청에 대한 처리로 사용된다.
init(): 필터 인스턴스 초기화 doFilter(): 전/후 처리 destroy(): 필터 인스턴스 종료 Interceptor 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답을 처리한다.</description></item><item><title>Dependency Injection</title><link>https://youngeun-in.github.io/dependency-injection/</link><pubDate>Sat, 05 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dependency-injection/</guid><description>Dependency Injection Dependency Injection은 말 그대로 의존성 주입을 말한다. 이는 객체 간의 의존성을 외부에서 주입하여 관리하겠다라는 개념이다. 의존성이 높으면 코드의 재사용성이 떨어지고 변경에 유연하지 못하며 테스트 코드를 작성하기 어려워진다.
외부에서 의존을 주입받으면 의존을 내부에서 정의하지 않기 때문에 객체 간의 의존성을 줄여주고 코드의 재사용성도 증가하며 변화에 민감하지 않을 수 있다. 이때 변화에 민감하다는 말은 객체 자신이 아니라 의존하고 있는 다른 객체의 변경으로부터 민감한 정도를 말한다. 의존의 정도가 작을수록 의존 객체의 변경에 크게 영향을 받지 않는다.</description></item></channel></rss>