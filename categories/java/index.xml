<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>java - Category -</title><link>https://youngeun-in.github.io/categories/java/</link><description>java - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 17 Mar 2022 18:36:46 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/java/" rel="self" type="application/rss+xml"/><item><title>추상클래스 vs 인터페이스</title><link>https://youngeun-in.github.io/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</link><pubDate>Thu, 17 Mar 2022 18:36:46 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</guid><description>추상클래스 자바에서는 하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 추상 클래스(abstract class)라고 한다. 이러한 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해준다. 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로, 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야 할 경우 사용한다.
인터페이스 인터페이스는 객체의 사용 방법을 정의한 타입이다. 인터페이스는 상속 관계를 타고 올라갔을 때 다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다.</description></item><item><title>자바의 Proxy 구현</title><link>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/</link><pubDate>Mon, 07 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/</guid><description><![CDATA[Pure Java, JDK Dynamic Proxy, CGLib Dynamic Proxy를 이용하여 문자열을 대문자로 변환하는 프록시를 구현해보도록 하자. 인터페이스와 타겟 클래스는 다음과 같다.
1 2 3 4 5  public interface Hello { String sayHello(String name); String sayHi(String name); String sayThankyou(String name); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class HelloTarget implements Hello { @Override public String sayHello(String name) { return &#34;Hello &#34; + name; } @Override public String sayHi(String name) { return &#34;Hi &#34; + name; } @Override public String sayThankyou(String name) { return &#34;Thankyou &#34; + name; } }   예상 결과는 다음과 같다.]]></description></item><item><title>DTO vs VO</title><link>https://youngeun-in.github.io/dto-vs-vo/</link><pubDate>Fri, 04 Mar 2022 09:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dto-vs-vo/</guid><description>DTO Data Transfer Object의 약자로 계층(Layer) 간 데이터를 전달하는 객체이다.
조금 더 쉽게 말하면, 데이터를 담아서 전달하는 바구니라고 할 수 있다.
Controller는 View와 도메인 Model의 데이터를 주고 받을 때 별도의 DTO 를 주로 사용한다. 도메인 객체를 View에 직접 전달할 수 있지만, 민감한 도메인 비즈니스 기능이 노출될 수 있으며 Model과 View 사이에 의존성이 생기기 때문이다.
DTO는 데이터 접근 메서드(Getter, Setter), 생성자 외에 기능을 갖지 않는다. (정렬, 직렬화 등 데이터 표현을 위한 기능은 가질 수 있다.</description></item><item><title>volatile</title><link>https://youngeun-in.github.io/volatile/</link><pubDate>Thu, 03 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/volatile/</guid><description>volatile란? volatile 키워드는 java 변수를 Main Memory에 저장하겠다라는 것을 명시한다. 즉 매번 변수의 값을 읽을 때마다 CPU cache에 저장된 값이 아닌 Main Memory에서 읽는 것이다. 또한 변수의 값을 쓸 때마다 Main Memory까지 작성한다.
volatile 키워드의 필요성 멀티쓰레드 어플리케이션에서의 non-volatile 변수에 대한 작업은 성능상의 이유로 CPU 캐시를 이용한다. 둘 이상의 CPU가 탑재된 컴퓨터에서 어플리케이션을 실행한다면, 각 쓰레드는 변수를 각 CPU의 캐시로 복사하여 읽어들인다.
쓰레드가 변경한 값이 메인 메모리에 저장되지 않아서 다른 쓰레드가 이 값을 볼 수 없는 상황을 &amp;lsquo;가시성&amp;rsquo; 문제라 한다.</description></item><item><title>싱글톤 패턴 구현</title><link>https://youngeun-in.github.io/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/</link><pubDate>Thu, 03 Mar 2022 10:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/</guid><description>싱글톤 패턴은 프로세스(Java에서는 JVM) 내에 1개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역 접근점을 제공하는 패턴이다.
Eager Initialization 싱글톤 패턴을 가장 단순하게 구현하는 방법은 외부에서 해당 클래스의 인스턴스를 생성할 수 없도록 private 생성자를 만들고, 1개의 인스턴스만을 초기화(public static final)하여 이에 대한 접근을 제공하는 방식이다.
1 2 3 4 5 6 7 8 public class SimpleSingleton { //public static final으로 1개의 인스턴스만을 초기화하여 접근점을 제공하고, 2개 이상의 인스턴스를 못 만들게 한다.</description></item><item><title>HashMap vs HashTable vs ConcurrentHashMap</title><link>https://youngeun-in.github.io/hashmap-vs-hashtable-vs-concurrenthashmap/</link><pubDate>Thu, 03 Mar 2022 09:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/hashmap-vs-hashtable-vs-concurrenthashmap/</guid><description>각 자료구조는 필요에 따라 선택되고 활용된다. Map 인터페이스의 구현체로는 HashMap, HashTable, ConcurrentHashMap 등이 있다. Map 인터페이스를 구현하면, &amp;lt;Key, Value&amp;gt; 형태를 띈다. 그렇다면 이 셋은 무슨 특징을 가지고, 서로 어떤 차이가 있을까? 이번 글에서 해당 구현체를 비교하며 확인해보자.
HashMap key와 value에 null을 허용한다. 동기화를 보장하지 않는다. HashMap은 thread-safe하지 않아, 싱글 쓰레드 환경에서 사용하는 게 좋다. 한편, 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다. 결국 HashTable과 ConcurrentHashMap보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어진다.</description></item><item><title>자바의 Reflection</title><link>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/</link><pubDate>Wed, 02 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/</guid><description>Reflection API란? 아래와 같이 Car 클래스가 존재한다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Car { private final String name; private int position; public Car(String name, int position) { this.name = name; this.position = position; } public void move() { this.position++; } public int getPosition() { return position; } } 자바의 특징 중 하나인 다형성 덕분에 아래와 같이 객체 생성이 가능하다.</description></item><item><title>Garbage Collection</title><link>https://youngeun-in.github.io/garbage-collection/</link><pubDate>Tue, 01 Mar 2022 17:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/garbage-collection/</guid><description>Garbage Collection Garbage Collection, GC는 JVM 상에서 더 이상 사용되지 않는 데이터가 할당되어있는 메모리를 해제시키는 작업이다. JVM에서 자동으로 동작하기 때문에 특별한 경우가 아니면 메모리 관리를 개발자가 직접 해줄 필요가 없다.
참조되고 있는지에 대한 개념을 reachability라고 하고, 유효한 참조를 reachable, 유효하지 않은 참조를 unreachable이라고 한다. Garbace Collector는 unreachable 한 객체들을 garbage라고 인식한다.
Heap 영역 내부의 객체들은 Method Area, Stack, Native Stack에서 참조되면 reachable로 판정된다. 이렇게 reachable로 인식되게 만들어주는 JVM Runtime Area들을 root set 이라고 한다.</description></item><item><title>Java 실행 과정</title><link>https://youngeun-in.github.io/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/</link><pubDate>Tue, 01 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/</guid><description>1. 컴파일 자바 소스 파일(*.java)을 Java Compiler가 JVM이 해석할 수 있는 파일인 Java ByteCode (*.class)파일로 변환한다. Java Compiler는 Java 설치 시 Javac.exe라는 실행 파일 형태로 존재한다.
2. Class Loader를 통해 ByteCode를 메모리(Runtime Data Area)에 배치 ClassLoader는 크게 Loading, Linking, 그리고 Initialization 3가지 역할을 한다.
Loading .class 확장자를 가진 클래스 파일은 각 디렉터리에 흩어져 있다. 또한, 기본적인 라이브러리의 클래스 파일들은 $JAVAHOME_ 내부 경로에 존재한다. 각각의 클래스 파일들을 찾아서 JVM 의 메모리에 탑재해주는 역할을 하는 것이 ClassLoader의 역할이다.</description></item><item><title>JVM 의 메모리 영역</title><link>https://youngeun-in.github.io/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/</link><pubDate>Tue, 01 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/</guid><description>JVM의 메모리 영역은 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 세분화된다.
Method Area Method Area 에는 클래스, 인터페이스, 생성자, 메소드, Runtime Constant Pool과 static 변수 등이 저장된다. 이 영역은 JVM 당 하나만 생성이 되며 JVM 의 모든 Thread 들이 Method Area 을 공유한다. JVM 구동 시작 시에 생성이 되며, 종료 시까지 유지된다.
Heap Heap 영역에는 문자열에 대한 정보를 가진 String Pool 뿐만 아니라 실제 데이터를 가진 인스턴스, 배열 등이 저장된다.</description></item></channel></rss>