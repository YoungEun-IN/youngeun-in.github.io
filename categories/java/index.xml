<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>java - Category -</title><link>https://youngeun-in.github.io/categories/java/</link><description>java - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 22 Jul 2023 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/java/" rel="self" type="application/rss+xml"/><item><title>JAVA NIO 기반의 입출력</title><link>https://youngeun-in.github.io/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/</link><pubDate>Sat, 22 Jul 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/</guid><description>NIO의 채널(Channel)과 버퍼(Buffer) 스트림과 채널의 공통점
스트림도 채널도 데이터의 입력 및 출력을 위한 통로가 된다. 스트림과 채널의 차이점
스트림은 한 방향으로만 데이터가 이동하지만 채널은 양방향으로 데이터 이동이 가능하다. 채널에만 존재하는 제약사항
채널은 반드시 버퍼에 연결해서 사용해야 한다. 채널 기반 데이터 입출력 경로
출력 경로: 데이터 ⇨ 버퍼 ⇨ 채널 ⇨ 파일 입력 경로: 데이터 ⇦ 버퍼 ⇦ 채널 ⇦ 파일 채널과 버퍼는 독립적이다.</description></item><item><title>Java에서 String이 불변인 이유</title><link>https://youngeun-in.github.io/java%EC%97%90%EC%84%9C-string%EC%9D%B4-%EB%B6%88%EB%B3%80%EC%9D%B8-%EC%9D%B4%EC%9C%A0/</link><pubDate>Wed, 15 Feb 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java%EC%97%90%EC%84%9C-string%EC%9D%B4-%EB%B6%88%EB%B3%80%EC%9D%B8-%EC%9D%B4%EC%9C%A0/</guid><description>Java에서 String이 불변인 이유 String은 기본 타입(Primitive Type)이 아닌 참조 타입(Reference Type)이다. 즉, String은 클래스이다.
Java에서 String 객체를 리터럴로 선언하면 특별히 스택 메모리에 직접 저장되는 것이 아니라 Heap 영역 중에서 String constant pool이라는 곳에 메모리를 할당받아 거기에 값을 저장한다. 그리고 String 변수는 그 주소 값을 참조하게 된다. 따라서 Java에서 String은 불변성을 띄게 된다.
Java에서 String이 불변인 이유는 다음과 같다.
String pool을 통해 String을 관리함으로써 Java는 Runtime에서 Heap 영역의 많은 메모리를 절약할 수 있다.</description></item><item><title>Array vs ArrayList</title><link>https://youngeun-in.github.io/array-vs-arraylist/</link><pubDate>Sun, 15 Jan 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/array-vs-arraylist/</guid><description>Resizable Array Array는 static하다(길이 고정). Array 객체를 생성한 후에는 Array의 길이를 마음대로 변경할 수 없다. 따라서, 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어주어야 한다.
ArrayList ArrayList는 사이즈가 dynamic하다. 하지만 내부적으론 배열로 구성되어 있다. ArrayList는 Default로 10개의 공간을 가진 배열로 시작한다. 하지만 최적화(지연 초기화)로 인해 막 생성하면 0개의 사이즈로 시작된다.
각각의 ArrayList Object는 ArrayList의 size를 나타내는 capacity 인스턴스 변수를 가지고 있다. ArrayList에 요소들이 더해지면 ArrayList의 capacity 또한 자동적으로 늘어난다.</description></item><item><title>RuntimeException &amp; IOException</title><link>https://youngeun-in.github.io/runtimeexception-ioexception/</link><pubDate>Mon, 17 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/runtimeexception-ioexception/</guid><description>RuntimeException : Unchecked Exception 프로그램 실행 도중 발생하는 예외로, 프로그래머의 잘못으로 발생한다고 볼 수 있다.
배열의 범위를 넘어선 접근, Null 객채에 대한 접근, 잘못된 형 변환 등을 예로 들 수가 있다,
이러한 예외는 처리에 있어서 강제성을 띄지 않는다.
IOException : Checked Exception 런타임 예외는 언제 에러가 발생하는지 알 수 없기 때문에 처리를 하지 않아도 되지만,
IOException은 예외가 발생할 시점과 종류를 알 수 있기 때문에 반드시 처리를 해주어야 하는 강제성을 띄게 된다.</description></item><item><title>RestClientException</title><link>https://youngeun-in.github.io/restclientexception/</link><pubDate>Sat, 15 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/restclientexception/</guid><description>NestedRuntimeException RuntimeException의 root cause를 다루기 쉽게 래핑한 예외 클래스 내부적으로는 NestedExceptionUtils 라는 유틸리티 클래스를 이용한다. RestClientException 클라이언트 사이드의 HTTP 에러를 만났을 때 던져지는 기본 예외 클래스 RestClientResponseException 실제 HTTP 응답 데이터를 포함하고 있는 예외클래스들의 공통 기반 클래스 int 타입의 rawStatusCode를 가지고 있다. int rawStatusCode String statusText byte[] responseBody: getResponseBodyAsString() 메서드로 읽어올 수 있다. HttpHeaders responseHeaders String responseCharset HttpStatusCodeException HttpStatus (enum)를 기반으로 하여 만든 추상 클래스 getStatusCode() 메서드를 통해 HttpStatus를 읽어올 수 있다.</description></item><item><title>Lombok 어노테이션</title><link>https://youngeun-in.github.io/lombok-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/</link><pubDate>Mon, 10 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/lombok-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/</guid><description>생성자 자동 생성 Lombok을 사용하면 생성자를 자동으로 생성할 수 있다.
@NoArgsConstructor 어노테이션 : 파라미터가 없는 기본 생성자를 생성해준다. @AllArgsConstructor 어노테이션 : 모든 필드 값을 파라미터로 받는 생성자를 만들어준다. @RequiredArgsConstructor 어노테이션 : final이나 @NonNull인 필드 값만 파라미터로 받는 생성자를 만들어준다. 주로 의존성 주입(Dependency Injection) 편의성을 위해서 사용된다. @RequiredArgsConstructor 어노테이션 @RequiredArgsConstructor 어노테이션은 스프링 의존성 주입의 특징 중 한가지를 이용하는데 이는 다음과 같다.
어떠한 빈(Bean)에 생성자가 오직 하나만 있고, 생성자의 파라미터 타입이 빈으로 등록 가능한 존재라면 이 빈은 @Autowired 어노테이션 없이도 의존성 주입이 가능하다.</description></item><item><title>프레임워크 vs 라이브러리 vs API</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-vs-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-vs-api/</link><pubDate>Sat, 01 Oct 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-vs-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-vs-api/</guid><description>프레임워크 개발할 때에 빈번히 쓰여지는 범용 기능을 한꺼번에 제공해 개발 효율의 향상을 목표하는 소프트웨어 환경
특징 공통적인 개발환경을 제공한다. 개발할 수 있는 범위가 정해져 있다. 제어의 역전이 발생한다. (어플리케이션이 수동적으로 동작한다. ex: Spring, Django, Node.js) 라이브러리 재사용 가능한 코드의 집합
특징 개발하는데 필요한 것들을 모아 둔 일종의 저장소 필요할 때 호출해서 사용한다. 흐름을 제어한다. API 다른 프로그램이 제공하는 기능을 제어할 수 있게 만든 인터페이스
특징 다른 프로그램이나 서비스와 연결해 주는 다리 역할 구현이 아닌 제어의 역할 API를 조합해서 원하는 프로그램을 만들 수도 있다.</description></item><item><title>Hash와 HashMap</title><link>https://youngeun-in.github.io/hash%EC%99%80-hashmap/</link><pubDate>Sun, 15 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/hash%EC%99%80-hashmap/</guid><description>해싱 해싱은 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 찾아가는 검색 방식이다. 키값을 원소 위치로 변환하는 함수를 해시 함수(Hash Function)라 한다. 해시 함수에 의해 계산된 주소에 저장할 값을 저장한 표를 해시 테이블(Hash Table)이라 한다. 해시 테이블은 빠른 검색 속도를 제공하는데 이유는 내부적으로 버킷(배열)을 사용하여 데이터를 저장하기 때문이다. 해시 테이블은 각각의 key 값에 해시 함수를 적용해 배열의 고유한 인덱스를 생성한 후 인덱스를 이용해 값을 저장한다. 실제 값이 저장되는 장소를 버킷이라 한다.</description></item><item><title>Java 스레드풀</title><link>https://youngeun-in.github.io/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/</link><pubDate>Sat, 23 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/</guid><description>스레드풀 스레드풀 생성 스레드가 기하급수적으로 늘어난다면 스레드 생성과 스케줄링으로 인해 CPU의 메모리 사용량이 늘어나고 어플리케이션의 성능의 저하가 일어난다. 병렬작업의 급증을 막기 위해서는 특정 스레드 개수만큼 작업 컨베이어 벨트 (작업 큐)를 만들어 놓고 작업을 컨베이어 벨트에 올려놓아 작업이 끝난 스레드가 컨베이어에서 작업을 꺼내 기능을 수행하는 방식으로 작업을 구성할 수 있다. 아무리 작업 처리 요청이 폭주하여도 스레드의 전체 개수가 늘어나지 않기 때문에 어플리케이션의 성능이 급격하게 저하되지 않는다.
자바는 스레드 풀을 생성하고 사용할 수 있도록 java.</description></item><item><title>Java 스레드</title><link>https://youngeun-in.github.io/java-%EC%8A%A4%EB%A0%88%EB%93%9C/</link><pubDate>Fri, 22 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-%EC%8A%A4%EB%A0%88%EB%93%9C/</guid><description>스레드 모든 자바 어플리케이션은 Main Thread가 main() 메소드를 실행하면서 시작된다. Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 만들어 병렬로 코드를 실행할 수 있다. 싱글 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만, 멀티 스레드는 메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. 프로세스 내부에서의 멀티 스레드는 공유되는 자원이 있어 하나의 스레드에서 예외가 발생한다면 프로세스 자체가 종료될 수 있다.
Thread 생성 Thread 클래스로부터 직접 생성 new를 통해 Thread 클래스 객체를 생성 후 start 메서드를 통해 다른 스레드에서 할 작업을 할당하는 방법이다.</description></item></channel></rss>