<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>java - Category -</title><link>https://youngeun-in.github.io/categories/java/</link><description>java - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 01 Mar 2022 16:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/java/" rel="self" type="application/rss+xml"/><item><title>Java 실행 과정</title><link>https://youngeun-in.github.io/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/</link><pubDate>Tue, 01 Mar 2022 16:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/</guid><description>Java 컴파일 과정 자바 소스 파일(*.java)을해당 파일을 Java Compiler가 JVM이 해석할 수 있는 파일인 Java ByteCode (*.class)파일로 변환한다. Java Compiler는 Java 설치 시 Javac.exe라는 실행 파일 형태로 존재한다.
Java 바이트 코드란? Java 바이트 코드란 Java Source File을 Java Compiler가 컴파일해 만든 파일이다. Java Compiler에 의해 변환되는 코드의 명령어 크기가 1byte이기 때문에 Java 바이트코드라고 불린다. Java 바이트 코드는 JVM이 해석할 수 있는 언어이며 *.class 확장자를 가진다.
Java 실행 과정 Java Compiler를 통해 만들어진 Java Bytecode (*.</description></item><item><title>JVM의 구성요소</title><link>https://youngeun-in.github.io/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/</link><pubDate>Tue, 01 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/</guid><description>JVM의 구성요소 JVM은 크게 Class loader, Runtime Data Areas, Excution Engine 3가지로 구성된다.
Class Loader(클래스 로더) Java 컴파일러로 컴파일된 Java 바이트 코드를 Runtime 시점에 JVM내로 가져오고 Runtime Data Area(JVM 메모리 영역)에 배치해주는 역할을 한다.
Runtime Data Area JVM의 메모리 영역에 해당하며 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 세분화된다.
Method Area : Class, Interface, Method, Field, Static, Final 변수 등을 보관하는 영역 Heap Area : new 키워드로 생성된 객체나 배열 인스턴스를 보관하는 영역, Runtime 시 동적으로 생성되고 JVM이 사용여부를 판단 후 Garbage Collection을 하는 영역 Stack Area : Heap Area에 동적으로 생성되어 보관되있는 객체(참조 타입)의 래퍼런스를 보관하는 영역, 기본 타입의 경우 직접 Stack Area에 보관됨 PC Register : Thread가 생성될 때 생성되는 영역으로서 Thread마다 하나의 영역을 가진다.</description></item><item><title>Servlet 동작 방식</title><link>https://youngeun-in.github.io/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/</link><pubDate>Wed, 23 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/</guid><description><![CDATA[서블릿 컨테이너 서블릿 컨테이너는 서블릿을 담아 관리한다. 서블릿은 싱글톤으로 관리된다.
서블릿이 호출되는 과정  Servlet Request / Servlet Response 객체 생성 설정 파일을 참고하여 매핑할 Servlet을 확인  1 2 3 4 5 6 7 8 9  &lt;servlet&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jsp.web.MyServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;   해당 서블릿 인스턴스 존재를 유무를 확인하여 없으면 생성(init()) Servlet Container에 스레드를 생성하고, res req를 인자로 service 실행  참고 https://youtu.be/calGCwG_B4Y]]></description></item><item><title>Array &amp; ArrayList</title><link>https://youngeun-in.github.io/array-arraylist/</link><pubDate>Thu, 17 Feb 2022 18:36:46 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/array-arraylist/</guid><description>Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다.
위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다.
캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다.</description></item><item><title>자바의 Nested Class</title><link>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/</link><pubDate>Thu, 17 Feb 2022 10:36:46 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/</guid><description>Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다.
Nested Class의 구조는 다음과 같다.
Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다.</description></item><item><title>equals와 hashCode</title><link>https://youngeun-in.github.io/equals%EC%99%80-hashcode/</link><pubDate>Wed, 16 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/equals%EC%99%80-hashcode/</guid><description>equals 메소드 Object 클래스에 정의된 equals 메소드는 다음과 같다.
1 2 3 public boolean equals(Object obj) { return (this == obj); } 단순히 Object의 ==로 비교하는 것을 확인할 수 있다.
두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다.
1 2 3 4 5 6 7 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AttachFile that = (AttachFile) o; return Objects.</description></item><item><title>Comparable 인터페이스와 Comparator 인터페이스의 차이</title><link>https://youngeun-in.github.io/comparable-and-comparator/</link><pubDate>Tue, 15 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/comparable-and-comparator/</guid><description><![CDATA[Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다.
1 2 3  public interface Comparable&lt;T&gt; { int compareTo(T obj); }   사용 예시는 다음과 같다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable&lt;Person&gt; { String name; int age; public Person(String name, int age) { this.]]></description></item><item><title>Enum 사용 (활용)</title><link>https://youngeun-in.github.io/enum-usage-2/</link><pubDate>Fri, 04 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/enum-usage-2/</guid><description>데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다.
결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다.
이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다.</description></item><item><title>Enum 사용 (개념)</title><link>https://youngeun-in.github.io/enum-usage-1/</link><pubDate>Thu, 03 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/enum-usage-1/</guid><description><![CDATA[상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 &ldquo;CALC_A&quot;일 경우엔 값 그대로, &ldquo;CALC_B&quot;일 경우엔 10 한 값을, &ldquo;CALC_C&quot;일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 &ldquo;DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.&ldquo;는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import java.]]></description></item></channel></rss>