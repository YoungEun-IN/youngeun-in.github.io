<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>system - Category -</title><link>https://youngeun-in.github.io/categories/system/</link><description>system - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 08 Apr 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/system/" rel="self" type="application/rss+xml"/><item><title>정적 링킹, 동적 링킹</title><link>https://youngeun-in.github.io/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/</link><pubDate>Fri, 08 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/</guid><description>Static Linking (정적 링킹) 정적 링킹이란 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하는 방식을 말한다.
5개의 프로그램에서 A라는 외부 함수를 이용하는데 이때 정적 링킹 방식을 사용하면 5개의 프로그램의 실행 가능한 목적파일 각각에 A의 정보가 담긴다. 즉, 중복이 발생한다. 따라서 정적 링킹으로 만들어진 프로그램은 크기가 크고 메모리 효율이 좋지 않다.
정적 링킹을 이용하면, 동적 링킹 라이브러리를 사용하는 프로그램보다 빠르다. 또한 정적 링킹 프로그램에서 모든 코드는 하나의 실행 모듈에 담기기 때문에 compatibility issues 즉, 불일치에 대한 걱정을 하지 않아도 된다.</description></item><item><title>데드락 (DeadLock)</title><link>https://youngeun-in.github.io/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/</link><pubDate>Fri, 01 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/</guid><description>데드락이란 서로 요청한 자원이 이미 상대방에게 점유되어 다음 명령을 처리 못하는 상태(교착상태)이다. 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.
발생 조건 데드락은 4가지 조건을 모두 만족해야 발생하게 되는데, 하나라도 조건을 만족하지 않으면 문제를 해결할 수 있는 상황이다. 그 조건들은 아래와 같다.
상호 배제 (Mutual Exclusion)
자원은 한 번에 한 프로세스만 사용할 수 있음. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함. 점유 대기 (Hold and wait)</description></item><item><title>HDD vs SSD</title><link>https://youngeun-in.github.io/hdd-vs-ssd/</link><pubDate>Mon, 28 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/hdd-vs-ssd/</guid><description>HDD(Hard Disk Drive) HDD는 자성을 띠는 원형 디스크인 플래터(Platter)와 이 플래터 위를 쉴새 없이 움직이는 헤드(Head)로 구성된다. 돌아가는 LP판의 홈을 바늘이 읽는 것처럼, HDD의 헤드는 회전하는 플래터의 데이터를 읽고 쓴다. 물리적으로 돌아가는 모터 방식이기에 소음이 발생한다. 때문에 소비 전력도 높고 발열 문제가 수반된다는 특징이 있다. HDD는 데이터 처리 속도도 상대적으로 느리며, 충격에 의해 헤드 같은 내부 장치가 손상될 수 있어 내구성도 약하다.
SSD(Solid State Drive) SSD는 데이터 저장 장치로 메모리 반도체(낸드플래시)를 채택하며 HDD의 한계를 넘어선다.</description></item><item><title>ASCII, Unicode</title><link>https://youngeun-in.github.io/ascii-unicode/</link><pubDate>Fri, 25 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/ascii-unicode/</guid><description><![CDATA[인코딩이란, 사용자가 입력한 문자나 기호를 컴퓨터가 이용할 수 있는 신호로 만드는 것을 말한다.
아스키코드(American Standard Code for Information Interchange) 가장 처음 만들어진 인코딩방식이다. 숫자와 문자를 매칭시키는 국제적 규칙이다. 패리티 비트를 제외하고, 128개의 문자조합을 제공하는 7비트 부호로 구성된다.(패리티 비트는 데이터의 에러를 탐지하기 위해 사용한다. 일곱자리의 이진수에서 &lsquo;1&rsquo;이 홀수개라면 끝에 1을, &lsquo;1&rsquo;이 짝수개라면 끝에 0을 덧붙인다. 아주 정밀하진 않지만 패리티 비트를 이용해 어느 정도의 에러를 탐지할 수 있다.)
아스키코드만으로는 영어만 표현 가능하며 각 나라별 언어를 표현할 수 없다는 단점이 있다.]]></description></item><item><title>블럭, 넌블럭, 동기, 비동기</title><link>https://youngeun-in.github.io/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/</link><pubDate>Sat, 19 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/</guid><description>개념 블럭/넌블럭 블럭/넌블럭은 함수호출에서의 이야기. 제어권에 의해 대기가 발생하는지 여부로 구분한다.
Block
호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return하지 않으면 블럭이다. Non-Block
호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return하여 호출한 함수가 다른 일을 진행할 수 있도록 하면 넌블럭이다. 동기/비동기 동기/비동기는 행위에 대한 이야기. 호출한 함수가 호출된 함수를 신경쓰는지 여부로 구분한다.</description></item></channel></rss>