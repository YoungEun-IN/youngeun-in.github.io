<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>system - Category -</title><link>https://youngeun-in.github.io/categories/system/</link><description>system - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 11 Sep 2023 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/system/" rel="self" type="application/rss+xml"/><item><title>하드링크, 심볼릭링크</title><link>https://youngeun-in.github.io/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/</link><pubDate>Mon, 11 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/</guid><description>inode 리눅스에는 inode 라는 개념이 있다. inode는 유닉스 계통의 파일 시스템에서 사용하는 자료 구조이다.
모든 파일과 디렉토리는 inode를 하나씩 가지고 있다. 그리고 여기에는 해당 파일의 허가권, 소유권, 파일의 실제 위치 등 중요한 정보들이 들어있다.
inode는 실제 파일의 내용을 갖고 있지는 않다. inode는 데이터의 우편번호 역할을 한다고 볼 수 있다. 즉, 파일의 내용을 갖고 있는 주소를 포함할 뿐이다.
리눅스 파일 링크 종류 하드 링크 (Hard link) 하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킨다.</description></item><item><title>프로세스, 스레드</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/</link><pubDate>Thu, 08 Jun 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/</guid><description>프로세스 프로세스는 실행 중에 있는 프로그램을 의미한다. 여러분이 게임을 즐기기 위해서 게임 실행파일을 더블클릭하면, 그 순간 프로그램 실행을 위해 메모리 할당이 이루어집니다. 그리고 이 메모리 공간으로 바이너리 코드가 올라가게 되며, 이 순간부터 프로그램은 프로세스라고 불리게 된다.
대부분의 사람들은 하나의 프로그램만 사용하기보다는, 여러 프로그램을 동시에 사용하고 싶어한다. 하지만 컴퓨터가 하나의 명령을 수행하기 위해서 CPU를 점유하고 있으면 다른 작업은 실행될 수 없다. 둘 이상의 프로그램이 동시에 실행이 가능했던 이유는 하나의 CPU가 여러 개의 프로세스를 번갈아가며 실행하기 때문이다.</description></item><item><title>RAID</title><link>https://youngeun-in.github.io/raid/</link><pubDate>Tue, 13 Dec 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/raid/</guid><description>RAID (Redundant Array of Inexpensive/Independent Disk)는 저장장치(디스크) 여러 개를 묶어 고용량,고성능 저장 장치 한 개와 같은 효과를 얻기 위해 개발된 기법이다.
RAID는 여러개의 하드디스크를 함께 사용하는 방식을 말한다. 속도를 위해 함께 사용 할 수도 있고 안정성을 위해 함께 사용 할 수도 있고 둘다를 추구할 수도 있다.
RAID-0 속도 추구만을 위한 레이드 구성이다. 단순히 하드 여러개에 데이터를 분산시켜서 한꺼번에 입출력을 수행하는 것이다. 이를 스트라이핑(Disk striping) 기술이라고 한다.
예를 들면 1~10까지의 숫자를 저장하는데, 하드1에는 1 3 5 7 9, 하드2에는 2 4 6 8 10을 저장한다.</description></item><item><title>IPC(Inter Process Communication)</title><link>https://youngeun-in.github.io/ipcinter-process-communication/</link><pubDate>Tue, 07 Jun 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/ipcinter-process-communication/</guid><description>프로세스는 독립적으로 실행된다. 즉, 독립 되어있다는 것은 다른 프로세스에게 영향을 받지 않는다고 말할 수 있다. (스레드는 프로세스 안에서 자원을 공유하므로 영향을 받는다)
이런 독립적 구조를 가진 프로세스 간의 통신을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 IPC 통신이다.
프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다.
커널 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다. IPC 종류 익명 PIPE 파이프는 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다.</description></item><item><title>데드락 (DeadLock)</title><link>https://youngeun-in.github.io/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/</link><pubDate>Fri, 01 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/</guid><description>데드락이란 서로 요청한 자원이 이미 상대방에게 점유되어 다음 명령을 처리 못하는 상태(교착상태)이다. 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.
발생 조건 데드락은 4가지 조건을 모두 만족해야 발생하게 되는데, 하나라도 조건을 만족하지 않으면 문제를 해결할 수 있는 상황이다. 그 조건들은 아래와 같다.
상호 배제 (Mutual Exclusion)
자원은 한 번에 한 프로세스만 사용할 수 있음. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함. 점유 대기 (Hold and wait)</description></item><item><title>생산자 소비자 문제와 해결</title><link>https://youngeun-in.github.io/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/</link><pubDate>Sat, 26 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/</guid><description>생산자 소비자 문제 고정된 크기의 버퍼(데이터를 보유하는 임시 영역)가 있을 때, 생산자는 버퍼에 데이터를 생성하는 기능을 제공하고, 소비자는 버퍼에서 데이터를 소비/제거하는 기능을 제공한다.
이 때 특정 규칙이 있다.
소비자 스레드가 데이터를 소비하는 동안 생산자 스레드는 버퍼에 데이터를 생성할 수 없다. 생산자 스레드가 데이터를 생성하는 동안 소비자 스레드는 버퍼의 데이터를 사용할 수 없다. 버퍼가 가득 차면 생산자 스레드는 더 많은 데이터를 생성할 수 없고, 버퍼가 비어 있으면 소비자 스레드는 데이터를 소비할 수 없다.</description></item><item><title>스핀락 vs 뮤텍스 vs 세마포어 vs 모니터</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/</link><pubDate>Wed, 23 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/</guid><description>동기화(Synchronization)란 여러 프로세스/스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것을 말한다.
상호 배제(Mutual Exclusion)란 동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해, 즉 동기화를 위해 사용되는 알고리즘을 말한다. 상호 배제는 락(Lock)을 사용해서 달성할 수 있다.
1 2 3 4 5 6 do { acquire lock // 여러 프로세스/스레드가 lock을 획득하기 위해 경합 [critical section] // lock을 획득한 프로세스/스레드만 임계 영역에서 실행함 release lock // 작업을 끝내고, lock을 반환함 remainder section } while(true) 스핀락(Spinlock) 1 2 3 4 5 6 7 8 9 10 11 12 13 volatile int lock = 0; // global void critical() { while(test_and_set(&amp;amp;lock) == 1); // lock을 획득하려는 시도를 함 [.</description></item></channel></rss>