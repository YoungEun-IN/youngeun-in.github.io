<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>설계방법론 - Category -</title><link>https://youngeun-in.github.io/categories/%EC%84%A4%EA%B3%84%EB%B0%A9%EB%B2%95%EB%A1%A0/</link><description>설계방법론 - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 02 Feb 2024 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/%EC%84%A4%EA%B3%84%EB%B0%A9%EB%B2%95%EB%A1%A0/" rel="self" type="application/rss+xml"/><item><title>프록시 패턴 &amp; 데코레이터 패턴</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</link><pubDate>Fri, 02 Feb 2024 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid><description><![CDATA[프록시 패턴 1 2 3 4  package hello.proxy.pureproxy.proxy.code; public interface Subject { String operation(); }   예제에서 Subject 인터페이스는 단순히 operation() 메서드 하나만 가지고 있다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package hello.proxy.pureproxy.proxy.code; import lombok.extern.slf4j.Slf4j; @Slf4j public class RealSubject implements Subject { @Override public String operation() { log.info(&#34;실제 객체 호출&#34;); sleep(1000); return &#34;data&#34;; } private void sleep(int millis) { try { Thread.]]></description></item><item><title>템플릿 메서드 패턴 &amp; 전략 패턴 &amp; 콜백 패턴</title><link>https://youngeun-in.github.io/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/</link><pubDate>Thu, 01 Feb 2024 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/</guid><description>템플릿 메서드 패턴 템플릿은 기준이 되는 거대한 틀이다. 템플릿이라는 틀에 변하지 않는 부분을 몰아둔다. 그리고 일부 변하는 부분을 별도로 호출해서 해결한다.
템플릿 메서드 패턴은 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 일부 변경되는 로직은 자식 클래스에 정의하는 것이다. 이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의할 수 있다. 결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것이다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package hello.</description></item><item><title>객체지향 설계 5원칙 SOLID</title><link>https://youngeun-in.github.io/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/</link><pubDate>Sat, 10 Dec 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/</guid><description>객체지향 설계는 긴 세월과 수많은 시행착오를 거치며 5가지 원칙이 정리되었다. 이것은 객체지향 설계의 5원칙이라고 하며, 앞글자를 따서 SOLID라고 한다.
SRP (Single Responsibility Principle) - 단일 책임 원칙 SRP 원칙은 클래스가 하나의 기능만을 가지며, 어떤 변화에 의해 클래스를 변경해야하는 이유는 오직 하나 뿐이어야 한다는 원칙이다.
SRP에서는 책임자체가 분명해지기 때문에, 변경에 의한 연쇄 작용에서 자유로워 질 수가 있다.
OCP (Open-Closed Principle) - 개방-폐쇄 원칙 OCP 원칙은 요구사항의 변경이나 추가사항이 발생해도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성요소를 쉽게 확장하여 재사용가능하도록 만들어야 한다는 원칙이다.</description></item><item><title>Dependency Inversion Principle</title><link>https://youngeun-in.github.io/dependency-inversion-principle/</link><pubDate>Wed, 09 Mar 2022 14:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dependency-inversion-principle/</guid><description>DIP(Dependency Inversion Principle) 우리가 다루는 모듈은 고수준 모듈과 저수준 모듈로 나눌 수 있다. 고수준 모듈이란 의미있는 단일 기능을 제공하는 모듈이며, 저수준 모듈은 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현인 모듈이다. Layered Architecture 상에서 Application 및 Domain 등의 고수준 모듈은 Infrastructure라는 저수준 모듈을 의존한다. 그 결과, 구현 부분의 변경에 유연하지 못하고 테스트하기 어렵다는 문제점이 발생한다.
DIP(Dependency Inversion Principle)이란 의존 관계를 역전시켜서 저수준 모듈이 고수준 모듈에 의존하도록 구현하는 것을 의미한다.</description></item><item><title>디미터의 법칙(Law of Demeter)</title><link>https://youngeun-in.github.io/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/</link><pubDate>Tue, 08 Mar 2022 15:11:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/</guid><description>디미터의 법칙(Law of Demeter) 디미터의 법칙은 “Object-Oriented Programming: An Objective Sense of Style” 에서 처음으로 소개되었다. Demeter라는 프로젝트를 진행하던 개발자들은 어떤 객체가 다른 객체에 대해 지나치게 많이 알다보니, 결합도가 높아지고 좋지 못한 설계를 야기한다는 것을 발견하였다. 그래서 이를 개선하고자 객체에게 자료를 숨기는 대신 함수를 공개하도록 하였는데, 이것이 바로 디미터의 법칙이다.
즉, 디미터의 법칙은 다른 객체가 어떠한 자료를 갖고 있는지 속사정을 몰라야 한다는 것을 의미하며, 이러한 이유로 Don’t Talk to Strangers(낯선 이에게 말하지 마라) 또는 Principle of least knowledge(최소 지식 원칙) 으로도 알려져 있다.</description></item><item><title>캡슐화</title><link>https://youngeun-in.github.io/%EC%BA%A1%EC%8A%90%ED%99%94/</link><pubDate>Tue, 08 Mar 2022 13:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BA%A1%EC%8A%90%ED%99%94/</guid><description>객체지향과 캡슐화 객체는 캡슐화된 상태와 외부에 노출되어 있는 행동을 갖고 있으며, 다른 객체와 메시지를 주고 받으면서 협력한다. 객체는 메시지를 받으면 객체 그에 따른 로직(행동)을 수행하게 되고, 필요하다면 객체 스스로 내부의 상태값도 변경한다. 간단히 말해서 객체지향 프로그래밍은 객체가 스스로 일을 하도록 하는 프로그래밍이다.
상태를 가지는 객체를 추가했다면 객체가 제대로 된 역할을 하도록 구현해야 한다. 즉 객체가 로직을 구현하도록 한다. 상태 데이터를 꺼내 로직을 처리하도록 구현하지 말고 객체에 메시지를 보내 일을 하도록 해야한다.</description></item><item><title>AOP</title><link>https://youngeun-in.github.io/aop/</link><pubDate>Thu, 24 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/aop/</guid><description>AOP는 기능을 핵심 비즈니스 로직과 공통 모듈로 구분하고 핵심 로직에 영향을 미치지 않고 사이사이에 공통 모듈을 효과적으로 잘 끼워 넣어 중복성을 감소시킬 수 있는 개발 방법이다.
AOP 용어 용어 설명 Advice Joinpoint에서 실행되어야 하는 프로그램 코드
독립된 클래스의 메소드로 작성함
실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체
BEFORE, AROUND, AFTER의 실행 위치 지정 Joinpoint Advice를 적용할 수 있는 후보 지점 혹은 호출 이벤트</description></item><item><title>페이크 객체(Fake)</title><link>https://youngeun-in.github.io/%ED%8E%98%EC%9D%B4%ED%81%AC-%EA%B0%9D%EC%B2%B4fake/</link><pubDate>Sat, 01 Jan 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%8E%98%EC%9D%B4%ED%81%AC-%EA%B0%9D%EC%B2%B4fake/</guid><description>페이크 객체 페이크 객체(Fake Object)란 여러 상태를 대표할 수 있도록 구현된 객체로, 실제 로직이 구현된 것 처럼 보이게 한다. 실 DB에 접속해 동일한 모양이 보이도록 객체 내부에 구현할 수 있다.
모의 객체 대신 페이크 객체를 사용해야 하는 이유는 다음과 같다.
Mock Fake 코드가 장황해지고 이해가 어려워진다. 코드가 간결해지고 유지보수성이 좋아진다. 가정 / 결과를 통해 구현하기 때문에 내부 구현을 알아야한다. 클래스 내부의 구현에 대해 알지 못해도 된다.</description></item></channel></rss>