<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>web - Category -</title><link>https://youngeun-in.github.io/categories/web/</link><description>web - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 02 May 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/web/" rel="self" type="application/rss+xml"/><item><title>세션 하이재킹</title><link>https://youngeun-in.github.io/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/</link><pubDate>Mon, 02 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/</guid><description>서버는 로그인하는 시점에 보통 내부적으로 사용자 세션을 생성하고 이를 식별할 수 있는 식별자(세션 키 - 자바 웹 애플리케이션에서는 jsessionid라는 이름을 가진다)를 사용자에 보내는 응답에 포함시킨다. 브라우저는 이를 쿠키 형태로 가지고 있게 되며, 이 세션 키가 서버 입장에서 사용자의 identity를 식별할 수 있는 식별자가 된다.
이 때 누군가가 이 세션 키를 가로채서 알게 되면 마치 그 사람인 척 하고 서버에 요청을 보내도 서버에서는 이게 진짜 사용자가 보냈는지 아닌지를 판단할 수 없다. 이것을 세션 하이재킹이라고 한다.</description></item><item><title>JWT</title><link>https://youngeun-in.github.io/jwt/</link><pubDate>Sat, 30 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/jwt/</guid><description>JWT 는 유저를 인증하고 식별하기 위한 토큰(Token)기반 인증이다. RFC 7519 에 자세한 명세가 나와있다. 토큰은 세션과는 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.
JWT 가 가지는 핵심적인 특징이 있다면, 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보가 포함(Self-contained)된다는 것이다. 데이터가 많아지면 토큰이 커질 수 있으며 토큰이 한 번 발급된 이후 사용자의 정보를 바꾸더라도 토큰을 재발급하지 않는 이상 반영되지 않는다.</description></item><item><title>3 way handshake, 4 way handshake</title><link>https://youngeun-in.github.io/3-way-handshake-4-way-handshake/</link><pubDate>Tue, 19 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/3-way-handshake-4-way-handshake/</guid><description>3-Way Handshake 3-Way Handshake는 TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정이다. 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다. 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
작동 방식 Step 1 (SYN) 클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다.</description></item><item><title>HTTPS</title><link>https://youngeun-in.github.io/https/</link><pubDate>Fri, 15 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/https/</guid><description>HTTP와 HTTPS의 가장 큰 차이점은 SSL 인증서이다. SSL인증서는 클라이언트와 서버간의 통신을 공인된 제 3차 업체(CA)가 보증해주는 전자화된 문서이다. SSL 인증서는 사용자가 사이트에서 제공하는 정보를 암호화한다. 암호화되어 전송되는 데이터는 중간에 누가 훔치거나 조작하려해도 암호화 되어있어서 해독할 수 없다.
HTTPS 방식은 공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 함께 사용한다. 데이터를 대칭키 방식으로 암복호화하고, 공개키 방식으로 대칭키를 전달한다.
HTTPS의 동작과정 클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색 Client Hello : 클라이언트가 서버에게 전송할 데이터</description></item><item><title>OSI 7계층</title><link>https://youngeun-in.github.io/osi-7%EA%B3%84%EC%B8%B5/</link><pubDate>Sat, 26 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/osi-7%EA%B3%84%EC%B8%B5/</guid><description>OSI는 Open Systems Interconnection의 약자로 개방형 시스템 간의 상호 연결을 의미한다. 국제 표준화 기구인 ISO에서 개발한 모델로 컴퓨터 네트워크의 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다.
1계층 - 물리 계층(Physical Layer) 네트워크 OSI 모델에서 가장 낮은 계층으로 하드웨어 전송 기술로 구성된다. 하드웨어 장비로 케이블, 리피터, 허브가 있으며 네트워크에서 물리적으로 데이터를 전송하는 역할을 수행한다.
2계층 - 데이터 링크 계층(Data Link Layer) 물리 계층을 통해 데이터를 전송하다가 데이터가 제대로 도착하지 못하고 중도 분실되거나 데이터의 내용이 깨져서 변형이 되는 등 물리적인 오류가 발생할 수 있다.</description></item><item><title>프록시 서버</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/</link><pubDate>Sun, 13 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/</guid><description>포워드 프록시(Forward Proxy) 일반적으로, 프록시 서버라고 하면 포워드 프록시를 의미한다. 포워드 프록시란 클라이언트와 인터넷 사이에 프록시가 위치해서 클라이언트 대신 서버에 요청을 보내주는 형태를 말한다.
포워드프록시를 통해 얻는 이점은 다음과 같다.
로컬 네트워크와 인터넷 사이 오가는 트래픽을 제어할 수 있다. 예를 들어 초등학교 안에서 학생들이 부적절한 콘텐츠를 브라우징하는 것을 막기 위해서 포워드 프록시를 사용할 수 있다. 포워드 프록시는 대개 캐싱 기능이 있으므로 어떤 콘텐츠가 빈번하게 사용된다면 월등한 성능 향상을 가져올 수 있다.</description></item><item><title>CORS</title><link>https://youngeun-in.github.io/cors/</link><pubDate>Fri, 07 Jan 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/cors/</guid><description>SOP SOP(Same Origin Policy)는 다른 Origin으로 요청을 보낼 수 없도록 금지하는 브라우저의 기본적인 보안 정책이다. 즉, 동일한 Origin으로만 요청을 보낼 수 있게 하는 것이다. 실제로 아주 옛날에는 이것이 절대적인 규칙이었기 때문에, 다른 Origin으로 요청을 보내는 건 애초에 불가능하였다. 그러나 기술이 발달하면서 서로 다른 Origin끼리 데이터를 주고받아야 하는 일이 많아졌고, 이로 인해 SOP는 별도의 예외 사항을 두게 되었다. 즉, 몇 가지 예외 상황에 대해서는 다른 Origin으로도 요청을 보낼 수 있게 하는 것이다.</description></item><item><title>ETag</title><link>https://youngeun-in.github.io/etag/</link><pubDate>Thu, 06 Jan 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/etag/</guid><description>ETag(entity tag)는 웹 서버가 주어진 URL의 콘텐츠가 변경되었는지 알려주고 이를 반환하는 HTTP 응답 헤더이다.
캐시를 사용하면 불필요한 요청을 줄이면서 서버의 부하를 줄일 수 있고, 미리 캐시에 저장해 놓은 값을 사용함으로써 빠른 응답을 할 수 있다. ETag는 사용하는 캐시가 유효한지 검증하기 위해 사용한다. Static file(js, css, image) 뿐만 아니라 API와 같은 Dynamic content에도 간단하게 Cache기능을 사용하게 설정하면 API속도도 증가되고 유저 입장에서는 네트웍 트래픽을 줄일 수 있다. API와 같이 언제 바뀔지 모르는 데이터의 Cache는 쉽지 않은데, Etag를 이용하면 서버에서 새로운 데이터를 먼저 확인하고 줄 수 있기 때문에 API에도 충분히 적용가능하다.</description></item></channel></rss>