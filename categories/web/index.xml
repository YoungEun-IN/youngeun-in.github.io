<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>web - Category -</title><link>https://youngeun-in.github.io/categories/web/</link><description>web - Category -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 10 Nov 2023 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/categories/web/" rel="self" type="application/rss+xml"/><item><title>Web Server vs WAS</title><link>https://youngeun-in.github.io/web-server-vs-was/</link><pubDate>Fri, 10 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/web-server-vs-was/</guid><description>웹 서버(Web Server) HTTP 기반으로 동작 정적 리소스 제공, 기타 부가기능 정적(파일) HTML, CSS, JS, 이미지, 영상 예) NGINX, APACHE 웹 애플리케이션 서버(WAS - Web Application Server) HTTP 기반으로 동작 웹 서버 기능 포함+ (정적 리소스 제공 가능) 프로그램 코드를 실행해서 애플리케이션 로직 수행 동적 HTML, HTTP API(JSON) 서블릿, JSP, 스프링 MVC 예) 톰캣(Tomcat) Jetty, Undertow 웹 서버, 웹 애플리케이션 서버(WAS) 차이 웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직 사실은 둘의 용어도 경계도 모호함 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함 웹 애플리케이션 서버도 웹 서버의 기능을 제공함 자바는 서블릿 컨테이너 기능을 제공하면 WAS 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있음 WAS는 애플리케이션 코드를 실행하는데 더 특화 웹 시스템 구성 - WEB, WAS, DB 정적 리소스는 웹 서버가 처리 웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임 WAS는 중요한 애플리케이션 로직 처리 전담 효율적인 리소스 관리 정적 리소스가 많이 사용되면 Web 서버 증설 애플리케이션 리소스가 많이 사용되면 WAS 증설 WAS, DB 장애시 WEB 서버가 오류 화면 제공 가능 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽음 참고 https://www.</description></item><item><title>사설IP, NAT, CIDR</title><link>https://youngeun-in.github.io/%EC%82%AC%EC%84%A4ip-nat-cidr/</link><pubDate>Sat, 04 Nov 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%82%AC%EC%84%A4ip-nat-cidr/</guid><description>사설 IP(Private IP) 사설 IP(Private IP)는 한정된 IP 주소를 최대한 활용하기 위해 IP주소를 분할하고자 만든 개념이다. IPV4 기준으로 최대 IP 개수는 약 43억개이다.
사설망 내부에는 외부 인터넷 망으로 통신이 불가능한 사설 IP가 구성된다. 그리고 외부로 통신할 때는 통신 가능한 공인 IP를 사용한다. 보통 하나의 망은 사설 IP를 부여받은 기기들과 NAT 기능을 갖춘 Gateway로 구성한다.
NAT(Network Address Translation) NAT(Network Address Translation)는 사설 IP가 공용 IP로 통신할 수 있도록 주소를 변환해주는 방법이다.</description></item><item><title>HTTP</title><link>https://youngeun-in.github.io/http/</link><pubDate>Wed, 06 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/http/</guid><description>HTTP HTTP는 HyperText Transfer Protocol의 약자로, HTML, text, image, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터를 전송 가능한 프로토콜이다.
HTTP 특징 클라이언트-서버 구조 클라이언트는 서버에 요청을 보내고, 응답을 대기한다. 서버는 요청에 대한 결과를 만들어서 응답한다.
무상태 프로토콜(Stateless)) 서버가 클라이언트의 상태를 보존하지 않는다.
장점: 서버 확장성 높음(스케일 아웃) 단점: 클라이언트가 추가 데이터 전송 모든 것을 무상태로 설계 할 수 없는 경우에는 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지를 함으로써 무상태 프로토콜의 한계를 극복할 수 있다.</description></item><item><title>URI, URL, URN</title><link>https://youngeun-in.github.io/uri-url-urn/</link><pubDate>Tue, 05 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/uri-url-urn/</guid><description>URI URI는 로케이터(locator), 이름(name)을 포함한 개념이다.
URI는 다음과 같이 풀이할 수 있다.
Uniform: 리소스 식별하는 통일된 방식 Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음) Identifier: 다른 항목과 구분하는데 필요한 정보 URL, URN URL, URN은 다음과 같이 풀이할 수 있다.
URL: Uniform Resource Locator : 리소스가 있는 위치를 지정 URN: Uniform Resource Name : 리소스에 이름을 부여 URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않아, 잘 사용하지 않는다.</description></item><item><title>CSRF, XSS</title><link>https://youngeun-in.github.io/csrf-xss/</link><pubDate>Sat, 28 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/csrf-xss/</guid><description>CSRF (Cross Site Request Forgery) 웹 어플리케이션 취약점 중 하나로, 인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위 (modify, delete, register 등)를 특정한 웹사이트에 request하도록 만드는 공격을 말한다.
주로 해커들이 많이 이용하는 것으로, 유저의 권한을 도용해 중요한 기능을 실행하도록 한다.
우리가 실생활에서 CSRF 공격을 볼 수 있는 건, 해커가 사용자의 SNS 계정으로 광고성 글을 올리는 것이다.
정확히 말하면, CSRF는 해커가 사용자 컴퓨터를 감염시거나 서버를 해킹해서 공격하는 것이 아니다. CSRF 공격은 아래와 같은 조건이 만족할 때 실행된다.</description></item><item><title>쿠키 vs 세션</title><link>https://youngeun-in.github.io/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/</link><pubDate>Tue, 24 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/</guid><description>쿠키 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다. 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다. 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.
클라이언트에 300개까지 쿠키저장 가능하며, 하나의 도메인당 20개의 값만 가질 수 있다. 하나의 쿠키값은 4KB까지 저장한다. Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다.</description></item><item><title>Keep-Alive</title><link>https://youngeun-in.github.io/keep-alive/</link><pubDate>Fri, 06 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/keep-alive/</guid><description>TCP Keep-Alive 두 종단 간의 연결을 유지하는 것이 목적이다. 연결된 TCP 소켓을 체크할 수 있고 TCP 연결이 여전히 진행중인지 혹은 끊어졌는지를 결정한다.
TCP Keepalive는 연결된 세션의 재활용 측면에서만 아니라 좀비 커넥션의 삭제에도 도움을 준다. TCP 연결을 끊으려면 FIN 패킷이 필요하다. 하지만 다양한 이유로 FIN 패킷을 받을 수 없는 상황이 된다면 FIN을 전달할 수 없어 계속 연결된 것처럼 남아있게 된다. TCP Keepalive 옵션을 사용한다면 일정시간이 확인 패킷을 보내는 로직을 통해 일정시간 동안 응답이 없다면 연결을 종료하기 때문에 좀비 커넥션을 방지할 수 있다.</description></item><item><title>세션 하이재킹</title><link>https://youngeun-in.github.io/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/</link><pubDate>Mon, 02 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/</guid><description>서버는 로그인하는 시점에 보통 내부적으로 사용자 세션을 생성하고 이를 식별할 수 있는 식별자(세션 키 - 자바 웹 애플리케이션에서는 jsessionid라는 이름을 가진다)를 사용자에 보내는 응답에 포함시킨다. 브라우저는 이를 쿠키 형태로 가지고 있게 되며, 이 세션 키가 서버 입장에서 사용자의 identity를 식별할 수 있는 식별자가 된다.
이 때 누군가가 이 세션 키를 가로채서 알게 되면 마치 그 사람인 척 하고 서버에 요청을 보내도 서버에서는 이게 진짜 사용자가 보냈는지 아닌지를 판단할 수 없다. 이것을 세션 하이재킹이라고 한다.</description></item><item><title>JWT</title><link>https://youngeun-in.github.io/jwt/</link><pubDate>Sat, 30 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/jwt/</guid><description>JWT 는 유저를 인증하고 식별하기 위한 토큰(Token)기반 인증이다. RFC 7519 에 자세한 명세가 나와있다. 토큰은 세션과는 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.
JWT 가 가지는 핵심적인 특징이 있다면, 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보가 포함(Self-contained)된다는 것이다. 데이터가 많아지면 토큰이 커질 수 있으며 토큰이 한 번 발급된 이후 사용자의 정보를 바꾸더라도 토큰을 재발급하지 않는 이상 반영되지 않는다.</description></item><item><title>3 way handshake, 4 way handshake</title><link>https://youngeun-in.github.io/3-way-handshake-4-way-handshake/</link><pubDate>Tue, 19 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/3-way-handshake-4-way-handshake/</guid><description>3-Way Handshake 3-Way Handshake는 TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정이다. 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다. 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
작동 방식 Step 1 (SYN) 클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다.</description></item></channel></rss>