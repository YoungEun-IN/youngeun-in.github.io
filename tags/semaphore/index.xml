<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>semaphore - Tag -</title><link>https://youngeun-in.github.io/tags/semaphore/</link><description>semaphore - Tag -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 26 Mar 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/tags/semaphore/" rel="self" type="application/rss+xml"/><item><title>생산자 소비자 문제와 해결</title><link>https://youngeun-in.github.io/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/</link><pubDate>Sat, 26 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/</guid><description>생산자 소비자 문제 생산자 소비자 문제는 프로세스 동기화 문제이다. 고정된 크기의 버퍼(데이터를 보유하는 임시 영역)가 있을 때, 생산자는 버퍼에 데이터를 생성하는 기능을 제공하고, 소비자는 버퍼에서 데이터를 소비/제거하는 기능을 제공한다. 이 때 특정 규칙이 있다.
소비자 스레드가 데이터를 소비하는 동안 생산자 스레드는 버퍼에 데이터를 생성할 수 없다. 생산자 스레드가 데이터를 생성하는 동안 소비자 스레드는 버퍼의 데이터를 사용할 수 없다. 버퍼가 가득 차면 생산자 스레드는 더 많은 데이터를 생성할 수 없고, 버퍼가 비어 있으면 소비자 스레드는 데이터를 소비할 수 없다.</description></item><item><title>스핀락 vs 뮤텍스 vs 세마포어 vs 모니터</title><link>https://youngeun-in.github.io/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/</link><pubDate>Wed, 23 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/</guid><description>동기화(Synchronization)란 여러 프로세스/스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것을 말한다.
상호 배제(Mutual Exclusion)란 동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해, 즉 동기화를 위해 사용되는 알고리즘을 말한다. 상호 배제는 락(Lock)을 사용해서 달성할 수 있다.
1 2 3 4 5 6 do { acquire lock // 여러 프로세스/스레드가 lock을 획득하기 위해 경합 [critical section] // lock을 획득한 프로세스/스레드만 임계 영역에서 실행함 release lock // 작업을 끝내고, lock을 반환함 remainder section } while(true) 스핀락(Spinlock) 1 2 3 4 5 6 7 8 9 10 11 12 13 volatile int lock = 0; // global void critical() { while(test_and_set(&amp;amp;lock) == 1); // lock을 획득하려는 시도를 함 [.</description></item></channel></rss>