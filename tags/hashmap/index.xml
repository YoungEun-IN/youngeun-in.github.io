<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>hashmap - Tag -</title><link>https://youngeun-in.github.io/tags/hashmap/</link><description>hashmap - Tag -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 15 May 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/tags/hashmap/" rel="self" type="application/rss+xml"/><item><title>Hash와 HashMap</title><link>https://youngeun-in.github.io/hash%EC%99%80-hashmap/</link><pubDate>Sun, 15 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/hash%EC%99%80-hashmap/</guid><description>해싱 해싱은 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 찾아가는 검색 방식이다. 키값을 원소 위치로 변환하는 함수를 해시 함수(Hash Function)라 한다. 해시 함수에 의해 계산된 주소에 저장할 값을 저장한 표를 해시 테이블(Hash Table)이라 한다. 해시 테이블은 빠른 검색 속도를 제공하는데 이유는 내부적으로 버킷(배열)을 사용하여 데이터를 저장하기 때문이다. 해시 테이블은 각각의 key 값에 해시 함수를 적용해 배열의 고유한 인덱스를 생성한 후 인덱스를 이용해 값을 저장한다. 실제 값이 저장되는 장소를 버킷이라 한다.</description></item><item><title>HashMap vs HashTable vs ConcurrentHashMap</title><link>https://youngeun-in.github.io/hashmap-vs-hashtable-vs-concurrenthashmap/</link><pubDate>Thu, 03 Mar 2022 09:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/hashmap-vs-hashtable-vs-concurrenthashmap/</guid><description>각 자료구조는 필요에 따라 선택되고 활용된다. Map 인터페이스의 구현체로는 HashMap, HashTable, ConcurrentHashMap 등이 있다. Map 인터페이스를 구현하면, &amp;lt;Key, Value&amp;gt; 형태를 띈다. 그렇다면 이 셋은 무슨 특징을 가지고, 서로 어떤 차이가 있을까? 이번 글에서 해당 구현체를 비교하며 확인해보자.
HashMap key와 value에 null을 허용한다. 동기화를 보장하지 않는다. HashMap은 thread-safe하지 않아, 싱글 쓰레드 환경에서 사용하는 게 좋다. 한편, 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다. 결국 HashTable과 ConcurrentHashMap보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어진다.</description></item></channel></rss>