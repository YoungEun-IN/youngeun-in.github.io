<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>thread-pool - Tag -</title><link>https://youngeun-in.github.io/tags/thread-pool/</link><description>thread-pool - Tag -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 23 Apr 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/tags/thread-pool/" rel="self" type="application/rss+xml"/><item><title>Java 스레드풀</title><link>https://youngeun-in.github.io/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/</link><pubDate>Sat, 23 Apr 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/</guid><description>스레드풀 스레드풀 생성 스레드가 기하급수적으로 늘어난다면 스레드 생성과 스케줄링으로 인해 CPU의 메모리 사용량이 늘어나고 어플리케이션의 성능의 저하가 일어난다. 병렬작업의 급증을 막기 위해서는 특정 스레드 개수만큼 작업 컨베이어 벨트 (작업 큐)를 만들어 놓고 작업을 컨베이어 벨트에 올려놓아 작업이 끝난 스레드가 컨베이어에서 작업을 꺼내 기능을 수행하는 방식으로 작업을 구성할 수 있다. 아무리 작업 처리 요청이 폭주하여도 스레드의 전체 개수가 늘어나지 않기 때문에 어플리케이션의 성능이 급격하게 저하되지 않는다.
자바는 스레드 풀을 생성하고 사용할 수 있도록 java.</description></item></channel></rss>