<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>annotation - Tag -</title><link>https://youngeun-in.github.io/tags/annotation/</link><description>annotation - Tag -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 01 Dec 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/tags/annotation/" rel="self" type="application/rss+xml"/><item><title>Bean vs Component</title><link>https://youngeun-in.github.io/bean-vs-component/</link><pubDate>Thu, 01 Dec 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/bean-vs-component/</guid><description>@Bean @Bean은 메소드 레벨에서 선언하며, 반환되는 객체(인스턴스)를 개발자가 수동으로 빈으로 등록하는 애노테이션이다.
1 2 3 4 5 6 7 @Configuration public class AppConfig { @Bean public MemberService memberService() { return new MemberServiceImpl(); } } @Component @Component는 클래스 레벨에서 선언함으로써 스프링이 런타임시에 컴포넌트스캔을 하여 자동으로 빈을 찾고(detect) 등록하는 애노테이션이다.
1 2 3 4 @Component public class Utility { // ... } @Bean vs @Component @Bean의 경우 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우에 사용된다.</description></item></channel></rss>