<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>volatile - Tag -</title><link>https://youngeun-in.github.io/tags/volatile/</link><description>volatile - Tag -</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 03 Mar 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/tags/volatile/" rel="self" type="application/rss+xml"/><item><title>volatile</title><link>https://youngeun-in.github.io/volatile/</link><pubDate>Thu, 03 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/volatile/</guid><description>volatile란? volatile 키워드는 java 변수를 Main Memory에 저장하겠다라는 것을 명시한다. 즉 매번 변수의 값을 읽을 때마다 CPU cache에 저장된 값이 아닌 Main Memory에서 읽는 것이다. 또한 변수의 값을 쓸 때마다 Main Memory까지 작성한다.
volatile 키워드의 필요성 멀티쓰레드 어플리케이션에서의 non-volatile 변수에 대한 작업은 성능상의 이유로 CPU 캐시를 이용한다. 둘 이상의 CPU가 탑제된 컴퓨터에서 어플리케이션을 실행한다면, 각 쓰레드는 변수를 각 CPU의 캐시로 복사하여 읽어들인다.
쓰레드가 변경한 값이 메인 메모리에 저장되지 않아서 다른 쓰레드가 이 값을 볼 수 없는 상황을 &amp;lsquo;가시성&amp;rsquo; 문제라 한다.</description></item><item><title>싱글톤 패턴 구현</title><link>https://youngeun-in.github.io/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/</link><pubDate>Thu, 03 Mar 2022 10:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/</guid><description>싱글톤 패턴은 프로세스(Java에서는 JVM) 내에 1개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역 접근점을 제공하는 패턴이다.
Eager Initialization 싱글톤 패턴을 가장 단순하게 구현하는 방법은 외부에서 해당 클래스의 인스턴스를 생성할 수 없도록 private 생성자를 만들고, 1개의 인스턴스만을 초기화(public static final)하여 이에 대한 접근을 제공하는 방식이다.
1 2 3 4 5 6 7 8 public class SimpleSingleton { //public static final으로 1개의 인스턴스만을 초기화하여 접근점을 제공하고, 2개 이상의 인스턴스를 못 만들게 한다.</description></item></channel></rss>