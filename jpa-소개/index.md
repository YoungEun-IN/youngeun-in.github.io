# JPA 소개


## SQL 중심적인 개발의 문제점
 - SQL에 의존적인 개발을 피하기 어렵다.
 - 패러다임의 불일치 (객체 vs 관계형 데이터베이스)

## 객체와 관계형 데이터베이스의 차이
- 상속
  - 객체는 상속과 다형성을 사용
  - 테이블은 상속 관계 안쓴다.
- 연관관계
    - 객체는 참조를 사용
    - 관계형 데이터베이스는 외래 키를 사용
- 연관관계 탐색
     - 객체는 자유롭게 객체 그래프를 탐색할 수 있어야 한다.
     - 관계형 데이터베이스는 처음 실행하는 SQL에 따라 탐색 범위 결정
- 데이터 식별 방법
   - 관계형 데이터베이스는 처음 실행하는 SQL에 따라 탐색 범위 결정되기 때문에, 이는 엔티티 신뢰 문제를 발생시킨다.
   - 상황에 따라 동일한 조회 메서드를 여러벌 생성 
     - 진정한 의미의 계층 분할이 어렵다.

## JPA를 왜 사용해야 하는가?
### 생산성
- JPA는 기본적인 CRUD 코드가 다 설정되어 있기 때문에 **쉽게 자바 컬렉션에서 코드를 사용하듯 사용**할 수 있다.

### 유지보수성
- **JPA에서는 필드만 추가해주고 SQL은 JPA가 직접 처리**해준다. 이러한 특성 때문에 유지보수가 용이해진다.

### 패러다임의 불일치 해결
- JPA를 이용하면 개발자는 **한줄로 상속관계를 모두 포함**해 저장할 수 있다.
- 조회도 **자바컬렉션처럼 조회를 진행한다면 JPA에서 나머지 SELECT , JOIN을 진행**해준다.
- **연관관계 저장도 객체 컬렉션의 동작처럼 간단한 코드**로 진행할 수 있다.
- 객체를 미리 설정해주고 JPA로 미리 연관관계를 설정해준다면 **엔티티, 계층을 신뢰할 수 있고 객체 그래프 탐색이 자유로워진다.**
- SQL주도 개발에서의 객체는 다른 값이지만(new 를 통한 객체 생성 때문) JPA에서는 **동일한 트랜잭션에서 조회한 엔티티는 같음을 보장**해준다.

### 성능
- **1차 캐시와 동일성 보장**
  - **같은 트랜잭션 안에서는 같은 엔티티를 반환**하므로 약간의 조회 성능을 기대할 수 있다.
  - DB Isolation Level이 Read Commit이어도 **애플리케이션에서 Repeatable Read을 보장**한다.
- **트랜잭션을 지원하는 쓰기**
  - INSERT
    - 트랜잭션을 커밋할 때까지 INSERT SQL을 모음
    - JDBC BATCH SQL 기능을 사용해서 한번에 SQL을 모아서 전송
  - UPDATE
    - UPDATE, DELETE로 인한 로우(ROW)락 시간 최소화
    - 트랜잭션 커밋 시 UPDATE, DELETE SQL 실행하고, 바로 커밋
- **지연 로딩과 즉시 로딩**
  - JPA는 지연 로딩과 즉시 로딩 기능을 설정만으로 간단하게 세팅할 수 있다.
 
## 출처
https://www.inflearn.com/course/ORM-JPA-Basic
  

