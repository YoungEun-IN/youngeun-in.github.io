<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>equals와 hashCode - </title><meta name=Description content="About LoveIt Theme"><meta property="og:title" content="equals와 hashCode">
<meta property="og:description" content="equals 메소드 Object 클래스에 정의된 equals 메소드는 다음과 같다.
1 2 3  public boolean equals(Object obj) { return (this == obj); }   단순히 Object의 ==로 비교하는 것을 확인할 수 있다.
두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다.
1 2 3 4 5 6 7  @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AttachFile that = (AttachFile) o; return Objects.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://youngeun-in.github.io/equals-and-hashcode/"><meta property="og:image" content="https://youngeun-in.github.io/logo.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-02-07T15:12:26+09:00">
<meta property="article:modified_time" content="2022-02-07T15:12:26+09:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://youngeun-in.github.io/logo.png">
<meta name=twitter:title content="equals와 hashCode">
<meta name=twitter:description content="equals 메소드 Object 클래스에 정의된 equals 메소드는 다음과 같다.
1 2 3  public boolean equals(Object obj) { return (this == obj); }   단순히 Object의 ==로 비교하는 것을 확인할 수 있다.
두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다.
1 2 3 4 5 6 7  @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AttachFile that = (AttachFile) o; return Objects.">
<meta name=application-name content="DevLog">
<meta name=apple-mobile-web-app-title content="DevLog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://youngeun-in.github.io/equals-and-hashcode/><link rel=prev href=https://youngeun-in.github.io/enum-usage-2/><link rel=next href=https://youngeun-in.github.io/spring-psa/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"equals와 hashCode","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/youngeun-in.github.io\/equals-and-hashcode\/"},"image":["https:\/\/youngeun-in.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"equals, hashcode","wordcount":4550,"url":"https:\/\/youngeun-in.github.io\/equals-and-hashcode\/","datePublished":"2022-02-07T15:12:26+09:00","dateModified":"2022-02-07T15:12:26+09:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"yyoungeunin","logo":"https:\/\/youngeun-in.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yyoungeunin"},"description":""}</script><style>.search{position:relative;padding-top:3.5rem;padding-bottom:1rem;width:57.5%;margin:0 auto;background:#fff;opacity:.95}[theme=dark] .search{background:#3a3535}[theme=dark] .search header,.search header{background-color:#f8f8f8}[theme=dark] .search header:hover,.search header:hover{-webkit-box-shadow:none;box-shadow:none}.search header h1{padding-left:1rem;background:#fff}[theme=dark] .search header h1{background:#3a3535}[theme=dark] .search input,.search input{height:initial;width:initial;color:initial;background-color:#fff;margin:0 0 0 1rem;border-width:2px;border-style:inset;border-color:initial;border-image:initial;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.search #search-results{padding-left:1rem;padding-right:1rem}[theme=dark] a:active,[theme=dark] a:hover{color:#2d96bd}.search hr{margin-left:1rem;margin-right:1rem}}</style>
</head>
<body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title><span id=id-1 class=typeit></span></a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> Posts </a><a class=menu-item href=/categories/> Categories </a><a class=menu-item href=/tags/> Tags </a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i> Search </a><a class=menu-item href=/about/> About </a><a class=menu-item href=https://github.com/YouneEun-IN title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i> </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title><span id=id-2 class=typeit></span></a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/search/ title><i class="fas fa-fw fa-search"></i>Search</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=https://github.com/YouneEun-IN title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container>
<div class=toc id=toc-auto>
<h2 class=toc-title>Contents</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">equals와 hashCode</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>yyoungeunin</a></span>&nbsp;<span class=post-category>included in <a href=/categories/java/><i class="far fa-folder fa-fw"></i>java</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-02-07>2022-02-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;4550 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;22 minutes&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#equals-메소드>equals 메소드</a></li>
<li><a href=#hashcode-메소드>hashCode 메소드</a>
<ul>
<li><a href=#원문>원문</a>
<ul>
<li><a href=#java-18>Java 1.8</a></li>
<li><a href=#java-13>Java 13</a></li>
</ul>
</li>
<li><a href=#equals와의-관계>equals와의 관계</a></li>
<li><a href=#이상적인-해시-함수에-가까운-함수-만들기>이상적인 해시 함수에 가까운 함수 만들기</a>
<ul>
<li><a href=#effective-java2판>Effective Java(2판)</a></li>
<li><a href=#effective-java3판>Effective Java(3판)</a></li>
</ul>
</li>
<li><a href=#hashcode-메소드-예제>hashCode 메소드 예제</a>
<ul>
<li><a href=#abstractsetjava>AbstractSet.java</a></li>
<li><a href=#abstractlistjava>AbstractList.java</a></li>
</ul>
</li>
<li><a href=#listjava>List.java</a></li>
<li><a href=#그런데-왜-31을-곱하는-걸까>그런데 왜 31을 곱하는 걸까?</a>
<ul>
<li><a href=#해시-코드-생성에-소수를-사용하는-이유>해시 코드 생성에 소수를 사용하는 이유</a>
<ul>
<li><a href=#clrs-책의-나누기-방법>CLRS 책의 &ldquo;나누기 방법&rdquo;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href=#javautilhashmap>java.util.HashMap</a></li>
<li><a href=#project-lombok의-hashcode-메소드-자동-구현>Project Lombok의 hashCode 메소드 자동 구현</a></li>
<li><a href=#javalangobjecthashcode-의-native-코드>java.lang.Object.hashCode 의 native 코드</a></li>
<li><a href=#links>Links</a></li>
<li><a href=#참고문헌>참고문헌</a></li>
<li><a href=#주석>주석</a></li>
</ul>
</li>
</ul>
</nav></div>
</div><div class=content id=content><h2 id=equals-메소드>equals 메소드</h2>
<p>Object 클래스에 정의된 equals 메소드는 다음과 같다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=o>(</span><span class=k>this</span> <span class=o>==</span> <span class=n>obj</span><span class=o>);</span>
    <span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>단순히 Object의 ==로 비교하는 것을 확인할 수 있다.</p>
<p>두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java>    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=k>this</span> <span class=o>==</span> <span class=n>o</span><span class=o>)</span> <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>o</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>getClass</span><span class=o>()</span> <span class=o>!=</span> <span class=n>o</span><span class=o>.</span><span class=na>getClass</span><span class=o>())</span> <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
        <span class=n>AttachFile</span> <span class=n>that</span> <span class=o>=</span> <span class=o>(</span><span class=n>AttachFile</span><span class=o>)</span> <span class=n>o</span><span class=o>;</span>
        <span class=k>return</span> <span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>id</span><span class=o>,</span> <span class=n>that</span><span class=o>.</span><span class=na>id</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>fileName</span><span class=o>,</span> <span class=n>that</span><span class=o>.</span><span class=na>fileName</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>minutes</span><span class=o>,</span> <span class=n>that</span><span class=o>.</span><span class=na>minutes</span><span class=o>);</span>
    <span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=hashcode-메소드>hashCode 메소드</h2>
<p>Object 클래스에 정의된 hashCode 메소드는 다음과 같다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>o</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>?</span> <span class=n>o</span><span class=o>.</span><span class=na>hashCode</span><span class=o>()</span> <span class=o>:</span> <span class=n>0</span><span class=o>;</span>
    <span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=원문>원문</h3>
<h4 id=java-18>Java 1.8</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Returns a hash code value for the object. This method is
</span><span class=cm> * supported for the benefit of hash tables such as those provided by
</span><span class=cm> * {@link java.util.HashMap}.
</span><span class=cm> * &lt;p&gt;
</span><span class=cm> * The general contract of {@code hashCode} is:
</span><span class=cm> * &lt;ul&gt;
</span><span class=cm> * &lt;li&gt;Whenever it is invoked on the same object more than once during
</span><span class=cm> *     an execution of a Java application, the {@code hashCode} method
</span><span class=cm> *     must consistently return the same integer, provided no information
</span><span class=cm> *     used in {@code equals} comparisons on the object is modified.
</span><span class=cm> *     This integer need not remain consistent from one execution of an
</span><span class=cm> *     application to another execution of the same application.
</span><span class=cm> * &lt;li&gt;If two objects are equal according to the {@code equals(Object)}
</span><span class=cm> *     method, then calling the {@code hashCode} method on each of
</span><span class=cm> *     the two objects must produce the same integer result.
</span><span class=cm> * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal
</span><span class=cm> *     according to the {@link java.lang.Object#equals(java.lang.Object)}
</span><span class=cm> *     method, then calling the {@code hashCode} method on each of the
</span><span class=cm> *     two objects must produce distinct integer results.  However, the
</span><span class=cm> *     programmer should be aware that producing distinct integer results
</span><span class=cm> *     for unequal objects may improve the performance of hash tables.
</span><span class=cm> * &lt;/ul&gt;
</span><span class=cm> * &lt;p&gt;
</span><span class=cm> * As much as is reasonably practical, the hashCode method defined by
</span><span class=cm> * class {@code Object} does return distinct integers for distinct
</span><span class=cm> * objects. (This is typically implemented by converting the internal
</span><span class=cm> * address of the object into an integer, but this implementation
</span><span class=cm> * technique is not required by the
</span><span class=cm> * Java&amp;trade; programming language.)
</span><span class=cm> *
</span><span class=cm> * @return  a hash code value for this object.
</span><span class=cm> * @see     java.lang.Object#equals(java.lang.Object)
</span><span class=cm> * @see     java.lang.System#identityHashCode
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=kd>native</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>();</span>
</code></pre></td></tr></table>
</div>
</div><p>번역해 보자면 다음과 같다.</p>
<blockquote>
</blockquote>
<p><code>hashCode</code> 메소드는 객체의 해시코드 값을 리턴합니다.<br>
이 메소드는 해시 테이블(<code>java.util.HashMap</code> 같은)을 사용할 때의 이점을 위해 제공됩니다.<br>
<code>hashCode</code> 메소드의 일반 규약은 다음과 같습니다.</p>
<blockquote>
</blockquote>
<ol>
<li>변경되지 않은 한 객체의 <code>hashCode</code> 메소드를 호출한 결과는 항상 똑같은 <code>integer</code> 값이어야 합니다.
<ul>
<li>객체가 변경됐더라도 <code>equals</code> 메소드가 참고하는 정보가 변경되지 않았다면 <code>hashCode</code> 값은 달라지지 않습니다.</li>
</ul>
</li>
<li><code>equals</code> 메소드가 같다고 판별한 두 객체의 <code>hashCode</code> 호출 결과는 똑같은 <code>integer</code> 값이어야 합니다.</li>
<li>그러나 <code>java.lang.Object.equals</code> 메소드가 다르다고 판별한 두 객체의 <code>hashCode</code> 값이 반드시 달라야 하는 것은 아닙니다.
<ul>
<li>단, 같지 않은 객체들이 각기 다른 <code>hashCode</code> 값을 가지면 해시 테이블 성능이 향상된다는 점을 기억해두세요.</li>
</ul>
</li>
</ol>
<blockquote>
</blockquote>
<p>실용적인 이유로, <code>Object</code> 클래스의 <code>hashCode</code> 메소드는 다른 객체에 대해 각기 다른 <code>integer</code> 값을 리턴하도록 정의되었습니다. (일반적으로 객체의 내부 주소를 <code>integer</code> 값으로 변환하는 방식으로 구현되지만, 그러한 구현 기법은 Java(TM) 프로그래밍 언어에서는 필수적인 것은 아닙니다)</p>
<blockquote>
</blockquote>
<ul>
<li>@return <code>this</code> 객체의 해시코드 값</li>
<li>@see java.lang.Object#equals(java.lang.Object)</li>
<li>@see java.lang.System#identityHashCode</li>
</ul>
<h4 id=java-13>Java 13</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Returns a hash code value for the object. This method is
</span><span class=cm> * supported for the benefit of hash tables such as those provided by
</span><span class=cm> * {@link java.util.HashMap}.
</span><span class=cm> * &lt;p&gt;
</span><span class=cm> * The general contract of {@code hashCode} is:
</span><span class=cm> * &lt;ul&gt;
</span><span class=cm> * &lt;li&gt;Whenever it is invoked on the same object more than once during
</span><span class=cm> *     an execution of a Java application, the {@code hashCode} method
</span><span class=cm> *     must consistently return the same integer, provided no information
</span><span class=cm> *     used in {@code equals} comparisons on the object is modified.
</span><span class=cm> *     This integer need not remain consistent from one execution of an
</span><span class=cm> *     application to another execution of the same application.
</span><span class=cm> * &lt;li&gt;If two objects are equal according to the {@code equals(Object)}
</span><span class=cm> *     method, then calling the {@code hashCode} method on each of
</span><span class=cm> *     the two objects must produce the same integer result.
</span><span class=cm> * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal
</span><span class=cm> *     according to the {@link java.lang.Object#equals(java.lang.Object)}
</span><span class=cm> *     method, then calling the {@code hashCode} method on each of the
</span><span class=cm> *     two objects must produce distinct integer results.  However, the
</span><span class=cm> *     programmer should be aware that producing distinct integer results
</span><span class=cm> *     for unequal objects may improve the performance of hash tables.
</span><span class=cm> * &lt;/ul&gt;
</span><span class=cm> *
</span><span class=cm> * @implSpec
</span><span class=cm> * As far as is reasonably practical, the {@code hashCode} method defined
</span><span class=cm> * by class {@code Object} returns distinct integers for distinct objects.
</span><span class=cm> *
</span><span class=cm> * @return  a hash code value for this object.
</span><span class=cm> * @see     java.lang.Object#equals(java.lang.Object)
</span><span class=cm> * @see     java.lang.System#identityHashCode
</span><span class=cm> */</span>
<span class=nd>@HotSpotIntrinsicCandidate</span>
<span class=kd>public</span> <span class=kd>native</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>();</span>
</code></pre></td></tr></table>
</div>
</div><p>1.8과 비교해 보면 <code>&lt;p></code> 부터는 짧은 문장 하나만 남기고 나머지 부분은 삭제되었다.
그리고 남아 있는 한 문장에는 <code>@implSpec</code> 태그가 붙었다.</p>
<p>남은 문장은 다음과 같다.</p>
<blockquote>
</blockquote>
<p>As far as is reasonably practical, the hashCode method defined
by class Object returns distinct integers for distinct objects.</p>
<blockquote>
</blockquote>
<p>실용적인 이유로, <code>Object</code> 클래스의 <code>hashCode</code> 메소드는 다른 객체에 대해 각기 다른 <code>integer</code> 값을 리턴하도록 정의되었습니다.</p>
<h3 id=equals와의-관계>equals와의 관계</h3>
<p>주석을 읽어보면 hashCode 메소드가 equals와 밀접한 관련이 있음을 알 수 있다.</p>
<p>이펙티브 자바(Effective Java)에서는 다음과 같은 규칙을 제안하고 있다.</p>
<blockquote>
</blockquote>
<ul>
<li>규칙 9. equals를 재정의할 때는 반드시 hashCode도 재정의하라(2판)</li>
<li>아이템 11. equals를 재정의하려거든 hashCode도 재정의하라(3판)</li>
</ul>
<p>equals를 재정의할 때, hashCode도 재정의하지 않으면, 2번 규약을 어길 수 있기 때문이다.</p>
<h3 id=이상적인-해시-함수에-가까운-함수-만들기>이상적인 해시 함수에 가까운 함수 만들기</h3>
<h4 id=effective-java2판>Effective Java(2판)</h4>
<blockquote>
</blockquote>
<p>다행히도 이상적인 해시 함수에 &lsquo;가까운&rsquo; 함수를 만드는 건 별로 어렵지 않다. 아래의 지침을 따르면 된다.
<br></p>
<ol>
<li><code>17</code>과 같은 <code>0</code> 아닌 상수를 <code>result</code>라는 이름의 <code>int</code> 변수에 저장한다.</li>
<li>객체 안에 있는 모든 중요 필드 <code>f</code>에 대해서(<code>equals</code> 메서드가 사용하는 필드들을 말한다) 아래의 절차를 시행한다.
<ul>
<li>A. 해당 필드에 대한 <code>int</code> 해시 코드 <code>c</code>를 계산한다.
<ul>
<li>i. 필드가 <code>boolean</code>이면 <code>(f ? 1 : 0)</code>을 계산한다.</li>
<li>ii. 필드가 <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code> 중 하나이면 <code>(int) f</code>를 계산한다.</li>
<li>iii. 필드가 <code>long</code>이면 <code>(int)(f ^ (f >>> 32))</code>를 계산한다.</li>
<li>iv. 필드가 <code>float</code>이면 <code>Float.floatToIntBits(f)</code>를 계산한다.</li>
<li>v. 필드가 <code>double</code>이면 <code>Double.doubleToLongBits(f)</code>를 계산하고 그 결과로 얻은 <code>long</code> 값을 위의 절차 iii 에 따라 해시 코드로 변환한다.</li>
<li>vi. 필드가 객체 참조이고 <code>equals</code> 메서드가 해당 필드의 <code>equals</code> 메서드를 재귀적으로 호출하는 경우에는 해당 필드의 <code>hashCode</code> 메서드를 제귀적으로 호출하여 해시 코드를 계산한다. 좀 더 복잡한 비교가 필요한 경우에는 해당 필드의 &ldquo;대표 형태(canonical representation)&ldquo;를 계산한 다음, 대표 형태에 대해 <code>hashCode</code>를 호출한다. 필드 값이 <code>null</code>인 경우에는 <code>0</code>을 반환한다. (다른 상수를 반환할 수도 있으나, 보통 <code>0</code>을 사용한다.)</li>
<li>vii. 필드가 배열인 경우에는 배열의 각 원소가 별도 필드인 것처럼 계산한다. 즉, 각각의 중요 원소에 대해서 방금 설명한 규칙들을 재귀적으로 적용해 해시 코드를 계산하고, 그 결과를 절차 2.B와 같이 결합한다. 배열 내의 모든 원소가 중요하다면 JDK 1.5 부터 제공되는 <code>Arrays.hashCode</code> 메소드 가운데 하나를 사용할 수도 있다.</li>
</ul>
</li>
<li>B. 위의 절차 A에서 계산된 해시 코드 <code>c</code>를 <code>result</code>에 다음과 같이 결합한다.
<ul>
<li><code>result = 31 * result + c</code></li>
</ul>
</li>
</ul>
</li>
<li><code>result</code>를 반환한다.</li>
<li><code>hashCode</code> 구현이 끝났다면, 동치 관계에 있는 객체의 해시 코드 값이 똑같이 계산되는지 점검하라. 단위 테스트를 작성해서 생각대로 되는지 확인하라. 동치 관계의 객체인데 해시 코드 값이 서로 다르다면 원인을 알아내서 고쳐라.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li>
</ol>
<h4 id=effective-java3판>Effective Java(3판)</h4>
<p>3판의 경우 내용이 바뀌었다.</p>
<blockquote>
</blockquote>
<p>다음은 좋은 hashCode를 작성하는 간단한 요령이다.<br></p>
<ol>
<li><code>int</code> 변수 <code>result</code> 를 선언한 후 값 <code>c</code>로 초기화한다. 이때 <code>c</code>는 해당 객체의 첫 번째 핵심 필드를 단계 2.a 방식으로 계산한 해시코드다(여기서 핵심 필드란 <code>equals</code> 비교에 사용되는 필드를 말한다. 아이템 10 참조).</li>
<li>해당 객체의 나머지 핵심 필드 <code>f</code> 각각에 대해 다음 작업을 수행한다.
<ul>
<li>a. 해당 필드의 해시코드 <code>c</code>를 계산한다.
<ul>
<li>i. 기본 타입 필드라면, <code>Type.hashCode(f)</code>를 수행한다. 여기서 <code>Type</code>은 해당 기본 타입의 박싱 클래스다.</li>
<li>ii. 참조 타입 필드면서 이 클래스의 <code>equals</code> 메서드가 이 필드의 <code>equals</code>를 재귀적으로 호출해 비교한다면, 이 필드의 표준형(canonical representation)을 만들어 그 표준형의 <code>hashCode</code>를 호출한다. 필드의 값이 <code>null</code> 이면 <code>0</code>을 사용한다(다른 상수도 괜찮지만 전통적으로 <code>0</code>을 사용한다).</li>
<li>iii. 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 단계 2.b 방식으로 갱신한다. 배열에 핵심 원소가 하나도 없다면 단순히 상수(<code>0</code>을 추천한다)를 사용한다. 모든 원소가 핵심 원소라면 <code>Arrays.hashCode</code>를 사용한다.</li>
</ul>
</li>
<li>b. 단계 2.a에서 계산한 해시코드 <code>c</code>로 <code>result</code>를 갱신한다. 코드로는 다음과 같다.
<ul>
<li><code>result = 31 * result + c</code></li>
</ul>
</li>
</ul>
</li>
<li><code>result</code> 를 반환한다.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></li>
</ol>
<h3 id=hashcode-메소드-예제>hashCode 메소드 예제</h3>
<h4 id=abstractsetjava>AbstractSet.java</h4>
<p>2번 규약과 3번 규약을 읽어보면 <code>equals</code> 메소드와 <code>hashCode</code> 메소드의 관계가 다음과 같음을 알 수 있다.</p>
<table>
<thead>
<tr>
<th></th>
<th>equals</th>
<th>hashCode</th>
</tr>
</thead>
<tbody>
<tr>
<td>규약 1</td>
<td>true</td>
<td><strong>같아야 한다</strong></td>
</tr>
<tr>
<td>규약 2</td>
<td>false</td>
<td>같아도 되고, 달라도 된다</td>
</tr>
</tbody>
</table>
<p>위의 경우는 이해하기 쉽지만, 아래의 경우는 이해하기 어렵다.</p>
<p>그러나 java.util.AbstractSet의 hashCode를 보면 비교적 쉽게 이해할 수 있다.</p>
<p>AbstractSet에 정의된 hashCode는 집합의 모든 원소의 hashCode 값의 총합이다.</p>
<p>따라서 다음이 가능하다.</p>
<ul>
<li>두 집합이 동치이면, 해시코드도 똑같게 된다.
<ul>
<li><code>[1, 2, 3] => 6</code>과 <code>[1, 2, 3] => 6</code></li>
</ul>
</li>
<li>두 집합이 동치가 아닌데도, 두 집합의 모든 원소의 해시코드 총합이 같을 수 있다.
<ul>
<li><code>[1, 2, 3] => 6</code>과 <code>[0, 2, 4] => 6</code></li>
</ul>
</li>
</ul>
<p>다음은 java.util.AbstractSet.java에 들어 있는 hashCode 메소드의 코드이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Returns the hash code value for this set.  The hash code of a set is
</span><span class=cm> * defined to be the sum of the hash codes of the elements in the set,
</span><span class=cm> * where the hash code of a &lt;tt&gt;null&lt;/tt&gt; element is defined to be zero.
</span><span class=cm> * This ensures that &lt;tt&gt;s1.equals(s2)&lt;/tt&gt; implies that
</span><span class=cm> * &lt;tt&gt;s1.hashCode()==s2.hashCode()&lt;/tt&gt; for any two sets &lt;tt&gt;s1&lt;/tt&gt;
</span><span class=cm> * and &lt;tt&gt;s2&lt;/tt&gt;, as required by the general contract of
</span><span class=cm> * {@link Object#hashCode}.
</span><span class=cm> *
</span><span class=cm> * &lt;p&gt;This implementation iterates over the set, calling the
</span><span class=cm> * &lt;tt&gt;hashCode&lt;/tt&gt; method on each element in the set, and adding up
</span><span class=cm> * the results.
</span><span class=cm> *
</span><span class=cm> * @return the hash code value for this set
</span><span class=cm> * @see Object#equals(Object)
</span><span class=cm> * @see Set#equals(Object)
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>()</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>i</span> <span class=o>=</span> <span class=n>iterator</span><span class=o>();</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>i</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span> <span class=o>{</span>
        <span class=n>E</span> <span class=n>obj</span> <span class=o>=</span> <span class=n>i</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>obj</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
            <span class=n>h</span> <span class=o>+=</span> <span class=n>obj</span><span class=o>.</span><span class=na>hashCode</span><span class=o>();</span>    <span class=c1>// 각 원소의 해시코드 총 합계를 구한다
</span><span class=c1></span>    <span class=o>}</span>
    <span class=k>return</span> <span class=n>h</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>번역하자면 다음과 같다.</p>
<p>hashCode 메소드는 this 집합(Set)의 해시코드 값을 리턴합니다.</p>
<p>한 집합의 해시 코드는 집합에 포함된 모든 원소의 해시코드 값의 합계로 정의됩니다.</p>
<p>만약 null 인 원소가 있다면 해당 원소의 해시코드 값은 0으로 정의합니다.</p>
<p>이 방법을 통해 두 집합 s1, s2가 <code>s1.equals(s2)</code>를 만족하는 관계라면 <code>s1.hashCode() == s2.hashCode()</code> 라는 것을 보장할 수 있으며, 이는 Object#hashCode의 일반 규약에서 요구하고 있는 것입니다.</p>
<p>이 메소드의 구현은 집합의 원소 전체를 순회하며 각각의 원소의 hashCode 메소드를 호출하여 결과에 더해가는 방식입니다.</p>
<ul>
<li>@return this 집합의 해시코드</li>
<li>@see Object#equals(Object)</li>
<li>@see Set#equals(Object)</li>
</ul>
<h4 id=abstractlistjava>AbstractList.java</h4>
<p>다음은 java.util.AbstractList.java에 들어 있는 hashCode 메소드의 코드이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Returns the hash code value for this list.
</span><span class=cm> *
</span><span class=cm> * &lt;p&gt;This implementation uses exactly the code that is used to define the
</span><span class=cm> * list hash function in the documentation for the {@link List#hashCode}
</span><span class=cm> * method.
</span><span class=cm> *
</span><span class=cm> * @return the hash code value for this list
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>()</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>hashCode</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=n>E</span> <span class=n>e</span> <span class=o>:</span> <span class=k>this</span><span class=o>)</span>
        <span class=n>hashCode</span> <span class=o>=</span> <span class=n>31</span><span class=o>*</span><span class=n>hashCode</span> <span class=o>+</span> <span class=o>(</span><span class=n>e</span><span class=o>==</span><span class=kc>null</span> <span class=o>?</span> <span class=n>0</span> <span class=o>:</span> <span class=n>e</span><span class=o>.</span><span class=na>hashCode</span><span class=o>());</span>
    <span class=k>return</span> <span class=n>hashCode</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>번역해 보았다.</p>
<p>이 메소드는 this 리스트의 해시 코드를 리턴합니다.</p>
<p>이 구현은 List 인터페이스의 hashCode 메소드 문서에 정의된 코드를 그대로 적용한 것입니다.</p>
<ul>
<li>@return this 리스트의 해시 코드</li>
<li></li>
</ul>
<h3 id=listjava>List.java</h3>
<p>다음은 java.util.List.java에 들어 있는 List 인터페이스의 hashCode 메소드 코드이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Returns the hash code value for this list.  The hash code of a list
</span><span class=cm> * is defined to be the result of the following calculation:
</span><span class=cm> * &lt;pre&gt;{@code
</span><span class=cm> *     int hashCode = 1;
</span><span class=cm> *     for (E e : list)
</span><span class=cm> *         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
</span><span class=cm> * }&lt;/pre&gt;
</span><span class=cm> * This ensures that &lt;tt&gt;list1.equals(list2)&lt;/tt&gt; implies that
</span><span class=cm> * &lt;tt&gt;list1.hashCode()==list2.hashCode()&lt;/tt&gt; for any two lists,
</span><span class=cm> * &lt;tt&gt;list1&lt;/tt&gt; and &lt;tt&gt;list2&lt;/tt&gt;, as required by the general
</span><span class=cm> * contract of {@link Object#hashCode}.
</span><span class=cm> *
</span><span class=cm> * @return the hash code value for this list
</span><span class=cm> * @see Object#equals(Object)
</span><span class=cm> * @see #equals(Object)
</span><span class=cm> */</span>
<span class=kt>int</span> <span class=nf>hashCode</span><span class=o>();</span>
</code></pre></td></tr></table>
</div>
</div><p>이 메소드는 this 리스트의 해시 코드 값을 리턴합니다.</p>
<p>리스트의 해시 코드는 다음 방법으로 계산하도록 정의되어 있습니다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kt>int</span> <span class=n>hashCode</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span>
<span class=k>for</span> <span class=o>(</span><span class=n>E</span> <span class=n>e</span> <span class=o>:</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>hashCode</span> <span class=o>=</span> <span class=n>31</span> <span class=o>*</span> <span class=n>hashCode</span> <span class=o>+</span> <span class=n>0</span><span class=o>;</span>
    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
        <span class=n>hashCode</span> <span class=o>=</span> <span class=n>31</span> <span class=o>*</span> <span class=n>hashCode</span> <span class=o>+</span> <span class=n>e</span><span class=o>.</span><span class=na>hashCode</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
<span class=k>return</span> <span class=n>hashCode</span><span class=o>;</span>
</code></pre></td></tr></table>
</div>
</div><p>이 방법을 통해 두 리스트 list1, list2가 <code>list1.equals(list2)</code>를 만족하는 관계라면 <code>list1.hashCode() == list2.hashCode()</code> 라는 것을 보장할 수 있으며, 이는 Object#hashCode의 일반 규약에서 요구하고 있는 것입니다.</p>
<ul>
<li>@return this 리스트의 해시 코드</li>
<li>@see Object#equals(Object)</li>
<li>@see #equals(Object)</li>
</ul>
<p>매직 넘버 <code>31</code>이 인상적이다.</p>
<h3 id=그런데-왜-31을-곱하는-걸까>그런데 왜 31을 곱하는 걸까?</h3>
<p>List의 hashCode 메소드를 보면 매 단계마다 각 원소의 해시코드를 더하고 <code>31</code>을 곱하고 있다.</p>
<p>그리고 앞에서 살펴본 이펙티브 자바의 hashCode 구현 요령에서도
해시값을 생성하는 과정에서 <code>31</code>을 곱하고 있다.</p>
<p>왜 <code>31</code>일까?</p>
<p>31이 소수이면서 홀수이기 때문이다</p>
<p>List 클래스 author인 Joshua Bloch가 쓴 책인 이펙티브 자바 2판을 다시 한 번 살펴보자.</p>
<blockquote>
</blockquote>
<ul>
<li>B. 위의 절차 A에서 계산된 해시 코드 c를 result에 다음과 같이 결합한다.
<ul>
<li><code>result = 31 * result + c</code> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li>
</ul>
</li>
</ul>
<p>2.B 항목을 보면 매 단계마다 <code>31</code>을 곱하라고 한다.
다음 페이지에 있는 이 부분에 대한 설명을 읽어보면 될 것 같다.</p>
<blockquote>
</blockquote>
<p><strong>31은 소수이면서 홀수이기 때문에 선택된 값이다.</strong>
만일 그 값이 짝수였고 곱셈 결과가 오버플로되었다면 정보는 사라졌을 것이다.
2로 곱하는 것은 비트를 왼쪽으로 shift하는 것과 같기 때문이다.
<strong>소수를 사용하는 이점은 그다지 분명하지 않지만 전통적으로 널리 사용된다.</strong>
31의 좋은 점은 곱셈을 시프트와 뺄셈의 조합으로 바꾸면 더 좋은 성능을 낼 수 있다는 것이다(<code>31 * i</code>는 <code>(i &lt;&lt; 5) - i</code> 와 같다).
최신 VM은 이런 최적화를 자동으로 실행한다.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p>
<p>3 판도 내용이 다르지는 않다.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p>
<p>오케이. <code>32</code>로 곱셈을 하게 되면 bit shift가 발생하게 되어 한쪽이 <code>0</code>으로 차게 되므로 하지 않는다는 것이다.</p>
<p>그러나 소수를 사용하는 이점은 분명하지 않으며, &ldquo;전통적으로 널리 사용된다"고 한다. 즉 관행이라고만 언급하고 있다.</p>
<h4 id=해시-코드-생성에-소수를-사용하는-이유>해시 코드 생성에 소수를 사용하는 이유</h4>
<p>어째서 소수를 이용하는 걸까?</p>
<p>해시 테이블에서 값을 넣고 뺄 때 사용할 해시 버킷을 선택하는 문제에 소수를 쓴다면 바로 이해할 수 있을 것 같다.
매미가 17년이나 땅 속에서 사는 것과 같은 이유로 추측할 수 있기 때문이다.
그러나 문제는 해시 코드 생성에 소수를 사용하는 이유이다.</p>
<p>인터넷을 뒤지다 다음 글을 찾을 수 있었다.</p>
<p><a href=https://bytes.com/topic/c/answers/537762-why-mult-31-hash-function-string target=_blank rel="noopener noreffer">Why MULT 31 (hash function for string)?</a></p>
<p>답변들 중 Eric Sosman의 답변이 설득력이 있어 다음과 같이 발췌하였다.</p>
<blockquote>
<p>It&rsquo;s a mixture of superstition and good sense.
<br><br>
First, the superstition: People who write code having to do with hash tables apparently recall that prime numbers are particularly &ldquo;good&rdquo; for them.
It seems they don&rsquo;t always remember just what the &ldquo;goodness&rdquo; was or in what connection, but they&rsquo;ll throw prime numbers into the mix whenever they can.
They&rsquo;ll throw in prime numbers even if they&rsquo;re not too sure what a prime number is! A colleague of mine once ran across this little coding gem:
<br><br>
#define HASHSIZE 51 /* a smallish prime */
<br><br>
Second, the good sense: Suppose MULT were 26, and consider hashing a hundred-character string.
How much influence does the string&rsquo;s first character have on the final value of &lsquo;h&rsquo;, just before the mod operation?
The first character&rsquo;s value will have been multiplied by MULT 99 times,
so if the arithmetic were done in infinite precision the value would consist of some jumble of bits followed by 99 low-order zero bits &ndash; each time you multiply by MULT you introduce another low-order zero, right?
The computer&rsquo;s finite arithmetic just chops away all the excess high-order bits, so the first character&rsquo;s actual contribution to &lsquo;h&rsquo; is &mldr; precisely zero!
The &lsquo;h&rsquo; value depends only on the rightmost 32 string characters (assuming a 32-bit int), and even then things are not wonderful:
the first of those final 32 bytes influences only the leftmost bit of &lsquo;h&rsquo; and has no effect on the remaining 31.
Clearly, an even-valued MULT is a poor idea.</p>
</blockquote>
<p>내용을 요약하자면 다음과 같다.</p>
<p>31을 사용하는 데에는 나쁜 이유와 좋은 이유가 섞여 있다.</p>
<ul>
<li>나쁜 이유는, <strong>소수에 대한 미신</strong>이다.
<ul>
<li>알고리즘 작성에 소수가 도움이 될 거라는 맹신이 있다.</li>
<li>아무 생각 없이 소수를 가져다 쓰는 사람들이 있다.</li>
<li><code>51</code>을 써놓고 <code>/* a smallish prime */</code> 이라는 주석을 붙인 코드를 본 적도 있었다.
<br><br></li>
</ul>
</li>
<li>좋은 이유는, <code>MULT</code> 값으로 <strong>짝수를 피해야 하기 때문</strong>이다.
<ul>
<li>짝수를 사용하면 해시코드를 계산할 때 <code>MULT</code>를 곱해가므로 비트의 오른쪽이 <code>0</code>으로 가득찬 결과가 나온다.</li>
<li>가령, <code>100</code>글자 문자열의 해시코드를 구하게 되면 오른쪽에 <code>0</code>이 <code>99</code>개 붙은 결과가 나오는 것이다.</li>
<li>따라서 홀수를 사용해야 한다.</li>
</ul>
</li>
</ul>
<p>홀수를 사용해야 하는데, 소수에 대한 맹신이 합쳐져 적당한 크기의 소수인 31이 사용되고 있다는 것.</p>
<p>일리 있다. 그러나 공식 레퍼런스가 근거로 달려 있지 않다는 점이 아쉽다.</p>
<h5 id=clrs-책의-나누기-방법>CLRS 책의 &ldquo;나누기 방법&rdquo;</h5>
<p>이왕 하는 김에 CLRS<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>의 11. 해시 테이블 챕터를 찾아보았다.</p>
<p>소수에 대한 언급은 많았던 반면, 31이라는 매직 넘버에 대한 언급은 없었다.</p>
<p>다음은 CLRS의 11.3.1 나누기 방법에서 발췌한 것이다.</p>
<blockquote>
<p>해시 함수를 만드는 <em>나누기 방법</em> 에서 키 $k$는 $k$를 $m$으로 나눈 나머지를 취함으로써 $m$ 개의 자리 중 하나로 위치를 결정한다.<br>
즉, 해시 함수는 $h(k) = k \pmod m$ 이다.<br>
예를 들어, 해시 테이블의 크기가 $m = 12$를 가지고 키가 $k = 100$ 일 때, $h(k) = 4$다.
단지 하나의 나누기 연산만 필요하기 때문에 나누기 방법에 의한 해싱은 매우 빠르다.
<br><br>
나누기 방법을 사용할 때 $m$이 특정 값을 갖는 것을 피하도록 선택한다.
예를 들어, $m = 2^p$이라면 $h(k)$는 $k$에서 가장 낮은 $p$비트로 이루어진 수기 때문에 $m$이 2의 지수승이 되는 것을 피하도록 한다.
모든 낮은 자리 $p$ 비트 패턴이 같은 확률로 나타나지 않는다면 키의 모든 비트를 사용하는 해시 함수를 만드는 것이 좋다.
연습문제 11.3-3과 같이 $k$가 $2^p$ 기수법으로 표현된 문자열일 때 $m = 2^p - 1$을 선택하는 것은 좋지 않은 선택이 된다.
이것은 $k$의 문자 순서를 섞는 것이 해시값을 변경하지 못하기 때문이다.
<br><br>
$m$은 2의 지수승 값에 근접하지 않은 <strong>소수</strong>를 택하는 것이 좋다.
예를 들어, $ n = 2000 $ 개의 문자열을 다루고 체이닝에 의해 충돌이 해결되는 해시 테이블을 할당하려 한다고 하자.
여기서 문자 하나는 8비트를 사용한다. 해시 테이블의 크기로 좋은 예는 $m = 701$이다.
이렇게 하면 실패하는 검색의 경우 평균 3개의 원소를 조사하게 되지만 개의치 않기로 한다. $2000/3$에 근접한 소수고 2의 지수승 값에 근접하지 않았기 때문에 701을 선택할 수 있었다.
<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p>
</blockquote>
<p>위의 내용을 요약하자면 다음과 같다.</p>
<p><strong>나누기 방법의 해시 함수는 <code>key % m</code>과 같이 나머지를 구하는 방식이다.</strong></p>
<ul>
<li>가령, 해시 테이블 크기 <code>m = 12</code>이고, <code>key = 100</code>이라면 해시 코드는 <code>100 % 12</code>로 <code>4</code>가 된다.</li>
</ul>
<p><strong>나누기 방법을 사용할 때, 해시 테이블의 크기 <code>m</code>이 피해야 하는 값이 있다.</strong></p>
<ul>
<li>
<p><code>m</code>이 2의 <code>p</code>제곱인 숫자가 되지 않도록 한다.</p>
<ul>
<li><code>key</code>의 가장 오른쪽 <code>p</code> 개의 비트만을 취하게 되므로 피하는 것이 좋다.</li>
<li>왜냐하면, 키 값의 모든 비트를 활용하는 쪽이 더 균등하게 퍼진 해시 값을 만들어 내는 데에 도움이 될 것이기 때문이다.</li>
<li>오른쪽 비트들이 모두 같고 왼쪽 비트들만 다른 값이 들어오는 경우가 있을 수 있기 때문이다.</li>
</ul>
</li>
<li>
<p><code>key</code>가 2의 거듭제곱 기수법으로 표현된 문자열일 때(2진법, 8진법, 16진법&mldr;), <code>m</code>이 <code>2^p - 1</code>이 되지 않도록 한다.</p>
<ul>
<li>이런 상황에서는 모든 키 값이 같은 해시값을 갖게 되기 때문이다.</li>
</ul>
</li>
</ul>
<p><strong><code>m</code> 값으로는 2의 거듭제곱 값과 어느 정도 거리가 있는 소수를 선택하자.</strong></p>
<ul>
<li>해시 테이블에 집어넣을 아이템이 <code>2000</code>개이고, 해시 충돌은 링크드 리스트로 해결한다고 하자.</li>
<li>이 해시 테이블의 크기 <code>m</code>은 <code>701</code>이 적절한 것 같다.</li>
<li><code>701</code>은 소수이다.</li>
<li><code>2000 / 701 = 2.853..</code> 이므로 각 해시 버킷의 리스트 최대 길이는 <code>3</code>이 된다.
<ul>
<li>해시 충돌로 루프를 돌며 선형 검색을 한다고 해도 <code>3</code>개만 검사하면 된다는 것이다.</li>
</ul>
</li>
</ul>
<p>이것도 잘 읽어보면 적당한 홀수 값을 선택하면 될 것 같은데, 굳이 소수를 선택하는 것 같다.</p>
<p>그런데 이걸 보다가 java.util.HashMap의 구현이 궁금해서 클래스를 열어보았는데,
java.util.HashMap은 나누기 방법을 좀 다른 방식으로 사용한다는 것을 알게 되었다.</p>
<h3 id=javautilhashmap>java.util.HashMap</h3>
<p>다음은 java.util.HashMap의 put 메소드가 호출하는 putVal 메소드의 앞부분이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=n>V</span> <span class=nf>putVal</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>onlyIfAbsent</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>evict</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>tab</span><span class=o>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=n>i</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span>
        <span class=n>n</span> <span class=o>=</span> <span class=o>(</span><span class=n>tab</span> <span class=o>=</span> <span class=n>resize</span><span class=o>()).</span><span class=na>length</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=o>])</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
    <span class=k>else</span> <span class=o>{</span>
    <span class=cm>/* 이후 생략*/</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>n = (tab = resize()).length</code>로 해시 테이블의 사이즈 <code>n</code>을 구한 다음,
<code>i = (n - 1) & hash</code> 비트 연산으로 빠르게 나머지를 구해 해시 버킷 <code>i</code>를 결정하고 있다.</p>
<p>테이블 사이즈를 구하는 메소드는 다음과 같다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>=</span> <span class=n>1</span> <span class=o>&lt;&lt;</span> <span class=n>30</span><span class=o>;</span>    <span class=c1>// 2의 30 제곱
</span><span class=c1></span>
<span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>tableSizeFor</span><span class=o>(</span><span class=kt>int</span> <span class=n>cap</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>cap</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
    <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>1</span><span class=o>;</span>
    <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>2</span><span class=o>;</span>
    <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>4</span><span class=o>;</span>
    <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>8</span><span class=o>;</span>
    <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=o>;</span>
    <span class=k>return</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>?</span> <span class=n>1</span> <span class=o>:</span> <span class=o>(</span><span class=n>n</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>?</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>:</span> <span class=n>n</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>비트 연산이 들어가서 좀 헷갈리긴 하지만, 잘 살펴보면 <code>cap</code>보다 큰 가장 작은 2의 제곱수를 구하는 메소드이다.</p>
<p>예를 들어 <code>55</code>를 넣으면 <code>64</code>가 나오고, <code>3172</code>를 넣으면 <code>4096</code>이 나오는 메소드라 할 수 있다.</p>
<p>테이블 사이즈인 <code>n</code> 값은 2의 제곱수이므로, <code>(n-1) & hash</code>는 그냥 나머지를 구하는 연산이란 것을 알 수 있다.</p>
<p>즉, java.util.HashMap은 CLRS의 나누기 방법을 사용하고 있다.</p>
<p>그런 한편으로는 테이블 사이즈로 CLRS에서 추천하는 방법은 아니라고 했던 2의 거듭제곱을 쓰고 있다.</p>
<p>하지만 <code>hash</code>메소드를 읽어보면, 가장 하위 비트가 아니라 가장 상위 비트 16개를 사용하고 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>hash</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>h</span><span class=o>;</span>
    <span class=k>return</span> <span class=o>(</span><span class=n>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=n>0</span> <span class=o>:</span> <span class=o>(</span><span class=n>h</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>hashCode</span><span class=o>())</span> <span class=o>^</span> <span class=o>(</span><span class=n>h</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=o>);</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>즉 CLRS에서 언급한 문제인 해시코드의 가장 하위 비트가 아니라 상위 비트를 사용하고 있으므로 성급하게 판단할 필요는 없을 것 같다.</p>
<h3 id=project-lombok의-hashcode-메소드-자동-구현>Project Lombok의 hashCode 메소드 자동 구현</h3>
<p>Lombok의 <code>@EqualsAndHashCode</code>를 사용하면 <code>equals</code>와 <code>hashCode</code> 메소드를 자동으로 만들어준다.</p>
<p>그런데 롬복은 <code>31</code>이 아니라 다른 소수를 사용하고 있다는 것을 알게 되었다.</p>
<p>다음은 롬복 홈페이지에서 복사해 온 코드이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kn>import</span> <span class=nn>lombok.EqualsAndHashCode</span><span class=o>;</span>

<span class=c1>// id와 shape를 제외한 나머지 필드를 참조하는 equals와 hashCode 생성
</span><span class=c1></span><span class=nd>@EqualsAndHashCode</span><span class=o>(</span><span class=n>exclude</span><span class=o>={</span><span class=s>&#34;id&#34;</span><span class=o>,</span> <span class=s>&#34;shape&#34;</span><span class=o>})</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>EqualsAndHashCodeExample</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>transient</span> <span class=kt>int</span> <span class=n>transientVar</span> <span class=o>=</span> <span class=n>10</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>String</span> <span class=n>name</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>double</span> <span class=n>score</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>Shape</span> <span class=n>shape</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Square</span><span class=o>(</span><span class=n>5</span><span class=o>,</span> <span class=n>10</span><span class=o>);</span>
    <span class=kd>private</span> <span class=n>String</span><span class=o>[]</span> <span class=n>tags</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>

    <span class=kd>public</span> <span class=n>String</span> <span class=nf>getName</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>name</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=nd>@EqualsAndHashCode</span><span class=o>(</span><span class=n>callSuper</span><span class=o>=</span><span class=kc>true</span><span class=o>)</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Square</span> <span class=kd>extends</span> <span class=n>Shape</span> <span class=o>{</span>
        <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>width</span><span class=o>,</span> <span class=n>height</span><span class=o>;</span>

        <span class=kd>public</span> <span class=nf>Square</span><span class=o>(</span><span class=kt>int</span> <span class=n>width</span><span class=o>,</span> <span class=kt>int</span> <span class=n>height</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>this</span><span class=o>.</span><span class=na>width</span> <span class=o>=</span> <span class=n>width</span><span class=o>;</span>
            <span class=k>this</span><span class=o>.</span><span class=na>height</span> <span class=o>=</span> <span class=n>height</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>위와 같이 <code>@EqualsAndHashCode</code> 어노테이션을 사용하면 다음과 같은 메소드가 자동생성된다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=nd>@Override</span> <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>o</span> <span class=o>==</span> <span class=k>this</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(!(</span><span class=n>o</span> <span class=k>instanceof</span> <span class=n>EqualsAndHashCodeExample</span><span class=o>))</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=n>EqualsAndHashCodeExample</span> <span class=n>other</span> <span class=o>=</span> <span class=o>(</span><span class=n>EqualsAndHashCodeExample</span><span class=o>)</span> <span class=n>o</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(!</span><span class=n>other</span><span class=o>.</span><span class=na>canEqual</span><span class=o>((</span><span class=n>Object</span><span class=o>)</span><span class=k>this</span><span class=o>))</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>getName</span><span class=o>()</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>?</span> <span class=n>other</span><span class=o>.</span><span class=na>getName</span><span class=o>()</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>:</span> <span class=o>!</span><span class=k>this</span><span class=o>.</span><span class=na>getName</span><span class=o>().</span><span class=na>equals</span><span class=o>(</span><span class=n>other</span><span class=o>.</span><span class=na>getName</span><span class=o>()))</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>Double</span><span class=o>.</span><span class=na>compare</span><span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>score</span><span class=o>,</span> <span class=n>other</span><span class=o>.</span><span class=na>score</span><span class=o>)</span> <span class=o>!=</span> <span class=n>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(!</span><span class=n>Arrays</span><span class=o>.</span><span class=na>deepEquals</span><span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>tags</span><span class=o>,</span> <span class=n>other</span><span class=o>.</span><span class=na>tags</span><span class=o>))</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
<span class=o>}</span>

<span class=nd>@Override</span> <span class=kd>public</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>()</span> <span class=o>{</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>PRIME</span> <span class=o>=</span> <span class=n>59</span><span class=o>;</span>   <span class=c1>// Lombok은 31이 아니라 조금 더 큰 소수인 59를 쓰고 있다
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span>
    <span class=kd>final</span> <span class=kt>long</span> <span class=n>temp1</span> <span class=o>=</span> <span class=n>Double</span><span class=o>.</span><span class=na>doubleToLongBits</span><span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>score</span><span class=o>);</span>
    <span class=n>result</span> <span class=o>=</span> <span class=o>(</span><span class=n>result</span> <span class=o>*</span> <span class=n>PRIME</span><span class=o>)</span> <span class=o>+</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>name</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>?</span> <span class=n>43</span> <span class=o>:</span> <span class=k>this</span><span class=o>.</span><span class=na>name</span><span class=o>.</span><span class=na>hashCode</span><span class=o>());</span>
    <span class=n>result</span> <span class=o>=</span> <span class=o>(</span><span class=n>result</span> <span class=o>*</span> <span class=n>PRIME</span><span class=o>)</span> <span class=o>+</span> <span class=o>(</span><span class=kt>int</span><span class=o>)(</span><span class=n>temp1</span> <span class=o>^</span> <span class=o>(</span><span class=n>temp1</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>32</span><span class=o>));</span>
    <span class=n>result</span> <span class=o>=</span> <span class=o>(</span><span class=n>result</span> <span class=o>*</span> <span class=n>PRIME</span><span class=o>)</span> <span class=o>+</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>deepHashCode</span><span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>tags</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>이 예제를 보면 Lombok의 hashCode 메소드는 <code>31</code>이 아니라 <code>59</code>를 사용하고 있다.</p>
<p>궁금해서 찾아보니 HandlerUtil 클래스 <a href=https://github.com/rzwitserloot/lombok/blob/760a4ec0d35f80bb7aa7089753643ba4c298d62b/src/core/lombok/core/handlers/HandlerUtil.java#L61 target=_blank rel="noopener noreffer">primeForHashcode 메소드</a>에 상수로 작성되어 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>primeForHashcode</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>59</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>그리고 HandleEqualsAndHashCode 클래스 <a href=https://github.com/rzwitserloot/lombok/blob/045638ec1f79f68747f135061d2e026faa719642/src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java#L262 target=_blank rel="noopener noreffer">createHashCode 메소드</a>에서 이를 사용하고 있는 것을 보면,
hashCode 메소드 생성에 <code>59</code>를 사용하고 있는 것이 맞는 것 같다.</p>
<p>좀 더 뒤져보니 <a href=https://github.com/rzwitserloot/lombok/commit/14cc54527663018cdf7343eefffc8c37fbce93bb#diff-01082d42a593f828cc90164b842e96ddR31 target=_blank rel="noopener noreffer">관련 commit</a>도 찾을 수 있었다.</p>
<p><code>59</code>가 사용된 것은 <code>v.1.16.20</code>부터이며
<a href=https://github.com/rzwitserloot/lombok/commit/14cc54527663018cdf7343eefffc8c37fbce93bb#diff-01082d42a593f828cc90164b842e96ddL30 target=_blank rel="noopener noreffer">diff를 보면</a> 본래 <code>59</code>가 아니라 <code>277</code>을 사용하고 있었다는 것도 알 수 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>PRIME_FOR_HASHCODE</span> <span class=o>=</span> <span class=n>277</span><span class=o>;</span>
</code></pre></td></tr></table>
</div>
</div><p><a href=https://github.com/rzwitserloot/lombok/commit/14cc54527663018cdf7343eefffc8c37fbce93bb#diff-ac92d0caf5382ec198bbb28bd2ed7e33R6 target=_blank rel="noopener noreffer">changelog를 보면</a>
해시 코드 생성에 <code>277</code>을 쓰고 있었지만 <code>127</code>보다 작은 소수를 쓰기로 결정한 것으로 보인다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=gu>#### v1.12.5 &#34;Edgy Guinea Pig&#34;
</span><span class=gu></span><span class=k>*</span> DETAIL: {Delombok} Inside enum bodies the delombok formatter didn&#39;t respect the emptyLines directive [<span class=nt>Issue #529</span>](<span class=na> https://code.google.com/p/projectlombok/issues/detail?id=629 </span>).
<span class=k>*</span> DETAIL: Use smaller primes (<span class=p>&lt;</span><span class=nt>127</span><span class=err>)</span> <span class=na>for</span> <span class=na>generating</span> <span class=na>hashcodes</span> [<span class=nt>Issue #625</span>](<span class=na>https://code.google.com/p/projectlombok/issues/detail?id=625</span>)
</code></pre></td></tr></table>
</div>
</div><p>안타깝게도 changelog의 링크는 모두 깨져 있었다.</p>
<p>그러나 31이 아닌 다른 소수를 사용하고 있어 31이 절대적인 숫자가 아니라는 것은 확인한 느낌이다.</p>
<h3 id=javalangobjecthashcode-의-native-코드>java.lang.Object.hashCode 의 native 코드</h3>
<p>Object.java 클래스의 hashCode 메소드는 다음과 같이 선언되어 있었다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>native</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>();</span>
</code></pre></td></tr></table>
</div>
</div><p>다음은 <a href=http://hg.openjdk.java.net/jdk10/jdk10/hotspot/file/tip/src/share/vm/prims/jvm.cpp target=_blank rel="noopener noreffer">hotspot의 jvm.cpp 파일에서 발췌</a>한 것이다. 버전은 JDK10 이지만, JDK8과 차이점은 없다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=n>JVM_ENTRY</span><span class=p>(</span><span class=n>jint</span><span class=p>,</span> <span class=n>JVM_IHashCode</span><span class=p>(</span><span class=n>JNIEnv</span><span class=o>*</span> <span class=n>env</span><span class=p>,</span> <span class=n>jobject</span> <span class=n>handle</span><span class=p>))</span>
  <span class=n>JVMWrapper</span><span class=p>(</span><span class=s>&#34;JVM_IHashCode&#34;</span><span class=p>);</span>
  <span class=c1>// as implemented in the classic virtual machine; return 0 if object is NULL
</span><span class=c1></span>  <span class=k>return</span> <span class=n>handle</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>ObjectSynchronizer</span><span class=o>::</span><span class=n>FastHashCode</span> <span class=p>(</span><span class=n>THREAD</span><span class=p>,</span> <span class=n>JNIHandles</span><span class=o>::</span><span class=n>resolve_non_null</span><span class=p>(</span><span class=n>handle</span><span class=p>))</span> <span class=p>;</span>
<span class=n>JVM_END</span>
</code></pre></td></tr></table>
</div>
</div><p><a href=http://hg.openjdk.java.net/jdk10/jdk10/hotspot/file/tip/src/share/vm/runtime/synchronizer.cpp target=_blank rel="noopener noreffer"><code>JVM_IHashCode</code> 는 <code>ObjectSynchronizer::FastHashCode</code></a>를 사용하고 있다. 그리고 이 함수를 잘 읽어보면 새로운 해시 코드 할당은 <code>get_next_hash</code> 함수를 사용한다는 것을 알 수 있다.</p>
<p>다음은 <code>get_next_hash</code> 함수의 코드이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// hashCode() generation :
</span><span class=c1>//
</span><span class=c1>// Possibilities:
</span><span class=c1>// * MD5Digest of {obj,stwRandom}
</span><span class=c1>// * CRC32 of {obj,stwRandom} or any linear-feedback shift register function.
</span><span class=c1>// * A DES- or AES-style SBox[] mechanism
</span><span class=c1>// * One of the Phi-based schemes, such as:
</span><span class=c1>//   2654435761 = 2^32 * Phi (golden ratio)
</span><span class=c1>//   HashCodeValue = ((uintptr_t(obj) &gt;&gt; 3) * 2654435761) ^ GVars.stwRandom ;
</span><span class=c1>// * A variation of Marsaglia&#39;s shift-xor RNG scheme.
</span><span class=c1>// * (obj ^ stwRandom) is appealing, but can result
</span><span class=c1>//   in undesirable regularity in the hashCode values of adjacent objects
</span><span class=c1>//   (objects allocated back-to-back, in particular).  This could potentially
</span><span class=c1>//   result in hashtable collisions and reduced hashtable efficiency.
</span><span class=c1>//   There are simple ways to &#34;diffuse&#34; the middle address bits over the
</span><span class=c1>//   generated hashCode values:
</span><span class=c1></span>
<span class=k>static</span> <span class=kr>inline</span> <span class=n>intptr_t</span> <span class=nf>get_next_hash</span><span class=p>(</span><span class=n>Thread</span> <span class=o>*</span> <span class=n>Self</span><span class=p>,</span> <span class=n>oop</span> <span class=n>obj</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>intptr_t</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>hashCode</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// This form uses global Park-Miller RNG.
</span><span class=c1></span>    <span class=c1>// On MP system we&#39;ll have lots of RW access to a global, so the
</span><span class=c1></span>    <span class=c1>// mechanism induces lots of coherency traffic.
</span><span class=c1></span>    <span class=n>value</span> <span class=o>=</span> <span class=n>os</span><span class=o>::</span><span class=n>random</span><span class=p>();</span>
  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>hashCode</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// This variation has the property of being stable (idempotent)
</span><span class=c1></span>    <span class=c1>// between STW operations.  This can be useful in some of the 1-0
</span><span class=c1></span>    <span class=c1>// synchronization schemes.
</span><span class=c1></span>    <span class=n>intptr_t</span> <span class=n>addrBits</span> <span class=o>=</span> <span class=n>cast_from_oop</span><span class=o>&lt;</span><span class=n>intptr_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>3</span><span class=p>;</span>
    <span class=n>value</span> <span class=o>=</span> <span class=n>addrBits</span> <span class=o>^</span> <span class=p>(</span><span class=n>addrBits</span> <span class=o>&gt;&gt;</span> <span class=mi>5</span><span class=p>)</span> <span class=o>^</span> <span class=n>GVars</span><span class=p>.</span><span class=n>stwRandom</span><span class=p>;</span>
  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>hashCode</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>value</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>            <span class=c1>// for sensitivity testing
</span><span class=c1></span>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>hashCode</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>value</span> <span class=o>=</span> <span class=o>++</span><span class=n>GVars</span><span class=p>.</span><span class=n>hcSequence</span><span class=p>;</span>
  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>hashCode</span> <span class=o>==</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>value</span> <span class=o>=</span> <span class=n>cast_from_oop</span><span class=o>&lt;</span><span class=n>intptr_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=c1>// Marsaglia&#39;s xor-shift scheme with thread-specific state
</span><span class=c1></span>    <span class=c1>// This is probably the best overall implementation -- we&#39;ll
</span><span class=c1></span>    <span class=c1>// likely make this the default in future releases.
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=n>t</span> <span class=o>=</span> <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateX</span><span class=p>;</span>
    <span class=n>t</span> <span class=o>^=</span> <span class=p>(</span><span class=n>t</span> <span class=o>&lt;&lt;</span> <span class=mi>11</span><span class=p>);</span>
    <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateX</span> <span class=o>=</span> <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateY</span><span class=p>;</span>
    <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateY</span> <span class=o>=</span> <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateZ</span><span class=p>;</span>
    <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateZ</span> <span class=o>=</span> <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateW</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=n>v</span> <span class=o>=</span> <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateW</span><span class=p>;</span>
    <span class=n>v</span> <span class=o>=</span> <span class=p>(</span><span class=n>v</span> <span class=o>^</span> <span class=p>(</span><span class=n>v</span> <span class=o>&gt;&gt;</span> <span class=mi>19</span><span class=p>))</span> <span class=o>^</span> <span class=p>(</span><span class=n>t</span> <span class=o>^</span> <span class=p>(</span><span class=n>t</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span><span class=p>));</span>
    <span class=n>Self</span><span class=o>-&gt;</span><span class=n>_hashStateW</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
    <span class=n>value</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=n>value</span> <span class=o>&amp;=</span> <span class=n>markOopDesc</span><span class=o>::</span><span class=n>hash_mask</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=n>value</span> <span class=o>=</span> <span class=mh>0xBAD</span><span class=p>;</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>value</span> <span class=o>!=</span> <span class=n>markOopDesc</span><span class=o>::</span><span class=n>no_hash</span><span class=p>,</span> <span class=s>&#34;invariant&#34;</span><span class=p>);</span>
  <span class=k>return</span> <span class=n>value</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=links>Links</h3>
<ul>
<li>
<p><a href=https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html target=_blank rel="noopener noreffer">Object(docs.oracle.com/javase/8)</a></p>
</li>
<li>
<p><a href=https://bytes.com/topic/c/answers/537762-why-mult-31-hash-function-string target=_blank rel="noopener noreffer">Why MULT 31 (hash function for string)?</a></p>
</li>
<li>
<p>Lombok</p>
<ul>
<li><a href=https://projectlombok.org/features/EqualsAndHashCode target=_blank rel="noopener noreffer">@EqualsAndHashCode</a></li>
<li><a href=https://github.com/rzwitserloot/lombok/commit/14cc54527663018cdf7343eefffc8c37fbce93bb#diff-01082d42a593f828cc90164b842e96ddR31 target=_blank rel="noopener noreffer">Issue 625: use (even) better primes for hashcodes</a></li>
</ul>
</li>
</ul>
<h3 id=참고문헌>참고문헌</h3>
<ul>
<li>이펙티브 자바 (2판) / 조슈아 블로크 저 / 이병준 역 / 인사이트(insight) / 초판 2쇄 2015년 07월 21일</li>
<li>이펙티브 자바 (3판) / 조슈아 블로크 저/개앞맵시 역 / 인사이트(insight) / 초판 2쇄 2018년 11월 21일</li>
<li>Introduction to Algorithms (3판) / 토머스 코멘, 찰스 레이서손, 로날드 리베스트, 클리포드 스타인 공저 / 문병로, 심규석, 이충세 공역 / 한빛아카데미 / 초판 3쇄 2016년 07월 29일</li>
</ul>
<h3 id=주석>주석</h3>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>이펙티브 자바 2판. 규칙 9. 64쪽.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p>이펙티브 자바 3판. 아이템 11. 68쪽.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p>이펙티브 자바 2판. 규칙 9. 65쪽.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p>이펙티브 자바 3판. 아이템 11. 70쪽.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p>Introduction to Algorithms 제목이 너무 길어서 CLRS라고 부르곤 한다. C, L, R, S 는 저자들의 이니셜이다.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:6 role=doc-endnote>
<p>Introduction to Algorithms. 11. 264쪽.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>Updated on 2022-02-07</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md><span>
<a class=link-to-markdown href=/equals-and-hashcode/index.md target=_blank>Read Markdown</a>
</span></div>
<div class=post-info-share>
<span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://youngeun-in.github.io/equals-and-hashcode/ data-title="equals와 hashCode" data-hashtags=equals,hashcode><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://youngeun-in.github.io/equals-and-hashcode/ data-hashtag=equals><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://youngeun-in.github.io/equals-and-hashcode/ data-title="equals와 hashCode"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://youngeun-in.github.io/equals-and-hashcode/ data-title="equals와 hashCode"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://youngeun-in.github.io/equals-and-hashcode/ data-title="equals와 hashCode"><i class="fab fa-weibo fa-fw"></i></a></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/equals/>equals</a>,&nbsp;<a href=/tags/hashcode/>hashcode</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span>
</section>
</div>
<div class=post-nav><a href=/enum-usage-2/ class=prev rel=prev title="Enum 사용 (활용)"><i class="fas fa-angle-left fa-fw"></i>Enum 사용 (활용)</a>
<a href=/spring-psa/ class=next rel=next title="Spring PSA">Spring PSA<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments><div id=utterances></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.92.0">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>yyoungeunin</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div>
</footer>
</div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:-1},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"",lightTheme:"github-light",repo:"YoungEun-IN/blog-comment"}},data:{"id-1":"DevLog","id-2":"DevLog"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:100}}</script><script type=text/javascript src=/js/theme.min.js></script></body>
</html>