[{"categories":["java"],"contents":"Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다. 위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다.  캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다. - 나무위키  Array 는 연속적인 memory block 으로, array 에 처음 접근할 때 전체 array 가 cache 에 로드된다. 첫 액세스 이후로는 공간 지역성이 생기는 것이다. 그러나 java 는 jvm 이 알아서 메모리를 관리 하기 때문에 array 사용시 cache locality 가 적용되는지 여부는 jvm 이 메모리 관리하는 방법을 공부해서 좀 더 알아봐야 할 것 같다. 지금 자세한 설명을 할 지식은 없지만 아마 java 에서는 ‘해당사항 없음’ 이라는 결론이 날 것 같다. ArrayList Java 의 ArrayList 는 AbstractList 를 상속받고 List 인터페이스를 구현한 클래스이다. Array 와 비슷하지만 size 가 dynamic 하게 조절된다. ArrayList.java 코드를 열어보면 default size 는 10 인 것을 알 수 있다. 1  private static final int DEFAULT_CAPACITY = 10;   ArrayList 에서 새로운 element 를 추가하는 메소드는 add() 로, 두 가지 방식의 오버로딩 된 메소드가 정의되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return \u0026lt;tt\u0026gt;true\u0026lt;/tt\u0026gt; (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!!  System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; }   아래에 있는 add() 메소드는 특정 index 에 element 를 삽입하는 메소드로, 어떤 작업을 한 다음에 기존 array 를 copy 한 더 큰 size 를 가진 새로운 array 를 만들어 낸다. 결국 copy 라는 작업이 필요한 것이다. 그럼 매개변수 하나만 받는 위에있는 add() 는 어떻게 동작하는 걸까? 방금 언급한 어떤 작업 에서 ensureCapacityInternal() 메소드가 사이즈 조절을 담당한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); }   ensureCapacityInternal() 메소드로 가보면, 사이즈 조절을 위해 ensureExplicitCapacity() 를 또 호출한다. ensureExplicitCapacity() 메소드에서는 if (minCapacity - elementData.length \u0026gt; 0) 이 if 문에 의해 현재 data 를 담고 있는 array 의 length 가 full 이면 grow() 라는 함수를 호출해서 size 를 늘린다. grow() 함수로 가보면 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  elementData = Arrays.copyOf(elementData, newCapacity); }   int newCapacity = oldCapacity + (oldCapacity \u0026raquo; 1); 여기가 포인트다. 비트연산으로 기존 size 의 1/2 만큼 새로운 capacity 를 할당하도록 한다. oldCapacity 값이 10 (default) 이었다면, 10 \u0026raquo; 1 의 경우 10 의 2진수인 1010(2) 을 1-bit right shifting 한 값인 0101(2) , 즉 10진수 5 만큼 size 를 키우는 것이다. 이렇게 size 키워서 결국 한다는 게 copy 다. 결국 java 에서 제공하는 ArrayList 도 별다른 신박한 방법으로 관리하는 array 가 아니라 그냥 array 인 것이다. 즉, size 가 고정되지 않게 하려면 비용이 많이 든다는 단점이 있는 것은 확실하다. ","permalink":"https://youngeun-in.github.io/array-arraylist/","tags":["array","array-list"],"title":"Array \u0026 ArrayList"},{"categories":["java"],"contents":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. Local Class 중괄호 내에, 특히 메소드 내에 정의 Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","permalink":"https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/","tags":["nested-class"],"title":"자바의 Nested Class"},{"categories":["spring"],"contents":"Spring의 대표적인 핵심가치 3가지로 IoC, AOP, PSA가 있다. PSA (Portable Service Abstraction) @Transactional 어노테이션을 선언하는 것 만으로 별도의 코드 추가 없이 트랜잭션 서비스를 사용할 수 있다. 내부적으로 트랜잭션 코드가 추상화되어 숨겨져 있는 것이다. 이렇게 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이며, 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다. PSA의 원리 트랜잭션을 예로 들어 설명하겠다. 위 그림처럼 Spring의 @Transactional은 각 TransactionManager를 각각 구현하고 있는 것이 아니라 최상위 PlatformTransactionManager를 이용하고 필요한 TransactionManager를 DI로 주입받아 사용하고 있다. PlatformTransactionManager 인터페이스의 소스코드는 다음과 같다. 1 2 3 4 5 6 7 8  public interface PlatformTransactionManager extends TransactionManager { TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException; }   ","permalink":"https://youngeun-in.github.io/spring-psa/","tags":["PSA"],"title":"Spring PSA"},{"categories":["java"],"contents":"equals 메소드 Object 클래스에 정의된 equals 메소드는 다음과 같다. 1 2 3  public boolean equals(Object obj) { return (this == obj); }   단순히 Object의 ==로 비교하는 것을 확인할 수 있다. 두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다. 1 2 3 4 5 6 7  @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AttachFile that = (AttachFile) o; return Objects.equals(id, that.id) \u0026amp;\u0026amp; Objects.equals(fileName, that.fileName) \u0026amp;\u0026amp; Objects.equals(minutes, that.minutes); }   hashCode 메소드 Object 클래스에 정의된 hashCode 메소드는 다음과 같다. 1 2 3  public static int hashCode(Object o) { return o != null ? o.hashCode() : 0; }   원문 Java 1.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * {@link java.util.HashMap}. * \u0026lt;p\u0026gt; * The general contract of {@code hashCode} is: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the {@code hashCode} method * must consistently return the same integer, provided no information * used in {@code equals} comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * \u0026lt;li\u0026gt;If two objects are equal according to the {@code equals(Object)} * method, then calling the {@code hashCode} method on each of * the two objects must produce the same integer result. * \u0026lt;li\u0026gt;It is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; required that if two objects are unequal * according to the {@link java.lang.Object#equals(java.lang.Object)} * method, then calling the {@code hashCode} method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * \u0026lt;/ul\u0026gt; * \u0026lt;p\u0026gt; * As much as is reasonably practical, the hashCode method defined by * class {@code Object} does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java\u0026amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ public native int hashCode();   번역해 보자면 다음과 같다.   hashCode 메소드는 객체의 해시코드 값을 리턴합니다. 이 메소드는 해시 테이블(java.util.HashMap 같은)을 사용할 때의 이점을 위해 제공됩니다. hashCode 메소드의 일반 규약은 다음과 같습니다.    변경되지 않은 한 객체의 hashCode 메소드를 호출한 결과는 항상 똑같은 integer 값이어야 합니다.  객체가 변경됐더라도 equals 메소드가 참고하는 정보가 변경되지 않았다면 hashCode 값은 달라지지 않습니다.   equals 메소드가 같다고 판별한 두 객체의 hashCode 호출 결과는 똑같은 integer 값이어야 합니다. 그러나 java.lang.Object.equals 메소드가 다르다고 판별한 두 객체의 hashCode 값이 반드시 달라야 하는 것은 아닙니다.  단, 같지 않은 객체들이 각기 다른 hashCode 값을 가지면 해시 테이블 성능이 향상된다는 점을 기억해두세요.      실용적인 이유로, Object 클래스의 hashCode 메소드는 다른 객체에 대해 각기 다른 integer 값을 리턴하도록 정의되었습니다. (일반적으로 객체의 내부 주소를 integer 값으로 변환하는 방식으로 구현되지만, 그러한 구현 기법은 Java(TM) 프로그래밍 언어에서는 필수적인 것은 아닙니다)    @return this 객체의 해시코드 값 @see java.lang.Object#equals(java.lang.Object) @see java.lang.System#identityHashCode  Java 13 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * {@link java.util.HashMap}. * \u0026lt;p\u0026gt; * The general contract of {@code hashCode} is: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the {@code hashCode} method * must consistently return the same integer, provided no information * used in {@code equals} comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * \u0026lt;li\u0026gt;If two objects are equal according to the {@code equals(Object)} * method, then calling the {@code hashCode} method on each of * the two objects must produce the same integer result. * \u0026lt;li\u0026gt;It is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; required that if two objects are unequal * according to the {@link java.lang.Object#equals(java.lang.Object)} * method, then calling the {@code hashCode} method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * \u0026lt;/ul\u0026gt; * * @implSpec * As far as is reasonably practical, the {@code hashCode} method defined * by class {@code Object} returns distinct integers for distinct objects. * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ @HotSpotIntrinsicCandidate public native int hashCode();   1.8과 비교해 보면 \u0026lt;p\u0026gt; 부터는 짧은 문장 하나만 남기고 나머지 부분은 삭제되었다. 그리고 남아 있는 한 문장에는 @implSpec 태그가 붙었다. 남은 문장은 다음과 같다.   As far as is reasonably practical, the hashCode method defined by class Object returns distinct integers for distinct objects.   실용적인 이유로, Object 클래스의 hashCode 메소드는 다른 객체에 대해 각기 다른 integer 값을 리턴하도록 정의되었습니다. equals와의 관계 주석을 읽어보면 hashCode 메소드가 equals와 밀접한 관련이 있음을 알 수 있다. 이펙티브 자바(Effective Java)에서는 다음과 같은 규칙을 제안하고 있다.    규칙 9. equals를 재정의할 때는 반드시 hashCode도 재정의하라(2판) 아이템 11. equals를 재정의하려거든 hashCode도 재정의하라(3판)  equals를 재정의할 때, hashCode도 재정의하지 않으면, 2번 규약을 어길 수 있기 때문이다. 이상적인 해시 함수에 가까운 함수 만들기 Effective Java(2판)   다행히도 이상적인 해시 함수에 \u0026lsquo;가까운\u0026rsquo; 함수를 만드는 건 별로 어렵지 않다. 아래의 지침을 따르면 된다.   17과 같은 0 아닌 상수를 result라는 이름의 int 변수에 저장한다. 객체 안에 있는 모든 중요 필드 f에 대해서(equals 메서드가 사용하는 필드들을 말한다) 아래의 절차를 시행한다.  A. 해당 필드에 대한 int 해시 코드 c를 계산한다.  i. 필드가 boolean이면 (f ? 1 : 0)을 계산한다. ii. 필드가 byte, char, short, int 중 하나이면 (int) f를 계산한다. iii. 필드가 long이면 (int)(f ^ (f \u0026gt;\u0026gt;\u0026gt; 32))를 계산한다. iv. 필드가 float이면 Float.floatToIntBits(f)를 계산한다. v. 필드가 double이면 Double.doubleToLongBits(f)를 계산하고 그 결과로 얻은 long 값을 위의 절차 iii 에 따라 해시 코드로 변환한다. vi. 필드가 객체 참조이고 equals 메서드가 해당 필드의 equals 메서드를 재귀적으로 호출하는 경우에는 해당 필드의 hashCode 메서드를 제귀적으로 호출하여 해시 코드를 계산한다. 좀 더 복잡한 비교가 필요한 경우에는 해당 필드의 \u0026ldquo;대표 형태(canonical representation)\u0026ldquo;를 계산한 다음, 대표 형태에 대해 hashCode를 호출한다. 필드 값이 null인 경우에는 0을 반환한다. (다른 상수를 반환할 수도 있으나, 보통 0을 사용한다.) vii. 필드가 배열인 경우에는 배열의 각 원소가 별도 필드인 것처럼 계산한다. 즉, 각각의 중요 원소에 대해서 방금 설명한 규칙들을 재귀적으로 적용해 해시 코드를 계산하고, 그 결과를 절차 2.B와 같이 결합한다. 배열 내의 모든 원소가 중요하다면 JDK 1.5 부터 제공되는 Arrays.hashCode 메소드 가운데 하나를 사용할 수도 있다.   B. 위의 절차 A에서 계산된 해시 코드 c를 result에 다음과 같이 결합한다.  result = 31 * result + c     result를 반환한다. hashCode 구현이 끝났다면, 동치 관계에 있는 객체의 해시 코드 값이 똑같이 계산되는지 점검하라. 단위 테스트를 작성해서 생각대로 되는지 확인하라. 동치 관계의 객체인데 해시 코드 값이 서로 다르다면 원인을 알아내서 고쳐라.1  Effective Java(3판) 3판의 경우 내용이 바뀌었다.   다음은 좋은 hashCode를 작성하는 간단한 요령이다.  int 변수 result 를 선언한 후 값 c로 초기화한다. 이때 c는 해당 객체의 첫 번째 핵심 필드를 단계 2.a 방식으로 계산한 해시코드다(여기서 핵심 필드란 equals 비교에 사용되는 필드를 말한다. 아이템 10 참조). 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.  a. 해당 필드의 해시코드 c를 계산한다.  i. 기본 타입 필드라면, Type.hashCode(f)를 수행한다. 여기서 Type은 해당 기본 타입의 박싱 클래스다. ii. 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의 표준형(canonical representation)을 만들어 그 표준형의 hashCode를 호출한다. 필드의 값이 null 이면 0을 사용한다(다른 상수도 괜찮지만 전통적으로 0을 사용한다). iii. 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 단계 2.b 방식으로 갱신한다. 배열에 핵심 원소가 하나도 없다면 단순히 상수(0을 추천한다)를 사용한다. 모든 원소가 핵심 원소라면 Arrays.hashCode를 사용한다.   b. 단계 2.a에서 계산한 해시코드 c로 result를 갱신한다. 코드로는 다음과 같다.  result = 31 * result + c     result 를 반환한다.2  hashCode 메소드 예제 AbstractSet.java 2번 규약과 3번 규약을 읽어보면 equals 메소드와 hashCode 메소드의 관계가 다음과 같음을 알 수 있다.     equals hashCode     규약 1 true 같아야 한다   규약 2 false 같아도 되고, 달라도 된다    위의 경우는 이해하기 쉽지만, 아래의 경우는 이해하기 어렵다. 그러나 java.util.AbstractSet의 hashCode를 보면 비교적 쉽게 이해할 수 있다. AbstractSet에 정의된 hashCode는 집합의 모든 원소의 hashCode 값의 총합이다. 따라서 다음이 가능하다.  두 집합이 동치이면, 해시코드도 똑같게 된다.  [1, 2, 3] =\u0026gt; 6과 [1, 2, 3] =\u0026gt; 6   두 집합이 동치가 아닌데도, 두 집합의 모든 원소의 해시코드 총합이 같을 수 있다.  [1, 2, 3] =\u0026gt; 6과 [0, 2, 4] =\u0026gt; 6    다음은 java.util.AbstractSet.java에 들어 있는 hashCode 메소드의 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /** * Returns the hash code value for this set. The hash code of a set is * defined to be the sum of the hash codes of the elements in the set, * where the hash code of a \u0026lt;tt\u0026gt;null\u0026lt;/tt\u0026gt; element is defined to be zero. * This ensures that \u0026lt;tt\u0026gt;s1.equals(s2)\u0026lt;/tt\u0026gt; implies that * \u0026lt;tt\u0026gt;s1.hashCode()==s2.hashCode()\u0026lt;/tt\u0026gt; for any two sets \u0026lt;tt\u0026gt;s1\u0026lt;/tt\u0026gt; * and \u0026lt;tt\u0026gt;s2\u0026lt;/tt\u0026gt;, as required by the general contract of * {@link Object#hashCode}. * * \u0026lt;p\u0026gt;This implementation iterates over the set, calling the * \u0026lt;tt\u0026gt;hashCode\u0026lt;/tt\u0026gt; method on each element in the set, and adding up * the results. * * @return the hash code value for this set * @see Object#equals(Object) * @see Set#equals(Object) */ public int hashCode() { int h = 0; Iterator\u0026lt;E\u0026gt; i = iterator(); while (i.hasNext()) { E obj = i.next(); if (obj != null) h += obj.hashCode(); // 각 원소의 해시코드 총 합계를 구한다  } return h; }   번역하자면 다음과 같다. hashCode 메소드는 this 집합(Set)의 해시코드 값을 리턴합니다. 한 집합의 해시 코드는 집합에 포함된 모든 원소의 해시코드 값의 합계로 정의됩니다. 만약 null 인 원소가 있다면 해당 원소의 해시코드 값은 0으로 정의합니다. 이 방법을 통해 두 집합 s1, s2가 s1.equals(s2)를 만족하는 관계라면 s1.hashCode() == s2.hashCode() 라는 것을 보장할 수 있으며, 이는 Object#hashCode의 일반 규약에서 요구하고 있는 것입니다. 이 메소드의 구현은 집합의 원소 전체를 순회하며 각각의 원소의 hashCode 메소드를 호출하여 결과에 더해가는 방식입니다.  @return this 집합의 해시코드 @see Object#equals(Object) @see Set#equals(Object)  AbstractList.java 다음은 java.util.AbstractList.java에 들어 있는 hashCode 메소드의 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * Returns the hash code value for this list. * * \u0026lt;p\u0026gt;This implementation uses exactly the code that is used to define the * list hash function in the documentation for the {@link List#hashCode} * method. * * @return the hash code value for this list */ public int hashCode() { int hashCode = 1; for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode; }   번역해 보았다. 이 메소드는 this 리스트의 해시 코드를 리턴합니다. 이 구현은 List 인터페이스의 hashCode 메소드 문서에 정의된 코드를 그대로 적용한 것입니다.  @return this 리스트의 해시 코드   List.java 다음은 java.util.List.java에 들어 있는 List 인터페이스의 hashCode 메소드 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * Returns the hash code value for this list. The hash code of a list * is defined to be the result of the following calculation: * \u0026lt;pre\u0026gt;{@code * int hashCode = 1; * for (E e : list) * hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); * }\u0026lt;/pre\u0026gt; * This ensures that \u0026lt;tt\u0026gt;list1.equals(list2)\u0026lt;/tt\u0026gt; implies that * \u0026lt;tt\u0026gt;list1.hashCode()==list2.hashCode()\u0026lt;/tt\u0026gt; for any two lists, * \u0026lt;tt\u0026gt;list1\u0026lt;/tt\u0026gt; and \u0026lt;tt\u0026gt;list2\u0026lt;/tt\u0026gt;, as required by the general * contract of {@link Object#hashCode}. * * @return the hash code value for this list * @see Object#equals(Object) * @see #equals(Object) */ int hashCode();   이 메소드는 this 리스트의 해시 코드 값을 리턴합니다. 리스트의 해시 코드는 다음 방법으로 계산하도록 정의되어 있습니다. 1 2 3 4 5 6 7 8 9  int hashCode = 1; for (E e : list) { if (e == null) { hashCode = 31 * hashCode + 0; } else { hashCode = 31 * hashCode + e.hashCode(); } } return hashCode;   이 방법을 통해 두 리스트 list1, list2가 list1.equals(list2)를 만족하는 관계라면 list1.hashCode() == list2.hashCode() 라는 것을 보장할 수 있으며, 이는 Object#hashCode의 일반 규약에서 요구하고 있는 것입니다.  @return this 리스트의 해시 코드 @see Object#equals(Object) @see #equals(Object)  매직 넘버 31이 인상적이다. 그런데 왜 31을 곱하는 걸까? List의 hashCode 메소드를 보면 매 단계마다 각 원소의 해시코드를 더하고 31을 곱하고 있다. 그리고 앞에서 살펴본 이펙티브 자바의 hashCode 구현 요령에서도 해시값을 생성하는 과정에서 31을 곱하고 있다. 왜 31일까? 31이 소수이면서 홀수이기 때문이다 List 클래스 author인 Joshua Bloch가 쓴 책인 이펙티브 자바 2판을 다시 한 번 살펴보자.    B. 위의 절차 A에서 계산된 해시 코드 c를 result에 다음과 같이 결합한다.  result = 31 * result + c 1    2.B 항목을 보면 매 단계마다 31을 곱하라고 한다. 다음 페이지에 있는 이 부분에 대한 설명을 읽어보면 될 것 같다.   31은 소수이면서 홀수이기 때문에 선택된 값이다. 만일 그 값이 짝수였고 곱셈 결과가 오버플로되었다면 정보는 사라졌을 것이다. 2로 곱하는 것은 비트를 왼쪽으로 shift하는 것과 같기 때문이다. 소수를 사용하는 이점은 그다지 분명하지 않지만 전통적으로 널리 사용된다. 31의 좋은 점은 곱셈을 시프트와 뺄셈의 조합으로 바꾸면 더 좋은 성능을 낼 수 있다는 것이다(31 * i는 (i \u0026lt;\u0026lt; 5) - i 와 같다). 최신 VM은 이런 최적화를 자동으로 실행한다.3 3 판도 내용이 다르지는 않다.4 오케이. 32로 곱셈을 하게 되면 bit shift가 발생하게 되어 한쪽이 0으로 차게 되므로 하지 않는다는 것이다. 그러나 소수를 사용하는 이점은 분명하지 않으며, \u0026ldquo;전통적으로 널리 사용된다\u0026quot;고 한다. 즉 관행이라고만 언급하고 있다. 해시 코드 생성에 소수를 사용하는 이유 어째서 소수를 이용하는 걸까? 해시 테이블에서 값을 넣고 뺄 때 사용할 해시 버킷을 선택하는 문제에 소수를 쓴다면 바로 이해할 수 있을 것 같다. 매미가 17년이나 땅 속에서 사는 것과 같은 이유로 추측할 수 있기 때문이다. 그러나 문제는 해시 코드 생성에 소수를 사용하는 이유이다. 인터넷을 뒤지다 다음 글을 찾을 수 있었다. Why MULT 31 (hash function for string)? 답변들 중 Eric Sosman의 답변이 설득력이 있어 다음과 같이 발췌하였다.  It\u0026rsquo;s a mixture of superstition and good sense.  First, the superstition: People who write code having to do with hash tables apparently recall that prime numbers are particularly \u0026ldquo;good\u0026rdquo; for them. It seems they don\u0026rsquo;t always remember just what the \u0026ldquo;goodness\u0026rdquo; was or in what connection, but they\u0026rsquo;ll throw prime numbers into the mix whenever they can. They\u0026rsquo;ll throw in prime numbers even if they\u0026rsquo;re not too sure what a prime number is! A colleague of mine once ran across this little coding gem:  #define HASHSIZE 51 /* a smallish prime */  Second, the good sense: Suppose MULT were 26, and consider hashing a hundred-character string. How much influence does the string\u0026rsquo;s first character have on the final value of \u0026lsquo;h\u0026rsquo;, just before the mod operation? The first character\u0026rsquo;s value will have been multiplied by MULT 99 times, so if the arithmetic were done in infinite precision the value would consist of some jumble of bits followed by 99 low-order zero bits \u0026ndash; each time you multiply by MULT you introduce another low-order zero, right? The computer\u0026rsquo;s finite arithmetic just chops away all the excess high-order bits, so the first character\u0026rsquo;s actual contribution to \u0026lsquo;h\u0026rsquo; is \u0026hellip; precisely zero! The \u0026lsquo;h\u0026rsquo; value depends only on the rightmost 32 string characters (assuming a 32-bit int), and even then things are not wonderful: the first of those final 32 bytes influences only the leftmost bit of \u0026lsquo;h\u0026rsquo; and has no effect on the remaining 31. Clearly, an even-valued MULT is a poor idea.  내용을 요약하자면 다음과 같다. 31을 사용하는 데에는 나쁜 이유와 좋은 이유가 섞여 있다.  나쁜 이유는, 소수에 대한 미신이다.  알고리즘 작성에 소수가 도움이 될 거라는 맹신이 있다. 아무 생각 없이 소수를 가져다 쓰는 사람들이 있다. 51을 써놓고 /* a smallish prime */ 이라는 주석을 붙인 코드를 본 적도 있었다.    좋은 이유는, MULT 값으로 짝수를 피해야 하기 때문이다.  짝수를 사용하면 해시코드를 계산할 때 MULT를 곱해가므로 비트의 오른쪽이 0으로 가득찬 결과가 나온다. 가령, 100글자 문자열의 해시코드를 구하게 되면 오른쪽에 0이 99개 붙은 결과가 나오는 것이다. 따라서 홀수를 사용해야 한다.    홀수를 사용해야 하는데, 소수에 대한 맹신이 합쳐져 적당한 크기의 소수인 31이 사용되고 있다는 것. 일리 있다. 그러나 공식 레퍼런스가 근거로 달려 있지 않다는 점이 아쉽다. CLRS 책의 \u0026ldquo;나누기 방법\u0026rdquo; 이왕 하는 김에 CLRS5의 11. 해시 테이블 챕터를 찾아보았다. 소수에 대한 언급은 많았던 반면, 31이라는 매직 넘버에 대한 언급은 없었다. 다음은 CLRS의 11.3.1 나누기 방법에서 발췌한 것이다.  해시 함수를 만드는 나누기 방법 에서 키 $k$는 $k$를 $m$으로 나눈 나머지를 취함으로써 $m$ 개의 자리 중 하나로 위치를 결정한다. 즉, 해시 함수는 $h(k) = k \\pmod m$ 이다. 예를 들어, 해시 테이블의 크기가 $m = 12$를 가지고 키가 $k = 100$ 일 때, $h(k) = 4$다. 단지 하나의 나누기 연산만 필요하기 때문에 나누기 방법에 의한 해싱은 매우 빠르다.  나누기 방법을 사용할 때 $m$이 특정 값을 갖는 것을 피하도록 선택한다. 예를 들어, $m = 2^p$이라면 $h(k)$는 $k$에서 가장 낮은 $p$비트로 이루어진 수기 때문에 $m$이 2의 지수승이 되는 것을 피하도록 한다. 모든 낮은 자리 $p$ 비트 패턴이 같은 확률로 나타나지 않는다면 키의 모든 비트를 사용하는 해시 함수를 만드는 것이 좋다. 연습문제 11.3-3과 같이 $k$가 $2^p$ 기수법으로 표현된 문자열일 때 $m = 2^p - 1$을 선택하는 것은 좋지 않은 선택이 된다. 이것은 $k$의 문자 순서를 섞는 것이 해시값을 변경하지 못하기 때문이다.  $m$은 2의 지수승 값에 근접하지 않은 소수를 택하는 것이 좋다. 예를 들어, $ n = 2000 $ 개의 문자열을 다루고 체이닝에 의해 충돌이 해결되는 해시 테이블을 할당하려 한다고 하자. 여기서 문자 하나는 8비트를 사용한다. 해시 테이블의 크기로 좋은 예는 $m = 701$이다. 이렇게 하면 실패하는 검색의 경우 평균 3개의 원소를 조사하게 되지만 개의치 않기로 한다. $2000/3$에 근접한 소수고 2의 지수승 값에 근접하지 않았기 때문에 701을 선택할 수 있었다. 6  위의 내용을 요약하자면 다음과 같다. 나누기 방법의 해시 함수는 key % m과 같이 나머지를 구하는 방식이다.  가령, 해시 테이블 크기 m = 12이고, key = 100이라면 해시 코드는 100 % 12로 4가 된다.  나누기 방법을 사용할 때, 해시 테이블의 크기 m이 피해야 하는 값이 있다.   m이 2의 p제곱인 숫자가 되지 않도록 한다.  key의 가장 오른쪽 p 개의 비트만을 취하게 되므로 피하는 것이 좋다. 왜냐하면, 키 값의 모든 비트를 활용하는 쪽이 더 균등하게 퍼진 해시 값을 만들어 내는 데에 도움이 될 것이기 때문이다. 오른쪽 비트들이 모두 같고 왼쪽 비트들만 다른 값이 들어오는 경우가 있을 수 있기 때문이다.    key가 2의 거듭제곱 기수법으로 표현된 문자열일 때(2진법, 8진법, 16진법\u0026hellip;), m이 2^p - 1이 되지 않도록 한다.  이런 상황에서는 모든 키 값이 같은 해시값을 갖게 되기 때문이다.    m 값으로는 2의 거듭제곱 값과 어느 정도 거리가 있는 소수를 선택하자.  해시 테이블에 집어넣을 아이템이 2000개이고, 해시 충돌은 링크드 리스트로 해결한다고 하자. 이 해시 테이블의 크기 m은 701이 적절한 것 같다. 701은 소수이다. 2000 / 701 = 2.853.. 이므로 각 해시 버킷의 리스트 최대 길이는 3이 된다.  해시 충돌로 루프를 돌며 선형 검색을 한다고 해도 3개만 검사하면 된다는 것이다.    이것도 잘 읽어보면 적당한 홀수 값을 선택하면 될 것 같은데, 굳이 소수를 선택하는 것 같다. 그런데 이걸 보다가 java.util.HashMap의 구현이 궁금해서 클래스를 열어보았는데, java.util.HashMap은 나누기 방법을 좀 다른 방식으로 사용한다는 것을 알게 되었다. java.util.HashMap 다음은 java.util.HashMap의 put 메소드가 호출하는 putVal 메소드의 앞부분이다. 1 2 3 4 5 6 7 8 9 10  final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { /* 이후 생략*/ }   n = (tab = resize()).length로 해시 테이블의 사이즈 n을 구한 다음, i = (n - 1) \u0026amp; hash 비트 연산으로 빠르게 나머지를 구해 해시 버킷 i를 결정하고 있다. 테이블 사이즈를 구하는 메소드는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11  static final int MAXIMUM_CAPACITY = 1 \u0026lt;\u0026lt; 30; // 2의 30 제곱  static final int tableSizeFor(int cap) { int n = cap - 1; n |= n \u0026gt;\u0026gt;\u0026gt; 1; n |= n \u0026gt;\u0026gt;\u0026gt; 2; n |= n \u0026gt;\u0026gt;\u0026gt; 4; n |= n \u0026gt;\u0026gt;\u0026gt; 8; n |= n \u0026gt;\u0026gt;\u0026gt; 16; return (n \u0026lt; 0) ? 1 : (n \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }   비트 연산이 들어가서 좀 헷갈리긴 하지만, 잘 살펴보면 cap보다 큰 가장 작은 2의 제곱수를 구하는 메소드이다. 예를 들어 55를 넣으면 64가 나오고, 3172를 넣으면 4096이 나오는 메소드라 할 수 있다. 테이블 사이즈인 n 값은 2의 제곱수이므로, (n-1) \u0026amp; hash는 그냥 나머지를 구하는 연산이란 것을 알 수 있다. 즉, java.util.HashMap은 CLRS의 나누기 방법을 사용하고 있다. 그런 한편으로는 테이블 사이즈로 CLRS에서 추천하는 방법은 아니라고 했던 2의 거듭제곱을 쓰고 있다. 하지만 hash메소드를 읽어보면, 가장 하위 비트가 아니라 가장 상위 비트 16개를 사용하고 있다. 1 2 3 4  static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); }   즉 CLRS에서 언급한 문제인 해시코드의 가장 하위 비트가 아니라 상위 비트를 사용하고 있으므로 성급하게 판단할 필요는 없을 것 같다. Project Lombok의 hashCode 메소드 자동 구현 Lombok의 @EqualsAndHashCode를 사용하면 equals와 hashCode 메소드를 자동으로 만들어준다. 그런데 롬복은 31이 아니라 다른 소수를 사용하고 있다는 것을 알게 되었다. 다음은 롬복 홈페이지에서 복사해 온 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import lombok.EqualsAndHashCode; // id와 shape를 제외한 나머지 필드를 참조하는 equals와 hashCode 생성 @EqualsAndHashCode(exclude={\u0026#34;id\u0026#34;, \u0026#34;shape\u0026#34;}) public class EqualsAndHashCodeExample { private transient int transientVar = 10; private String name; private double score; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() { return this.name; } @EqualsAndHashCode(callSuper=true) public static class Square extends Shape { private final int width, height; public Square(int width, int height) { this.width = width; this.height = height; } } }   위와 같이 @EqualsAndHashCode 어노테이션을 사용하면 다음과 같은 메소드가 자동생성된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  @Override public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof EqualsAndHashCodeExample)) return false; EqualsAndHashCodeExample other = (EqualsAndHashCodeExample) o; if (!other.canEqual((Object)this)) return false; if (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false; if (Double.compare(this.score, other.score) != 0) return false; if (!Arrays.deepEquals(this.tags, other.tags)) return false; return true; } @Override public int hashCode() { final int PRIME = 59; // Lombok은 31이 아니라 조금 더 큰 소수인 59를 쓰고 있다  int result = 1; final long temp1 = Double.doubleToLongBits(this.score); result = (result * PRIME) + (this.name == null ? 43 : this.name.hashCode()); result = (result * PRIME) + (int)(temp1 ^ (temp1 \u0026gt;\u0026gt;\u0026gt; 32)); result = (result * PRIME) + Arrays.deepHashCode(this.tags); return result; }   이 예제를 보면 Lombok의 hashCode 메소드는 31이 아니라 59를 사용하고 있다. 궁금해서 찾아보니 HandlerUtil 클래스 primeForHashcode 메소드에 상수로 작성되어 있다. 1 2 3  public static int primeForHashcode() { return 59; }   그리고 HandleEqualsAndHashCode 클래스 createHashCode 메소드에서 이를 사용하고 있는 것을 보면, hashCode 메소드 생성에 59를 사용하고 있는 것이 맞는 것 같다. 좀 더 뒤져보니 관련 commit도 찾을 수 있었다. 59가 사용된 것은 v.1.16.20부터이며 diff를 보면 본래 59가 아니라 277을 사용하고 있었다는 것도 알 수 있다. 1  public static final int PRIME_FOR_HASHCODE = 277;   changelog를 보면 해시 코드 생성에 277을 쓰고 있었지만 127보다 작은 소수를 쓰기로 결정한 것으로 보인다. 1 2 3  #### v1.12.5 \u0026#34;Edgy Guinea Pig\u0026#34; * DETAIL: {Delombok} Inside enum bodies the delombok formatter didn\u0026#39;t respect the emptyLines directive [Issue #529](https://code.google.com/p/projectlombok/issues/detail?id=629 ). * DETAIL: Use smaller primes (\u0026lt;127) for generating hashcodes [Issue #625](https://code.google.com/p/projectlombok/issues/detail?id=625)   안타깝게도 changelog의 링크는 모두 깨져 있었다. 그러나 31이 아닌 다른 소수를 사용하고 있어 31이 절대적인 숫자가 아니라는 것은 확인한 느낌이다. java.lang.Object.hashCode 의 native 코드 Object.java 클래스의 hashCode 메소드는 다음과 같이 선언되어 있었다. 1  public native int hashCode();   다음은 hotspot의 jvm.cpp 파일에서 발췌한 것이다. 버전은 JDK10 이지만, JDK8과 차이점은 없다. 1 2 3 4 5  JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(\u0026#34;JVM_IHashCode\u0026#34;); // as implemented in the classic virtual machine; return 0 if object is NULL  return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END   JVM_IHashCode 는 ObjectSynchronizer::FastHashCode를 사용하고 있다. 그리고 이 함수를 잘 읽어보면 새로운 해시 코드 할당은 get_next_hash 함수를 사용한다는 것을 알 수 있다. 다음은 get_next_hash 함수의 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  // hashCode() generation : // // Possibilities: // * MD5Digest of {obj,stwRandom} // * CRC32 of {obj,stwRandom} or any linear-feedback shift register function. // * A DES- or AES-style SBox[] mechanism // * One of the Phi-based schemes, such as: // 2654435761 = 2^32 * Phi (golden ratio) // HashCodeValue = ((uintptr_t(obj) \u0026gt;\u0026gt; 3) * 2654435761) ^ GVars.stwRandom ; // * A variation of Marsaglia\u0026#39;s shift-xor RNG scheme. // * (obj ^ stwRandom) is appealing, but can result // in undesirable regularity in the hashCode values of adjacent objects // (objects allocated back-to-back, in particular). This could potentially // result in hashtable collisions and reduced hashtable efficiency. // There are simple ways to \u0026#34;diffuse\u0026#34; the middle address bits over the // generated hashCode values:  static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG.  // On MP system we\u0026#39;ll have lots of RW access to a global, so the  // mechanism induces lots of coherency traffic.  value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent)  // between STW operations. This can be useful in some of the 1-0  // synchronization schemes.  intptr_t addrBits = cast_from_oop\u0026lt;intptr_t\u0026gt;(obj) \u0026gt;\u0026gt; 3; value = addrBits ^ (addrBits \u0026gt;\u0026gt; 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing  } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop\u0026lt;intptr_t\u0026gt;(obj); } else { // Marsaglia\u0026#39;s xor-shift scheme with thread-specific state  // This is probably the best overall implementation -- we\u0026#39;ll  // likely make this the default in future releases.  unsigned t = Self-\u0026gt;_hashStateX; t ^= (t \u0026lt;\u0026lt; 11); Self-\u0026gt;_hashStateX = Self-\u0026gt;_hashStateY; Self-\u0026gt;_hashStateY = Self-\u0026gt;_hashStateZ; Self-\u0026gt;_hashStateZ = Self-\u0026gt;_hashStateW; unsigned v = Self-\u0026gt;_hashStateW; v = (v ^ (v \u0026gt;\u0026gt; 19)) ^ (t ^ (t \u0026gt;\u0026gt; 8)); Self-\u0026gt;_hashStateW = v; value = v; } value \u0026amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, \u0026#34;invariant\u0026#34;); return value; }   Links   Object(docs.oracle.com/javase/8)   Why MULT 31 (hash function for string)?   Lombok  @EqualsAndHashCode Issue 625: use (even) better primes for hashcodes    참고문헌  이펙티브 자바 (2판) / 조슈아 블로크 저 / 이병준 역 / 인사이트(insight) / 초판 2쇄 2015년 07월 21일 이펙티브 자바 (3판) / 조슈아 블로크 저/개앞맵시 역 / 인사이트(insight) / 초판 2쇄 2018년 11월 21일 Introduction to Algorithms (3판) / 토머스 코멘, 찰스 레이서손, 로날드 리베스트, 클리포드 스타인 공저 / 문병로, 심규석, 이충세 공역 / 한빛아카데미 / 초판 3쇄 2016년 07월 29일  주석   이펙티브 자바 2판. 규칙 9. 64쪽.\u0026#160;\u0026#x21a9;\u0026#xfe0e;  이펙티브 자바 3판. 아이템 11. 68쪽.\u0026#160;\u0026#x21a9;\u0026#xfe0e;  이펙티브 자바 2판. 규칙 9. 65쪽.\u0026#160;\u0026#x21a9;\u0026#xfe0e;  이펙티브 자바 3판. 아이템 11. 70쪽.\u0026#160;\u0026#x21a9;\u0026#xfe0e;  Introduction to Algorithms 제목이 너무 길어서 CLRS라고 부르곤 한다. C, L, R, S 는 저자들의 이니셜이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;  Introduction to Algorithms. 11. 264쪽.\u0026#160;\u0026#x21a9;\u0026#xfe0e;    ","permalink":"https://youngeun-in.github.io/equals-and-hashcode/","tags":["equals","hashcode"],"title":"equals와 hashCode"},{"categories":["java"],"contents":"데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다. 결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다. 이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public enum PayType { ACCOUNT_TRANSFER(\u0026#34;계좌이체\u0026#34;), REMITTANCE(\u0026#34;무통장입금\u0026#34;), ON_SITE_PAYMENT(\u0026#34;현장결제\u0026#34;), TOSS(\u0026#34;토스\u0026#34;), PAYCO(\u0026#34;페이코\u0026#34;), CARD(\u0026#34;신용카드\u0026#34;), KAKAO_PAY(\u0026#34;카카오페이\u0026#34;), BAEMIN_PAY(\u0026#34;배민페이\u0026#34;), POINT(\u0026#34;포인트\u0026#34;), COUPON(\u0026#34;쿠폰\u0026#34;); private final String title; PayType(String title) { this.title = title; } public String getTitle() { return title; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import lombok.Getter; import java.util.Arrays; import java.util.Collections; import java.util.List; @Getter public enum PayGroup { CASH(\u0026#34;현금\u0026#34;, Arrays.asList(PayType.ACCOUNT_TRANSFER, PayType.REMITTANCE, PayType.ON_SITE_PAYMENT, PayType.TOSS)), CARD(\u0026#34;카드\u0026#34;, Arrays.asList(PayType.PAYCO, PayType.CARD, PayType.KAKAO_PAY, PayType.BAEMIN_PAY)), ETC(\u0026#34;기타\u0026#34;, Arrays.asList(PayType.POINT, PayType.COUPON)), EMPTY(\u0026#34;없음\u0026#34;, Collections.EMPTY_LIST); private final String title; private final List\u0026lt;PayType\u0026gt; payList; PayGroup(String title, List\u0026lt;PayType\u0026gt; payList) { this.title = title; this.payList = payList; } public static PayGroup findByPayType(PayType payType){ return Arrays.stream(PayGroup.values()) .filter(payGroup -\u0026gt; payGroup.hasPayType(payType)) .findAny() .orElse(EMPTY); } private boolean hasPayType(PayType payType){ return payList.stream() .anyMatch(pay -\u0026gt; pay == payType); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PayGroupTest { @Test public void PayGroup에게_직접_결제종류_물어보기_PayType () { PayType payType = selectPayType(); PayGroup payGroup = PayGroup.findByPayType(payType); assertEquals(payGroup.name(), \u0026#34;CARD\u0026#34;); assertEquals(payGroup.getTitle(), \u0026#34;카드\u0026#34;); } private PayType selectPayType(){ return PayType.BAEMIN_PAY; } }   DB 혹은 API에서 PayType으로 데이터를 받아, 타입 안전성까지 확보하여 PayGroup 관련된 처리를 진행할 수 있게 되었다. 참고 https://github.com/jojoldu/blog-code/tree/master/enum-settler ","permalink":"https://youngeun-in.github.io/enum-usage-2/","tags":["enum"],"title":"Enum 사용 (활용)"},{"categories":["java"],"contents":"상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 \u0026ldquo;CALC_A\u0026quot;일 경우엔 값 그대로, \u0026ldquo;CALC_B\u0026quot;일 경우엔 10 한 값을, \u0026ldquo;CALC_C\u0026quot;일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 \u0026ldquo;DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.\u0026ldquo;는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import java.util.function.Function; public enum CalculatorType { CALC_A(value -\u0026gt; value), CALC_B(value -\u0026gt; value * 10), CALC_C(value -\u0026gt; value * 30), CALC_ETC(value -\u0026gt; 0L); private Function\u0026lt;Long, Long\u0026gt; expression; CalculatorType(Function\u0026lt;Long, Long\u0026gt; expression) { this.expression = expression; } public long calculate(long value) { return expression.apply(value); } }   1 2 3 4 5 6 7 8 9 10  import javax.persistence.Column; import javax.persistence.EnumType; import javax.persistence.Enumerated; public class Entity { @Column //@Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다.  @Enumerated(EnumType.STRING) private CalculatorType calculatorType; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.testng.annotations.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTypeTest { private CalculatorType selectType() { return CalculatorType.CALC_B; } @Test public void 코드에_따라_서로다른_계산하기_Enum() { CalculatorType code = selectType(); long originValue = 10000L; long result = code.calculate(originValue); assertEquals(result, 100000L); } }   값(상태)과 메소드(행위)가 어떤 관계가 있는지에 대해 더이상 다른 곳을 찾을 필요가 없게 되었다. 코드내에 전부 표현되어 있고, Enum 상수에게 직접 물어보면 되기 때문이다. ","permalink":"https://youngeun-in.github.io/enum-usage-1/","tags":["enum"],"title":"Enum 사용 (개념)"},{"categories":["ML"],"contents":"Neural Network 신경망(Neural Net)은 퍼셉트론을 쌓아올려 알아서 파라미터를 결정할 수 있도록 만든 장치입니다. 신경망의 구조는 아래 그림과 같습니다. 이미지 출처 : kdnuggets.com 아래는 2개의 입력값 $(x_1, x_2)$을 받는 퍼셉트론을 수식으로 나타낸 것입니다. $(w_1, w_2)$는 각 입력값에 곱해지는 가중치이며 $b$ 는 편향(bias)입니다. $$ y = \\begin{cases} 0 \\qquad (b + w_1x_1 + w_2x_2 \\leq 0) \\ 1 \\qquad (b + w_1x_1 + w_2x_2 \u0026gt; 0) \\end{cases} $$ 위 식을 퍼셉트론의 결과를 나타내는 함수 $h(x)$를 사용하면 아래와 같이 나타낼 수 있습니다. $$ y = h(b + w_1x_1 + w_2x_2) \\ h(x) = \\begin{cases} 0 \\qquad (x \\leq 0) \\ 1 \\qquad (x \u0026gt; 0) \\end{cases} $$ 여기서 $h(x)$는 **활성화 함수(Activation function)**라고 합니다. 활성화 함수는 가중치가 곱해진 신호의 총합이 활성화를 일으키는지, 즉 임곗값을 넘는지를 판단하게 됩니다. 임계값을 넘으면 $1$ 을, 그보다 작으면 $0$ 을 나타내게 되지요. 아래는 이 과정을 나타낸 것입니다. 이미지 출처 : i2tutorials.com Activation Function 그렇다면 활성화 함수는 어떤 것들이 있고 왜 이렇게 생기게 되었는 지에 대해서 조금 더 자세히 알아보겠습니다. Step Function 활성화 함수는 신경망의 행동을 결정하는 중요한 역할을 합니다. 가장 간단한 형태의 활성화 함수는 **계단 함수(Step function)**라고 합니다. 계단 함수는 위에서 살펴본 $h(x)$ 와 같이 행동합니다. 입력값의 합이 임계값을 넘으면 $0$ 을, 넘지 못하면 $1$ 을 출력하게 됩니다. 이에 따른 계단 함수의 그래프는 다음과 같이 생겼습니다. 이미지 출처 : wikipedia - Heaviside step function 계단 함수는 활성화 함수의 조건을 가장 잘 만족하는 함수이고 직관적으로도 이해하기 쉽습니다. 하지만 두 가지 단점 때문에 실제 신경망에 사용되지는 않습니다. 첫 번째 단점은 **불연속(Discontinuous)**입니다. 그래프를 보면 알 수 있듯 임계값 지점에서 불연속점을 갖게 되는데 이 점에서 미분이 불가능하기 때문에 학습이 필요한 신경망에 사용할 수 없습니다. 두 번째 단점은 다른 지점에서 미분값이 $0$이 된다는 점입니다. 추후 역전파 과정에서 미분값을 통해 학습을 하게 되는데 이 값이 0이 되어버리면 제대로 된 학습이 안되지요. 이런 문제점을 해결하기 위해서 등장한 것이 **시그모이드 함수(Sigmoid)**입니다. Sigmoid Function 시그모이드 함수는 기본적으로 $S$ 모양을 그리는 곡선 함수를 통칭하여 부르는 말입니다. 이 중 대표적인 함수는 로지스틱(Logistic) 함수와 하이퍼탄젠트(Hyper tangent, $\\tanh$) 함수가 있습니다. 두 함수의 수식과 그래프를 보며 시그모이드 함수와 계단 함수가 다른 점이 무엇인지 알아보도록 하겠습니다. 로지스틱 함수(Logistic Function) $$ \\text{Logistic} : \\frac{1}{1+e^{-x}} $$ 이미지 출처 : wikipedia - Logistic function 하이퍼탄젠트 함수(Hypertangent Function) $$ \\text{Hypertangent} : \\frac{e^x-e^{-x}}{e^x+e^{-x}} = \\frac{e^{2x}-1}{e^{2x}+1} $$ 이미지 출처 : mathworld.wolfram.com 두 함수는 모두 연속함수입니다. 계단 함수의 치명적인 단점이었던 불연속을 해결했지요. 계단 함수와 시그모이드 함수의 중요한 공통점은 **비선형 함수(Non-linear)**라는 점입니다. 활성화 함수는 비선형 함수를 사용해야 합니다. 활성화 함수가 선형 함수이면 안되는 이유는 무엇일까요? 선형인 활성화 함수 $l(x) = ax + b$ 가 있다고 해보겠습니다. 이 함수를 사용하여 3개의 층을 쌓는다면 최종적인 활성화 함수는 $l(l(l(x))) = l^3(x) = a(a(ax+b)+b)+b = a^3x+a^2b+ab+b$가 됩니다. $a^3 = c, d = a^2b+ab+b$라고 하면 $l^3(x) = cx+d$로 여전히 같은 형태의 함수를 사용하게 됩니다. 층을 아무리 깊게 쌓아도 여러 층을 쌓는 이점을 살리지 못하게 되지요. 여러 층을 쌓을 때의 장점을 살리기 위해 비선형 함수를 사용하게 되는 것이지요. ReLU Function 시그모이드 함수는 불연속이라는 계단 함수의 한 가지 단점을 해결했습니다. 하지만 나머지 단점 하나는 해결하지 못했습니다. 시그모이드도 여전히 대부분의 점에서 기울기 값이 0이 되지요. 이 때문에 **기울기 소실(Gradient vanishing)**이라는 문제가 발생합니다. 기울기 소실은 시그모이드 함수를 활성화 함수로 사용하여 층을 깊게 쌓았을 때 학습이 잘 되지 않는 현상입니다. 이런 현상이 왜 발생하는지 알아보겠습니다. 로지스틱 함수 $L(x)$를 미분한 함수 $L^\\prime(x)$ 의 수식은 다음과 같습니다. $$ L^\\prime(x) = \\bigg(\\frac{1}{1+e^{-x}}\\bigg)^\\prime = \\frac{e^x}{(1+e^{-x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 그래프에서 볼 수 있듯 최댓값이 $0.25$ 밖에 되지 않고 $x\u0026lt;-5, x\u0026gt;5$ 범위에서는 거의 $0$ 에 가깝습니다. 역전파(Back propagation) 과정에서는 미분값을 사용하여 학습을 하게 됩니다. 따라서 이 값이 0에 가까워 지면 정보가 유실되면서 학습이 잘 안되게 됩니다. 특히 층을 깊게 쌓을 경우에는 정보가 모두 유실되는 사태가 발생하게 되지요. 그렇다면 하이퍼탄젠트 함수는 어떻게 될까요? 하이퍼탄젠트 함수 $\\tanh$를 미분한 함수의 수식은 다음과 같습니다. $$ \\tanh^\\prime(x) = \\bigg(\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\bigg)^\\prime = \\frac{4e^{2x}}{(1+e^{2x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 하이퍼탄젠트 함수를 미분한 함수의 최댓값은 $1$ 입니다. 최댓값이 $0.25$ 밖에 안되었던 로지스틱 함수 보다는 정보를 잘 전달하게 되지요. 하지만 여전히 $x$ 가 0에서 멀어질수록 원래 함수의 미분값은 0에 가까워집니다. 그래서 하이퍼탄젠트 함수를 활성화 함수로 하더라도 퍼셉트론을 여러 층으로 쌓는다면 학습이 제대로 안되게 되지요. 이렇게 시그모이드 함수를 활성화 함수로 사용할 때 역전파시 학습이 제대로 진행되지 않는 현상을 기울기 소실이라고 합니다. 기울기 소실 문제를 극복하기 위해서 등장한 함수가 바로 ReLU(Rectified Linear Unit)함수입니다. ReLU함수는 입력값이 0보다 작을 경우에는 0을 반환하고, 0보다 클 경우에는 입력값을 그대로 반환합니다. 아래는 ReLU함수를 수식으로 나타낸 것입니다. $$ h(x) = \\begin{cases} 0 \\qquad (x \\leq 0) \\ x \\qquad (x \u0026gt; 0) \\end{cases} $$ 아래는 ReLU함수의 그래프를 나타낸 것입니다. 이미지 출처 : medium.com ReLU함수는 $x$ 가 $0$ 보다 클 때, 미분값이 항상 $1$ 입니다. 그래서 층이 아무리 깊어져도 손실없이 정보를 전달할 수 있습니다. 미분값이 항상 $0$과 $1$ 이기 때문에 연산이 빠르다는 점도 ReLU함수의 장점입니다. 덕분에 ReLU함수는 은닉층에서 가장 많이 사용되는 활성화 함수가 되었습니다. 물론 ReLU함수에게도 문제가 있습니다. 0이하의 값이 그대로 보존되지 않고 버려진다는 것이지요. 이를 보완하기 위해 Leaky ReLU함수가 고안되어 사용되고 있습니다. Leaky ReLU 함수 $h_\\text{Leaky}(x)$의 수식은 다음과 같습니다. $$ h_\\text{Leaky}(x) = \\begin{cases} ax \\qquad (x \\leq 0) \\ x \\qquad (x \u0026gt; 0) \\end{cases} $$ 일반적으로는 $a=0.01$을 사용하며 그래프는 다음과 같습니다. 이미지 출처 : medium.com Softmax 은닉층(Hidden Layer)의 활성화 함수로는 일반적으로 ReLU함수 혹은 Leaky ReLU와 같은 ReLU함수를 변형한 함수가 주로 사용됩니다. 하지만 출력층의 활성화 함수는 우리가 하고자 하는 작업에 맞게 조정해주어야 합니다. 일반적으로 회귀( Regression), 즉 연속형 변수에 대한 예측값을 출력하는 경우에는 출력층의 활성화 함수로 항등함수 $h_\\text{reg}(x) = x$ 를 사용합니다. 이진 분류의 경우에는 입력값을 받아 $0$ 혹은 $1$ 의 값을 출력하는 것이므로 주로 로지스틱 함수를 많이 사용합니다. 그렇다면 인스턴스를 다중 레이블로 분류하는 경우에는 어떤 활성화 함수를 사용하는 것이 좋을까요? 이런 질문에 대한 답으로 나온 것이 바로 소프트맥스(Softmax) 함수입니다. 소프트맥스 함수는 이진 분류에서 사용하는 로지스틱 함수를 다중 분류에서 사용할 수 있도록 일반화한 함수입니다. 소프트맥스의 함수는 다음과 같습니다. $$ y_k = \\frac{\\exp(a_k)}{\\sum^n_{i=1}\\exp(a_i)} $$ 소프트맥스도 함수도 사용할 때 주의해야 할 점이 있습니다. 소프트맥스 함수가 지수함수이기 때문에 $a$ 값이 커지게 되면 $\\exp(a)$ 값이 매우 커지게 됩니다. __int32가 최대로 나타낼 수 있는 숫자는 $2,147,483,647$ 인데 $a = 22$ 만 되더라도 표현할 수 있는 값 이상이 되어 오버플로(Overflow)현상이 발생합니다. 또한 부동소수점 표기 특성상, 작은 숫자를 큰 값으로 나누면 수치가 불안정해지는 문제 역시 발생하게 됩니다. 이런 문제를 해결하기 위해서 실제로 소프트맥스 함수를 사용하기 위해서는 상수 $C$를 곱해주어 스케일을 조정해주는 과정이 필요합니다. 실제로 구현되어 있는 소프트맥스 함수의 수식은 아래와 같습니다. $$ \\begin{aligned} y_k \u0026amp;= \\frac{\\exp(a_k)}{\\sum^n_{i=1}\\exp(a_i)} = \\frac{C\\exp(a_k)}{C\\sum^n_{i=1}\\exp(a_i)} \\ \u0026amp;= \\frac{\\exp(a_k +\\log C)}{\\sum^n_{i=1}\\exp(a_i + \\log C)} \\ \u0026amp;= \\frac{\\exp(a_k +C^\\prime)}{\\sum^n_{i=1}\\exp(a_i + C^\\prime)} \\end{aligned} $$ 위 식에서 $C^\\prime = \\log C$로, $C^\\prime$에는 0보다 작은 값이면 어떤 값을 대입하든 상관 없지만 오버플로를 막기 위해서 일반적으로 $a_i {i=1, \\cdots ,n}$ 중 가장 큰 값에 $-1$ 을 곱해준 값을 사용합니다. 예를 들어, $a_i = [1000, 1050, 1100]$이면 $C^\\prime = -1100$ 이 됩니다. 소프트맥스 함수의 출력값은 항상 $[0,1]$ 범위 내에 있으며 모든 출력값을 더한 값이 1이 된다는, 즉 $\\sum^n_{i=1}y_i = 1$ 이라는 특징이 있습니다. 이런 성질 덕분에 소프트맥스의 출력값을 확률(Probability)로도 해석할 수 있습니다. 다중 레이블에 대한 확률이 필요한 경우 소프트맥스 함수를 사용합니다. ","permalink":"https://youngeun-in.github.io/%EC%8B%A0%EA%B2%BD%EB%A7%9D%EA%B3%BC-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98/","tags":["neural-net","sigmoid","relu"],"title":"신경망(Neural Network)과 활성화 함수(Activation Function)"},{"categories":["spring"],"contents":"Spring mocking 없이 테스트하려면? 아래 코드를 mocking 없이 테스트하려면 어떻게 해야 할까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import java.io.IOException; public class RepositoryRank { public int getPoint(String repositoryName) throws IOException { GitHub github = GitHub.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u0026gt; 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public static void main(String[] args) throws IOException { RepositoryRank repositoryRank = new RepositoryRank(); int point = repositoryRank.getPoint(\u0026#34;whiteship/live-study\u0026#34;); System.out.println(point); } }   Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입하면 된다. 설명과 코드는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import org.kohsuke.github.GitHubBuilder; import java.io.IOException; public class RepositoryRank { //인터페이스 선언  interface GitHubService { GitHub connect() throws IOException; } //인터페이스를 구현한 클래스 생성하고 모킹하고자 하는 메소드를 오버라이드한다.  static class DefaultGitHubService implements GitHubService { @Override public GitHub connect() throws IOException { return new GitHubBuilder().build(); } } private final GitHubService gitHubService; //서비스를 주입받는다.  public RepositoryRank(GitHubService gitHubService) { this.gitHubService = gitHubService; } public int getPoint(String repositoryName) throws IOException { GitHub github = gitHubService.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u0026gt; 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public void main(String[] args) throws IOException { GitHubService gitHubService = new DefaultGitHubService(); //Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입  RepositoryRank repositoryRank = new RepositoryRank(gitHubService); int point = repositoryRank.getPoint(\u0026#34;whiteship/live-study\u0026#34;); System.out.println(point); } }   참고 백기선님의 유튜브를 참고했다. https://youtu.be/bJfbPWEMj_c ","permalink":"https://youngeun-in.github.io/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법"},{"categories":null,"contents":"","permalink":"https://youngeun-in.github.io/search/","tags":null,"title":"Search"}]