[{"categories":["spring"],"contents":"📕 AOP AOP는 OOP를 더욱 OOP답게 프로그래밍 할 수 있게 도와주는 것으로 애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법이다. 실제로 Spring doc document 에서는 아래와 같이 말하고 있다. 1 2 3 4 5  Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by providing another way of thinking about program structure AOP는 프로그램 구조에 대한 다른 생각의 방향을 제공해주면서 OOP를 보완하고 있다.   예를 들면 어떠한 클래스를 대상으로 핵심 기능과 부가적인 기능의 관점으로 공통 사용 부가 기능들을 외부의 독립된 클래스로 분리하고 이를 모듈화하여 재사용할 수 있게끔 하는 프로그래밍 기법이다. 📘 AOP 용어    용어 설명     Aspect(Advisor) ✔ 특정 한 가지 기능에 대해 흩어진 관심사를 모듈화하여 묶은 클래스 - PointCut + Advice를 묶은 메서드를 정의 및 관리한다.   Target ✔ 비즈니스(핵심) 로직을 구현하는 AOP의 대상 \u0026lsquo;클래스\u0026rsquo;   Advice ✔ AOP 메서드 : 부가 기능을 적용시키는 메서드(부가 기능 로직 메서드) 적용 시점도 지정할 수 있다. - before : 비즈니스 메소드 실행 전에 동작 - after : 비즈니스 메소드 실행 후에 동작 - after-returning : 비즈니스 메소드 실행 중 리턴 되는 순간 - after-throwing : 비즈니스 메소드 실행 중 에러 발생 순간 - around\t: 비즈니스 메소드 실행 전/후에 동작   JoinPoint ✔ AOP가 적용될 수 있는 메소드, 필드, 객체, 생성자 등의 요소 - 타겟 클래스의 요소들을 의미하며 PointCut의 후보 - Spring AOP에서는 메서드만 지정 가능   PointCut ✔ AOP 적용 가능 요소들 중에서 \u0026lsquo;실제 적용될 요소들\u0026rsquo;을 의미한다. - JoinPoint에서 실제 Advice가 적용될 지점 - Spring AOP 에서는 advice가 적용될 메서드를 의미   Weaving ✔ PointCut이 호출될 때 Advice가 호출되는 과정을 의미한다. 즉, PointCut에 Advice 메서드가 삽입되는 과정을 의미한다. - 컴파일 전에는 핵심 로직과 인프라 로직이 분리되어있지만 - 컴파일타임에 바이트 코드를 넣는다던지 런타임에 프록시를 만들던지 - 관심사를 분리한 코드를 비즈니스 코드와 병합하는 작업을 의미한다. Weaving 처리 방식 (AOP 구현 방법) - 컴파일 타임 위빙 : a.java -\u0026gt; a.clss 컴파일 될 때 - 로딩 타임 위빙 : 클래스파일을 클래스 로더가 메모리에 로드할 때 - 런타임/프록시 위빙 : 타겟 클래스에 부가 기능을 추가하도록 Proxy 객체를 만들어(감싸서) 실행 - 스프링 AOP는 런타임 위빙만을 지원한다.(IOC/DI를 이용한 방법)   proxy ✔ Target 객체에 Advice를 적용시키는 래퍼 클래스     애플리케이션은 자연스럽게 여러 메서드(Join Point)를 호출한다. 이때 특정 PointCut으로 지정한 메소드가 호출되는 순간 Aspect 의 Advice 메소드가 호출된다. Advice 메소드의 동작 시점은 5가지로 정할 수 있다. 애스팩트 설정에 따라 위빙 처리되어 프록시 객체가 생성된다.(동적 프록시 생성) 프록시 객체를 통해 부가기능이 포함된 비즈니스 로직을 수행한다.  📖 AOP 구현 1  implementation \u0026#39;org.springframework.boot:spring-boot-starter-aop\u0026#39;   1 2 3 4 5  // @EnableAspectJAutoProxy 생략 가능 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } }   1 2 3 4 5 6  @Service public class AuthServiceImpl { public void businessLogicMethod(){ System.out.println(\u0026#34;businessLogicMethod process!\u0026#34;); } }   📄 일반적인 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Aspect @Configuration public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\u0026#34;execution(* com.demo.study.service.AuthServiceImpl.*(..))\u0026#34;) public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\u0026#34;request spent {} ms\u0026#34;, stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\u0026#34;execution(* com.demo.study.service.AuthServiceImpl.*(..))\u0026#34;) public void After() throws Throwable { log.info(\u0026#34;After 어드바이스\u0026#34;); } }   📄 어노테이션으로 구현 1 2 3 4  @Target(ElementType.METHOD) @Retention(RetentionPolicy.CLASS) public @interface PerformanceCheck { }   1 2 3 4 5 6 7  @Service public class AuthServiceImpl { @PerformanceCheck public void businessLogicMethod(){ System.out.println(\u0026#34;businessLogicMethod process!\u0026#34;); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\u0026#34;@annotation(com.demo.study.annotation.PerformanceCheck)\u0026#34;) public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\u0026#34;request spent {} ms\u0026#34;, stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\u0026#34;@annotation(com.demo.study.annotation.PerformanceCheck)\u0026#34;) public void After() throws Throwable { log.info(\u0026#34;After 어드바이스\u0026#34;); } }    어노테이션과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다.  📄 빈으로 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\u0026#34;bean(com.demo.study.service.AuthServiceImpl)\u0026#34;) public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\u0026#34;request spent {} ms\u0026#34;, stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\u0026#34;bean(com.demo.study.service.AuthServiceImpl)\u0026#34;) public void After() throws Throwable { log.info(\u0026#34;After 어드바이스\u0026#34;); } }    빈과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다.  📖 AOP PointCut 설정 1  execution(* com.springbook.biz..*Impl.get*(..))\u0026#34;    * : 리턴값 com.springbook.biz.. : 패키지 *Impl: 클래스 이름 get* : 메서드 이름 (..) : 매개변수 중간마다의 . : 구분점  📄 execution 포인트 컷 리턴    표현식 설명     * 모든 리턴타입 허용   void 리턴타입이 void인 메서드 선택   !void 리턴타입이 void가 아닌 메서드 선택    📄 execution 포인트 컷 패키지    표현식 설명     com.springbook.biz 정학하게 해당 패키지만 선택   com.springbook.biz.. 해당 패키지 및 모든 하위 패키지 선택   com.springbook..impl ..앞 패키지로 시작하면서 마지막 패키지 이름이 ..뒤로 끝나는 패키지 선택    📄 execution 포인트 컷 클래스    표현식 설명     BoardServiceImpl 정학하게 해당 클래스만 선택   *Impl 클래스 이름이 *뒷 글자로 끝나는 클래스만 선택   BoardService+ 해당 클래스는 물론 파생된 모든 자식 클래스도 선택 가능   variable+ 해당 인터페이스를 구현한 모든 클래스 선택 가능    📄 execution execution 포인트 컷 메서드    표현식 설명     *(..) 가장 기본 설정으로 모든 메서드 선택   get*(..) 메서드 이름이 get으로 시작하는 모든 메서드 선택   매서드이름(..) 특정 메서드 이름을 가진 메서드 선택    📄 execution 포인트 컷 매개변수    표현식 설명     (..) 가장 기본 설정으로서 매개변수 타입의 제한이 없음을 의미   (*) 반드시 1개의 매개변수를 가지는 메서드만 허용한다는 의미   (com.spring.user.User) 해당 패키지의 클래스를 가지는 메서드만 허용한다는 의미   (!com.spring.user.User) 해당 패키지의 클래스를 가지지 않는 메서드만 허용한다는 의미   (Integer, ..) 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용   (Integer, *) 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용    📗 스프링 AOP 스프링 AOP 는 런타임 위빙을 지원하기에 Proxy 기반의 AOP 구현 기능을 지원한다. 이러한 Proxy 기반의 AOP는 스프링 빈에만 적용가능하기에 빈으로 등록된 대상만 AOP 대상이 된다. 또한, 스프링 AOP 특징상 메서드만을 지원할 수 있다. 프록시 패턴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Primary @Service public class ProxySimpleEventService implements EventService{ private final EventService simpleEventService; ProxySimpleEventService(EventService simpleEventService) { this.simpleEventService = simpleEventService; } @Override public void createEvent() { long begin = System.currentTimeMillis(); simpleEventService.createEvent(); System.out.println(\u0026#34;createEvent 실행시간: \u0026#34;+(System.currentTimeMillis()-begin)); } @Override public void publishEvent() { long begin = System.currentTimeMillis(); simpleEventService.publishEvent(); System.out.println(\u0026#34;createEvent 실행시간: \u0026#34;+(System.currentTimeMillis()-begin)); } @Override public void deleteEvent() { simpleEventService.deleteEvent(); } }   프록시 패턴은 AOP에서 기존 코드의 변경 없이 접근 제어 또는 부가 기능 추가하기 위해 사용된다. 그러나 일반적인 방법으로 프록시 패턴을 구현하면 아래와 같은 문제점이 발생한다. 문제점  매번 Proxy 클래스를 작성해야 한다. 하나의 클래스가 아닌 여러 클래스를 대상으로 적용하기 힘들다. 객체 관계가 복잡해지고 관리하기 어렵다.  이러한 문제점을 해결하기 위해 등장한 것이 바로 Spring AOP와 Dynamic Proxy다. 스프링 IoC 컨테이너가 제공하는 기반 시설과 Dynamic Proxy를 사용하여 여러 복잡한 문제 해결했다.  Dynamic Proxy : 동적으로 프록시 객체 생성하는 방법 JDK Dynamic Proxy : 자바가 제공하는 인터페이스 기반 프록시 생성 라이브러리  CGlib : 자바가 제공하는 클래스 기반 프록시 생성 라이브러리   Spring IoC : 기존 빈을 대체하는 \u0026lsquo;동적 프록시 빈\u0026rsquo;을 만들어 등록한다.  클라이언트 코드 변경이 없다. AbstractAutoProxyCreator implements BeanPostProcessor를 기반으로 만든다. 즉 빈이 생성된 후, 프록시를 생성하는 로직을 수행한다.    이렇듯 런타임시에 동적으로 프록시 빈을 생성하고 AOP를 적용시키는 것을 런타임 위빙이라 부른다. 🔍 런타임 위빙(프록시 위빙) 런타임 위빙은 런타임에 동적으로 Proxy를 생성하여 실제 Target 객체의 변형없이 AOP를 수행하는 것을 의미한다. 스프링을 기준으로 말하자면 메서드만이 JoinPoint가 될 수 있기에 Method 호출 시에 위빙이 이루어 지는 방식이다. 런타임 위빙 또한, 일반적인 Proxy 패턴을 개선한 Dynamic Proxy를 사용하고 있지만 아래와 같은 문제가 있다.  포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다. 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.(프록시이기에)  AOP 프록시 객체 1  org.woowacourse.aoppractice.service.AuthServiceImpl$$EnhancerBySpringCGLIB$$dbdb402d   위 코드를 보면, Target 클래스 자체를 프록시로 감싸는 것을 알 수 있다. 프록시 위빙이 가능한 이유는 상속을 이용한 방식이기에 다형성을 적용시킬 수 있다. 즉, 위 그림에서 AuthController가 AuthService의 프록시 클래스인 AuthService$$블라블라를 참조할 수 있던 것이다. 그런데 한가지 생각해볼 점이 있다. DynamicProxy는 상속/구현을 적용하니 아래와 같은 요소들은 가능할까? 🤔  final 클래스 final 메서드 private 메서드  당연하게도, 자바 문법적으로 상속 및 오버라이딩을 지원하지 못하므로 적용이 되지 않는다. 이와 비슷하게 Spring에서 지원해주는 @Trancsactional 어노테이션이 있는데 @Trancsactional 어노테이션 또한 AOP기반이기에 private 메서드를 붙이면 작동을 하지 않는다. @Trancsactional  로직 시작시 트랜잭션을 열어줌 로직 끝날시 commit하고 트랜잭션을 닫아줌 트랜잭션에 관련된 인프라 로직을 지원하기에 우리는 비즈니스 로직에 집중할 수 있게해준다.   참고 백기선-스프링 프레임워크 핵심 기술 스프링 퀵 스타트 테코톡-스프링 AOP 장인 개발자를 꿈꾸는 : 기록하는 공간 Carrey\u0026rsquo;s 기술블로그 진짜 개발자 기억보단 기록을 리다양의 개발 세상 Carrey\u0026rsquo;s 기술블로그-AspectJ 나중에 참고하면 좋음 논리적 코딩 ","permalink":"https://youngeun-in.github.io/aop/","tags":["spring-aop","dynamic-proxy"],"title":"AOP"},{"categories":["java"],"contents":"서블릿이 호출되는 과정 서블릿 컨테이너는 서블릿을 담아 관리한다. 서블릿은 싱글톤으로 관리된다.  Servlet Request / Servlet Response 객체 생성 설정 파일을 참고하여 매핑할 Servlet을 확인  1 2 3 4 5 6 7 8 9  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.jsp.web.MyServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;   해당 서블릿 인스턴스 존재를 유무를 확인하여 없으면 생성(init()) Servlet Container에 스레드를 생성하고, res req를 인자로 service 실행  참고 https://youtu.be/calGCwG_B4Y ","permalink":"https://youngeun-in.github.io/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/","tags":["servlet-container"],"title":"Servlet 동작 방식"},{"categories":["java"],"contents":"Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다. 위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다.  캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다. - 나무위키  Array 는 연속적인 memory block 으로, array 에 처음 접근할 때 전체 array 가 cache 에 로드된다. 첫 액세스 이후로는 공간 지역성이 생기는 것이다. 그러나 java 는 jvm 이 알아서 메모리를 관리 하기 때문에 array 사용시 cache locality 가 적용되는지 여부는 jvm 이 메모리 관리하는 방법을 공부해서 좀 더 알아봐야 할 것 같다. 지금 자세한 설명을 할 지식은 없지만 아마 java 에서는 ‘해당사항 없음’ 이라는 결론이 날 것 같다. ArrayList Java 의 ArrayList 는 AbstractList 를 상속받고 List 인터페이스를 구현한 클래스이다. Array 와 비슷하지만 size 가 dynamic 하게 조절된다. ArrayList.java 코드를 열어보면 default size 는 10 인 것을 알 수 있다. 1  private static final int DEFAULT_CAPACITY = 10;   ArrayList 에서 새로운 element 를 추가하는 메소드는 add() 로, 두 가지 방식의 오버로딩 된 메소드가 정의되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return \u0026lt;tt\u0026gt;true\u0026lt;/tt\u0026gt; (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!!  System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; }   아래에 있는 add() 메소드는 특정 index 에 element 를 삽입하는 메소드로, 어떤 작업을 한 다음에 기존 array 를 copy 한 더 큰 size 를 가진 새로운 array 를 만들어 낸다. 결국 copy 라는 작업이 필요한 것이다. 그럼 매개변수 하나만 받는 위에있는 add() 는 어떻게 동작하는 걸까? 방금 언급한 어떤 작업 에서 ensureCapacityInternal() 메소드가 사이즈 조절을 담당한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); }   ensureCapacityInternal() 메소드로 가보면, 사이즈 조절을 위해 ensureExplicitCapacity() 를 또 호출한다. ensureExplicitCapacity() 메소드에서는 if (minCapacity - elementData.length \u0026gt; 0) 이 if 문에 의해 현재 data 를 담고 있는 array 의 length 가 full 이면 grow() 라는 함수를 호출해서 size 를 늘린다. grow() 함수로 가보면 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  elementData = Arrays.copyOf(elementData, newCapacity); }   int newCapacity = oldCapacity + (oldCapacity \u0026raquo; 1); 여기가 포인트다. 비트연산으로 기존 size 의 1/2 만큼 새로운 capacity 를 할당하도록 한다. oldCapacity 값이 10 (default) 이었다면, 10 \u0026raquo; 1 의 경우 10 의 2진수인 1010(2) 을 1-bit right shifting 한 값인 0101(2) , 즉 10진수 5 만큼 size 를 키우는 것이다. 이렇게 size 키워서 결국 한다는 게 copy 다. 결국 java 에서 제공하는 ArrayList 도 별다른 신박한 방법으로 관리하는 array 가 아니라 그냥 array 인 것이다. 즉, size 가 고정되지 않게 하려면 비용이 많이 든다는 단점이 있는 것은 확실하다. ","permalink":"https://youngeun-in.github.io/array-arraylist/","tags":["array","array-list"],"title":"Array \u0026 ArrayList"},{"categories":["java"],"contents":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. Local Class 중괄호 내에, 특히 메소드 내에 정의 Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","permalink":"https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/","tags":["nested-class"],"title":"자바의 Nested Class"},{"categories":["java"],"contents":"equals 메소드 Object 클래스에 정의된 equals 메소드는 다음과 같다. 1 2 3  public boolean equals(Object obj) { return (this == obj); }   단순히 Object의 ==로 비교하는 것을 확인할 수 있다. 두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다. 1 2 3 4 5 6 7  @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AttachFile that = (AttachFile) o; return Objects.equals(id, that.id) \u0026amp;\u0026amp; Objects.equals(fileName, that.fileName) \u0026amp;\u0026amp; Objects.equals(minutes, that.minutes); }   hashCode 메소드 Object 클래스에 정의된 hashCode 메소드는 인스턴스가 다르면 구성 내용에 상관없이 전혀 다른 해시 값을 반환하도로 정의되어 있다. Object 클래스에 정의된 hashCode 메소드는 다음과 같다. 1 2  @HotSpotIntrinsicCandidate public native int hashCode();   다음은 [hotspot의 jvm.cpp 파일에서 발췌][jvm-cpp-583]한 것이다. 버전은 JDK10 이지만, JDK8과 차이점은 없다. 1 2 3 4 5  JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(\u0026#34;JVM_IHashCode\u0026#34;); // as implemented in the classic virtual machine; return 0 if object is NULL  return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END   [JVM_IHashCode 는 ObjectSynchronizer::FastHashCode][synchronizer-714]를 사용하고 있다. 그리고 이 함수를 잘 읽어보면 새로운 해시 코드 할당은 get_next_hash 함수를 사용한다는 것을 알 수 있다. 다음은 get_next_hash 함수의 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  // hashCode() generation : // // Possibilities: // * MD5Digest of {obj,stwRandom} // * CRC32 of {obj,stwRandom} or any linear-feedback shift register function. // * A DES- or AES-style SBox[] mechanism // * One of the Phi-based schemes, such as: // 2654435761 = 2^32 * Phi (golden ratio) // HashCodeValue = ((uintptr_t(obj) \u0026gt;\u0026gt; 3) * 2654435761) ^ GVars.stwRandom ; // * A variation of Marsaglia\u0026#39;s shift-xor RNG scheme. // * (obj ^ stwRandom) is appealing, but can result // in undesirable regularity in the hashCode values of adjacent objects // (objects allocated back-to-back, in particular). This could potentially // result in hashtable collisions and reduced hashtable efficiency. // There are simple ways to \u0026#34;diffuse\u0026#34; the middle address bits over the // generated hashCode values:  static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG.  // On MP system we\u0026#39;ll have lots of RW access to a global, so the  // mechanism induces lots of coherency traffic.  value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent)  // between STW operations. This can be useful in some of the 1-0  // synchronization schemes.  intptr_t addrBits = cast_from_oop\u0026lt;intptr_t\u0026gt;(obj) \u0026gt;\u0026gt; 3; value = addrBits ^ (addrBits \u0026gt;\u0026gt; 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing  } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop\u0026lt;intptr_t\u0026gt;(obj); } else { // Marsaglia\u0026#39;s xor-shift scheme with thread-specific state  // This is probably the best overall implementation -- we\u0026#39;ll  // likely make this the default in future releases.  unsigned t = Self-\u0026gt;_hashStateX; t ^= (t \u0026lt;\u0026lt; 11); Self-\u0026gt;_hashStateX = Self-\u0026gt;_hashStateY; Self-\u0026gt;_hashStateY = Self-\u0026gt;_hashStateZ; Self-\u0026gt;_hashStateZ = Self-\u0026gt;_hashStateW; unsigned v = Self-\u0026gt;_hashStateW; v = (v ^ (v \u0026gt;\u0026gt; 19)) ^ (t ^ (t \u0026gt;\u0026gt; 8)); Self-\u0026gt;_hashStateW = v; value = v; } value \u0026amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, \u0026#34;invariant\u0026#34;); return value; }   equals와 hashCode는 왜 같이 재정의해야 할까? hash 값을 사용하는 Collection(HashMap, HashSet, HashTable)은 객체가 논리적으로 같은지 비교할 때 아래 그림과 같은 과정을 거친다. hashCode 메소드의 반환값을 이용해서 검색의 범위를 확 줄여버리고, 해당 부류 내에 존재하는 데이터의 내용 비교는 equals 메소드를 통해서 진행한다. Object 클래스의 hashCode 메서드는 객체의 고유한 주소 값을 int 값으로 변환하기 때문에 객체마다 다른 값을 리턴한다. 두 개의 Car 객체는 equals로 비교도 하기 전에 서로 다른 hashCode 메서드의 리턴 값으로 인해 다른 객체로 판단된 것이다. 성능에 아주 민감하지 않은 대부분의 프로그램은 간편하게 Objects.hash 메서드를 사용해서 hashCode 메서드를 재정의해도 문제없다. 민감한 경우에는 직접 재정의해주는 게 좋다. 1 2 3 4  @Override public int hashCode() { return Objects.hash(id, fileName, minutes); }   Objects 클래스에 정의된 hash 메소드는 다음과 같다. 1 2 3  public static int hash(Object... values) { return Arrays.hashCode(values); }   Arrays 클래스에 정의된 hashCode 메소드는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11  public static int hashCode(Object a[]) { if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; }   ","permalink":"https://youngeun-in.github.io/equals%EC%99%80-hashcode/","tags":["equals","hashcode"],"title":"equals와 hashCode"},{"categories":["java"],"contents":"Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다. 1 2 3  public interface Comparable\u0026lt;T\u0026gt; { int compareTo(T obj); }   사용 예시는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable\u0026lt;Person\u0026gt; { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void showData() { System.out.printf(\u0026#34;%s %d \\n\u0026#34;, name, age); } public int compareTo(Person p) { if (age \u0026gt; p.age) return 1; else if (age \u0026lt; p.age) return -1; else return 0; } } class ComparablePerson { public static void main(String[] args) { TreeSet\u0026lt;Person\u0026gt; sTree = new TreeSet\u0026lt;Person\u0026gt;(); sTree.add(new Person(\u0026#34;Lee\u0026#34;, 24)); sTree.add(new Person(\u0026#34;Hong\u0026#34;, 29)); sTree.add(new Person(\u0026#34;Choi\u0026#34;, 21)); Iterator\u0026lt;Person\u0026gt; itr = sTree.iterator(); while (itr.hasNext()) itr.next().showData(); } }   Comparator 인터페이스 String 클래스는 이미 compareTo 메소드를 구현하고 있다. 이 때 정령기준을 변경하기 위해서 String 클래스를 상속하는 클래스를 새로 정의하는 것은 번거롭다 따라서 새로운 정렬 기준을 파라미터로 넘길 수 있도록 정의된 것이 Comparator 인터페이스이다. 1 2 3  public interface Comparator\u0026lt;T\u0026gt; { int compare(T o1, T o2); }   사용 예시는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  import java.util.TreeSet; import java.util.Iterator; import java.util.Comparator; class StrLenComparator implements Comparator\u0026lt;String\u0026gt; { public int compare(String str1, String str2) { if (str1.length() \u0026gt; str2.length()) return 1; else if (str1.length() \u0026lt; str2.length()) return -1; else return 0; /* * return str1.length()-str2.length(); */ } } class IntroComparator { public static void main(String[] args) { TreeSet\u0026lt;String\u0026gt; tSet = new TreeSet\u0026lt;String\u0026gt;(new StrLenComparator()); tSet.add(\u0026#34;Orange\u0026#34;); tSet.add(\u0026#34;Apple\u0026#34;); tSet.add(\u0026#34;Dog\u0026#34;); tSet.add(\u0026#34;Individual\u0026#34;); Iterator\u0026lt;String\u0026gt; itr = tSet.iterator(); while (itr.hasNext()) System.out.println(itr.next()); } }   ","permalink":"https://youngeun-in.github.io/comparable-and-comparator/","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이"},{"categories":["spring"],"contents":"Spring의 대표적인 핵심가치 3가지로 IoC, AOP, PSA가 있다. PSA (Portable Service Abstraction) @Transactional 어노테이션을 선언하는 것 만으로 별도의 코드 추가 없이 트랜잭션 서비스를 사용할 수 있다. 내부적으로 트랜잭션 코드가 추상화되어 숨겨져 있는 것이다. 이렇게 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이며, 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다. PSA의 원리 트랜잭션을 예로 들어 설명하겠다. 위 그림처럼 Spring의 @Transactional은 각 TransactionManager를 각각 구현하고 있는 것이 아니라 최상위 PlatformTransactionManager를 이용하고 필요한 TransactionManager를 DI로 주입받아 사용하고 있다. PlatformTransactionManager 인터페이스의 소스코드는 다음과 같다. 1 2 3 4 5 6 7 8  public interface PlatformTransactionManager extends TransactionManager { TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException; }   ","permalink":"https://youngeun-in.github.io/spring-psa/","tags":["PSA"],"title":"Spring PSA"},{"categories":["design pattern"],"contents":"프록시 패턴 Proxy는 우리말로 대리자, 대변인 이라는 뜻이다. 대리자, 대변인은 다른 누군가를 대신해서 그 역할을 수행하는 존재를 말한다. 프록시는 타겟의 기능을 확장하거나 타깃에 대한 접근을 제어하기 위한 목적으로 사용된다. 상속을 사용한 구현 아래와 같은 타겟 클래스가 있다고 하자. 1 2 3 4 5  public class GameService { public void startGame() { System.out.println(\u0026#34;Hello\u0026#34;); } }   다음과 같이 프록시 클래스가 타겟 클래스를 상속받도록 만든다. 1 2 3 4 5 6 7 8 9  public class GameServiceProxy extends GameService { @Override public void startGame() { long before = System.currentTimeMillis(); //상위 메소드 실행  super.startGame(); System.out.println(System.currentTimeMillis() - before); } }   1 2 3 4 5 6  public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(); gameService.startGame(); } }   결과는 다음과 같다. 1 2  Hello 0   인터페이스를 사용한 구현 인터페이스를 사용할 경우, 좀 더 구조가 유연하며 테스트하기에도 쉽다. 다음과 같이 인터페이스를 선언한다. 1 2 3  public interface GameService { void startGame(); }   인터페이스를 구현한 클래스를 만들고, 메소드를 오버라이드한다. 1 2 3 4 5 6  public class DefaultGameService implements GameService{ @Override public void startGame() { System.out.println(\u0026#34;Hello\u0026#34;); } }   다음과 같이 프록시 클래스를 선언한다. 1 2 3 4 5 6 7 8 9 10 11 12  @RequiredArgsConstructor public class GameServiceProxy implements GameService { //GameService를 외부에서 주입받는다.  private final GameService gameService; @Override public void startGame() { long before = System.currentTimeMillis(); gameService.startGame(); System.out.println(System.currentTimeMillis() - before); } }   클라이언트에서는 GameService 구현체를 생성하여 프록시 객체에 넘겨준다. 1 2 3 4 5 6  public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(new DefaultGameService()); gameService.startGame(); } }   다이나믹 프록시 프록시 패턴의 단점은 다음과 같다.  인터페이스를 직접 구현해야 한다. 프록시 클래스 내에 중복이 발생한다.  위와 같은 문제는 다이나믹 프록시를 사용하여 해결할 수 있다. Dynamic Proxy는 런타임 시점에 인터페이스를 구현하는 클래스 또는 인스턴스를 만드는 기술을 말한다. 다이나믹 프록시를 사용하면, 일일이 구현해야한다는 문제는 reflection API가 해결해주고, 중복은 InvocationHandler가 해결해준다. InvocationHandler의 invoke() 메소드에서 타겟의 어떤 메소드에 적용할지 검사하고, 적용해야 하는 메소드라면 타겟의 원래 메소드를 호출하여 결과를 담아둔 뒤 추가 기능을 적용하여 리턴한다. 적용하지 말아야 하는 메소드라면 타겟의 원래 메소드의 리턴을 그대로 리턴한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  BookService bookService = (BookService) Proxy.newProxyInstance(BookService.class.getClassLoader(), new Class[]{BookService.class}, new InvocationHandler() { BookService bookService = new RealSubjectBookService(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName() == \u0026#34;rent\u0026#34;) { System.out.println(\u0026#34;11111\u0026#34;); Object invoke = method.invoke(bookService, args); System.out.println(\u0026#34;22222\u0026#34;); return invoke; } return method.invoke(bookService, args); } });   Proxy.newProxyInstance 메소드를 이용해 프록시 객체를 생성한다.  첫번째 인자는 프록시 객체를 생성할 인터페이스 타입의 클래스로더 두번째 인자는 해당 프록시가 어떤 인터페이스를 구현체인가 3번째 인자는 이를 구현하는 InvocationHandler 이다.  InvocationHandler는 invoke 메소드를 구현한다.  첫번째 인자는 newProxyInstance를 사용해 생성된 프록시 객체의 참조 두번째 인자는 프록시를 통해 호출된 메소드의 참조 세번째 인자는 해당 메소드의 파라메터들의 참조  invoke 메소드 내에서 method.invoke 를 통해 메소드를 호출할 수 있다. 만약 프록시 객체를 통해 부가적인 기능을 추가하고싶다면 invoke 메소드 내에서 구현을 해주면 된다. ","permalink":"https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/","tags":["dynamic-proxy"],"title":"프록시 패턴"},{"categories":["java"],"contents":"데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다. 결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다. 이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public enum PayType { ACCOUNT_TRANSFER(\u0026#34;계좌이체\u0026#34;), REMITTANCE(\u0026#34;무통장입금\u0026#34;), ON_SITE_PAYMENT(\u0026#34;현장결제\u0026#34;), TOSS(\u0026#34;토스\u0026#34;), PAYCO(\u0026#34;페이코\u0026#34;), CARD(\u0026#34;신용카드\u0026#34;), KAKAO_PAY(\u0026#34;카카오페이\u0026#34;), BAEMIN_PAY(\u0026#34;배민페이\u0026#34;), POINT(\u0026#34;포인트\u0026#34;), COUPON(\u0026#34;쿠폰\u0026#34;); private final String title; PayType(String title) { this.title = title; } public String getTitle() { return title; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import lombok.Getter; import java.util.Arrays; import java.util.Collections; import java.util.List; @Getter public enum PayGroup { CASH(\u0026#34;현금\u0026#34;, Arrays.asList(PayType.ACCOUNT_TRANSFER, PayType.REMITTANCE, PayType.ON_SITE_PAYMENT, PayType.TOSS)), CARD(\u0026#34;카드\u0026#34;, Arrays.asList(PayType.PAYCO, PayType.CARD, PayType.KAKAO_PAY, PayType.BAEMIN_PAY)), ETC(\u0026#34;기타\u0026#34;, Arrays.asList(PayType.POINT, PayType.COUPON)), EMPTY(\u0026#34;없음\u0026#34;, Collections.EMPTY_LIST); private final String title; private final List\u0026lt;PayType\u0026gt; payList; PayGroup(String title, List\u0026lt;PayType\u0026gt; payList) { this.title = title; this.payList = payList; } public static PayGroup findByPayType(PayType payType){ return Arrays.stream(PayGroup.values()) .filter(payGroup -\u0026gt; payGroup.hasPayType(payType)) .findAny() .orElse(EMPTY); } private boolean hasPayType(PayType payType){ return payList.stream() .anyMatch(pay -\u0026gt; pay == payType); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PayGroupTest { @Test public void PayGroup에게_직접_결제종류_물어보기_PayType () { PayType payType = selectPayType(); PayGroup payGroup = PayGroup.findByPayType(payType); assertEquals(payGroup.name(), \u0026#34;CARD\u0026#34;); assertEquals(payGroup.getTitle(), \u0026#34;카드\u0026#34;); } private PayType selectPayType(){ return PayType.BAEMIN_PAY; } }   DB 혹은 API에서 PayType으로 데이터를 받아, 타입 안전성까지 확보하여 PayGroup 관련된 처리를 진행할 수 있게 되었다. 참고 https://github.com/jojoldu/blog-code/tree/master/enum-settler ","permalink":"https://youngeun-in.github.io/enum-usage-2/","tags":["enum"],"title":"Enum 사용 (활용)"},{"categories":["java"],"contents":"상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 \u0026ldquo;CALC_A\u0026quot;일 경우엔 값 그대로, \u0026ldquo;CALC_B\u0026quot;일 경우엔 10 한 값을, \u0026ldquo;CALC_C\u0026quot;일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 \u0026ldquo;DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.\u0026ldquo;는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import java.util.function.Function; public enum CalculatorType { CALC_A(value -\u0026gt; value), CALC_B(value -\u0026gt; value * 10), CALC_C(value -\u0026gt; value * 30), CALC_ETC(value -\u0026gt; 0L); private Function\u0026lt;Long, Long\u0026gt; expression; CalculatorType(Function\u0026lt;Long, Long\u0026gt; expression) { this.expression = expression; } public long calculate(long value) { return expression.apply(value); } }   1 2 3 4 5 6 7 8 9 10  import javax.persistence.Column; import javax.persistence.EnumType; import javax.persistence.Enumerated; public class Entity { @Column //@Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다.  @Enumerated(EnumType.STRING) private CalculatorType calculatorType; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.testng.annotations.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTypeTest { private CalculatorType selectType() { return CalculatorType.CALC_B; } @Test public void 코드에_따라_서로다른_계산하기_Enum() { CalculatorType code = selectType(); long originValue = 10000L; long result = code.calculate(originValue); assertEquals(result, 100000L); } }   값(상태)과 메소드(행위)가 어떤 관계가 있는지에 대해 더이상 다른 곳을 찾을 필요가 없게 되었다. 코드내에 전부 표현되어 있고, Enum 상수에게 직접 물어보면 되기 때문이다. ","permalink":"https://youngeun-in.github.io/enum-usage-1/","tags":["enum"],"title":"Enum 사용 (개념)"},{"categories":["ML"],"contents":"Step Function 활성화 함수는 신경망의 행동을 결정하는 중요한 역할을 합니다. 가장 간단한 형태의 활성화 함수는 계단 함수(Step function) 라고 합니다. 계단 함수는 입력값의 합이 임계값을 넘으면 $0$ 을, 넘지 못하면 $1$ 을 출력하게 됩니다. 계단 함수의 그래프는 다음과 같이 생겼습니다. 이미지 출처 : wikipedia - Heaviside step function 계단 함수는 활성화 함수의 조건을 가장 잘 만족하는 함수이고 직관적으로도 이해하기 쉽습니다. 하지만 불연속 함수라는 단점 때문에 실제 신경망에 사용되지는 않습니다. 그래프를 보면 알 수 있듯 임계값 지점에서 불연속점을 갖게 되는데 이 점에서 미분이 불가능하기 때문에 학습이 필요한 신경망에 사용할 수 없습니다. 이런 문제점을 해결하기 위해서 등장한 것이 시그모이드 함수(Sigmoid) 입니다. Sigmoid Function 시그모이드 함수는 기본적으로 $S$ 모양을 그리는 곡선 함수를 통칭하여 부르는 말입니다. 이 중 대표적인 함수는 로지스틱(Logistic) 함수와 하이퍼탄젠트(Hyper tangent, $\\tanh$) 함수가 있습니다. 두 함수의 수식과 그래프를 보며 시그모이드 함수와 계단 함수가 다른 점이 무엇인지 알아보도록 하겠습니다. 로지스틱 함수(Logistic Function) $$ \\text{Logistic} : \\frac{1}{1+e^{-x}} $$ 이미지 출처 : wikipedia - Logistic function 하이퍼탄젠트 함수(Hypertangent Function) $$ \\text{Hypertangent} : \\frac{e^x-e^{-x}}{e^x+e^{-x}} = \\frac{e^{2x}-1}{e^{2x}+1} $$ 이미지 출처 : mathworld.wolfram.com 두 함수는 모두 연속함수입니다. 계단 함수의 치명적인 단점이었던 불연속을 해결했지요. 계단 함수와 시그모이드 함수의 중요한 공통점은 비선형 함수(Non-linear) 라는 점입니다. 활성화 함수는 비선형 함수를 사용해야 합니다. 활성화 함수가 선형 함수이면 안되는 이유는 무엇일까요? 선형인 활성화 함수 $l(x) = ax + b$ 가 있다고 해보겠습니다. 이 함수를 사용하여 3개의 층을 쌓는다면 최종적인 활성화 함수는 $l(l(l(x))) = l^3(x) = a(a(ax+b)+b)+b = a^3x+a^2b+ab+b$가 됩니다. $a^3 = c, d = a^2b+ab+b$라고 하면 $l^3(x) = cx+d$로 여전히 같은 형태의 함수를 사용하게 됩니다. 이렇듯 층을 아무리 깊게 쌓아도 여러 층을 쌓는 이점을 살리지 못하게 되지요. 여러 층을 쌓을 때의 장점을 살리기 위해 비선형 함수를 사용하게 되는 것이지요. ReLU Function 시그모이드 함수는 불연속이라는 계단 함수의 단점을 해결했습니다. 하지만 시그모이드는 대부분의 점에서 기울기 값이 0이 됩니다. 이 때문에 **기울기 소실(Gradient vanishing)**이라는 문제가 발생합니다. 기울기 소실은 시그모이드 함수를 활성화 함수로 사용하여 층을 깊게 쌓았을 때 학습이 잘 되지 않는 현상입니다. 이런 현상이 왜 발생하는지 알아보겠습니다. 로지스틱 함수 $L(x)$를 미분한 함수 $L^\\prime(x)$ 의 수식은 다음과 같습니다. $$ L^\\prime(x) = \\bigg(\\frac{1}{1+e^{-x}}\\bigg)^\\prime = \\frac{e^x}{(1+e^{-x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 그래프에서 볼 수 있듯 최댓값이 $0.25$ 밖에 되지 않고 $x\u0026lt;-5, x\u0026gt;5$ 범위에서는 거의 $0$ 에 가깝습니다. 역전파(Back propagation) 과정에서는 미분값을 사용하여 학습을 하게 됩니다. 따라서 이 값이 0에 가까워 지면 정보가 유실되면서 학습이 잘 안되게 됩니다. 특히 층을 깊게 쌓을 경우에는 정보가 모두 유실되는 사태가 발생하게 되지요. 그렇다면 하이퍼탄젠트 함수는 어떻게 될까요? 하이퍼탄젠트 함수 $\\tanh$를 미분한 함수의 수식은 다음과 같습니다. $$ \\tanh^\\prime(x) = \\bigg(\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\bigg)^\\prime = \\frac{4e^{2x}}{(1+e^{2x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 하이퍼탄젠트 함수를 미분한 함수의 최댓값은 $1$ 입니다. 최댓값이 $0.25$ 밖에 안되었던 로지스틱 함수 보다는 정보를 잘 전달하게 되지요. 하지만 여전히 $x$ 가 0에서 멀어질수록 원래 함수의 미분값은 0에 가까워집니다. 그래서 하이퍼탄젠트 함수를 활성화 함수로 하더라도 퍼셉트론을 여러 층으로 쌓는다면 학습이 제대로 안되게 되지요. 이렇게 시그모이드 함수를 활성화 함수로 사용할 때 역전파시 학습이 제대로 진행되지 않는 현상을 기울기 소실이라고 합니다. 기울기 소실 문제를 극복하기 위해서 등장한 함수가 바로 ReLU(Rectified Linear Unit)함수입니다. ReLU함수는 입력값이 0보다 작을 경우에는 0을 반환하고, 0보다 클 경우에는 입력값을 그대로 반환합니다. 아래는 ReLU함수의 그래프를 나타낸 것입니다. 이미지 출처 : medium.com ReLU함수는 $x$ 가 $0$ 보다 클 때, 미분값이 항상 $1$ 입니다. 그래서 층이 아무리 깊어져도 손실없이 정보를 전달할 수 있습니다. 미분값이 항상 $0$과 $1$ 이기 때문에 연산이 빠르다는 점도 ReLU함수의 장점입니다. 덕분에 ReLU함수는 은닉층에서 가장 많이 사용되는 활성화 함수가 되었습니다. 물론 ReLU함수에게도 문제가 있습니다. 0이하의 값이 그대로 보존되지 않고 버려진다는 것이지요. 이를 보완하기 위해 Leaky ReLU함수가 고안되어 사용되고 있습니다. 일반적으로는 $a=0.01$을 사용하며 그래프는 다음과 같습니다. 이미지 출처 : medium.com ","permalink":"https://youngeun-in.github.io/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/","tags":["step-function","sigmoid","relu"],"title":"활성화 함수"},{"categories":["spring"],"contents":"Spring mocking 없이 테스트하려면? 아래 코드를 mocking 없이 테스트하려면 어떻게 해야 할까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import java.io.IOException; public class RepositoryRank { public int getPoint(String repositoryName) throws IOException { GitHub github = GitHub.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u0026gt; 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public static void main(String[] args) throws IOException { RepositoryRank repositoryRank = new RepositoryRank(); int point = repositoryRank.getPoint(\u0026#34;whiteship/live-study\u0026#34;); System.out.println(point); } }   Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입하면 된다. 설명과 코드는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import org.kohsuke.github.GitHubBuilder; import java.io.IOException; public class RepositoryRank { //인터페이스 선언  interface GitHubService { GitHub connect() throws IOException; } //인터페이스를 구현한 클래스 생성하고 모킹하고자 하는 메소드를 오버라이드한다.  static class DefaultGitHubService implements GitHubService { @Override public GitHub connect() throws IOException { return new GitHubBuilder().build(); } } private final GitHubService gitHubService; //서비스를 주입받는다.  public RepositoryRank(GitHubService gitHubService) { this.gitHubService = gitHubService; } public int getPoint(String repositoryName) throws IOException { GitHub github = gitHubService.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u0026gt; 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public void main(String[] args) throws IOException { GitHubService gitHubService = new DefaultGitHubService(); //Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입  RepositoryRank repositoryRank = new RepositoryRank(gitHubService); int point = repositoryRank.getPoint(\u0026#34;whiteship/live-study\u0026#34;); System.out.println(point); } }   참고 백기선님의 유튜브를 참고했다. https://youtu.be/bJfbPWEMj_c ","permalink":"https://youngeun-in.github.io/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법"},{"categories":null,"contents":"","permalink":"https://youngeun-in.github.io/search/","tags":null,"title":"Search"}]