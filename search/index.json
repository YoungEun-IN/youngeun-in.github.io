[{"categories":["java"],"contents":"Reflection API란? 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메서드, 타입, 변수 등등)에 접근할 수 있게 해주는 자바 API다. 아래와 같이 Car 클래스가 존재한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class Car { private final String name; private int position; public Car(String name, int position) { this.name = name; this.position = position; } public void move() { this.position++; } public int getPosition() { return position; } }   자바의 특징 중 하나인 다형성 덕분에 아래와 같이 객체 생성이 가능하다. 1 2 3  public static void main(String[] args) { Object obj = new Car(\u0026#34;foo\u0026#34;, 0); }   그럼 이렇게 생성된 obj라는 이름의 객체가 Car 클래스의 move 메서드를 사용할 수 있을까? 정답은 불가능이다. 왜일까? 자바는 컴파일러를 사용한다. 즉 컴파일 타임에 타입이 결정된다. obj라는 이름의 객체는 컴파일 타임에 Object로 타입이 결정됐기 때문에 Object 클래스의 인스턴스 변수와 메서드만 사용할 수 있다. 그러므로 아래와 같은 코드는 필연적으로 컴파일 에러가 난다. 1 2 3 4  public static void main(String[] args) { Object obj = new Car(\u0026#34;foo\u0026#34;, 0); obj.move(); // 컴파일 에러 발생 java: cannot find symbol }   생성된 obj라는 객체는 Object 클래스라는 타입만 알 뿐, Car 클래스라는 구체적인 타입은 모른다. 결국 컴파일러가 있는 자바는 구체적인 클래스를 모르면 해당 클래스의 정보에 접근할 수 없다는 것을 알 수 있다. 이렇게 불가능한 일을 마법처럼 가능하게 해주는 것이 Reflection API이다. 위에서 봤던 예제와 똑같은 상황에서 Reflection API를 활용해 Car 클래스의 move 메서드를 호출해보자. 1 2 3 4 5 6 7 8 9 10 11 12 13  public static void main(String[] args) throws Exception { Object obj = new Car(\u0026#34;foo\u0026#34;, 0); Class carClass = Car.class; Method move = carClass.getMethod(\u0026#34;move\u0026#34;); // move 메서드 실행, invoke(메서드를 실행시킬 객체, 해당 메서드에 넘길 인자)  move.invoke(obj, null); Method getPosition = carClass.getMethod(\u0026#34;getPosition\u0026#34;); int position = (int)getPosition.invoke(obj, null); System.out.println(position); // 출력 결과: 1 }   move 메서드가 실행되고 0으로 초기화했던 Car 클래스 인스턴스 변수 position이 1로 출력되는 걸 확인할 수 있다. Reflection API로 구체적인 클래스 Car 타입을 알지 못해도 move 메서드에 접근한 것이다. 1  Class carClass2 = Class.forName(\u0026#34;Car\u0026#34;);   위의 예제처럼 클래스의 이름만으로도 해당 클래스의 정보를 가져올 수 있다. 다시 말해서 Reflection API는 클래스의 이름만 가지고도 생성자, 필드, 메서드 등등 해당 클래스에 대한 거의 모든 정보를 가져올 수 있는 마법 같은 API라는 것이다. Reflection은 어떻게 가능할까? 자바에서는 JVM이 실행되면 사용자가 작성한 자바 코드가 컴파일러를 거쳐 바이트 코드로 변환되어 static 영역에 저장된다. Reflection API는 이 정보를 활용한다. 그래서 클래스 이름만 알고 있다면 언제든 static 영역을 뒤져서 정보를 가져올 수 있는 것이다. Reflection을 어디에 활용할 수 있을까? 위에서 살펴봤던 예제 코드를 보면 멀쩡한 Car 객체를 Object 타입으로 생성하고 있다. 실제로 우리가 코드를 작성할 때는 예제와 같이 작성하지 않는다. 그러므로 우리가 코드를 작성하면서 Reflection을 활용할 일은 거의 없다. 구체적인 클래스를 모를 일이 거의 없기 때문이다. 게다가 Reflection은 마법 같은 힘을 가지고 있는 만큼 치명적인 단점들을 가지고 있다. 당연히 사용하지 않을 수 있다면 대부분의 경우 사용하지 않는 게 좋다. 치명적인 단점 중 대표적으로 성능 오버헤드가 있다. 컴파일 타임이 아닌 런타임에 동적으로 타입을 분석하고 정보를 가져오므로 JVM을 최적화할 수 없기 때문이다. 뿐만 아니라 직접 접근할 수 없는 private 인스턴스 변수, 메서드에 접근하기 때문에 내부를 노출하면서 추상화가 깨진다. 이로 인해 예기치 못한 부작용이 발생할 수 있다. 결론적으로 Reflection은 애플리케이션 개발보다는 프레임워크나 라이브러리에서 많이 사용된다. 프레임워크나 라이브러리는 사용자가 어떤 클래스를 만들지 예측할 수 없기 때문에 동적으로 해결해주기 위해 Reflection을 사용한다. 실제로 intellij의 자동완성, jackson 라이브러리, Hibernate 등등 많은 프레임워크나 라이브러리에서 Reflection을 사용하고 있다. Spring Framework에서도 Reflection API를 사용하는데 대표적으로 Spring Container의 BeanFactory가 있다. Bean은 애플리케이션이 실행한 후 런타임에 객체가 호출될 때 동적으로 객체의 인스턴스를 생성하는데 이때 Spring Container의 BeanFactory에서 리플렉션을 사용한다. Spring Data JPA 에서 Entity에 기본 생성자가 필요한 이유도 동적으로 객체 생성 시 Reflection API를 활용하기 때문이다. Reflection API로 가져올 수 없는 정보 중 하나가 생성자의 인자 정보이다. 그래서 기본 생성자가 반드시 있어야 객체를 생성할 수 있는 것이다. 기본 생성자로 객체를 생성만 하면 필드 값 등은 Reflection API로 넣어줄 수 있다. 출처 https://tecoble.techcourse.co.kr/post/2020-07-16-reflection-api/ ","permalink":"https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/","tags":["reflection"],"title":"자바의 Reflection"},{"categories":["java"],"contents":"Java 컴파일 과정 자바 소스 파일(*.java)을해당 파일을 Java Compiler가 JVM이 해석할 수 있는 파일인 Java ByteCode (*.class)파일로 변환한다. Java Compiler는 Java 설치 시 Javac.exe라는 실행 파일 형태로 존재한다. Java 바이트 코드란? Java 바이트 코드란 Java Source File을 Java Compiler가 컴파일해 만든 파일이다. Java Compiler에 의해 변환되는 코드의 명령어 크기가 1byte이기 때문에 Java 바이트코드라고 불린다. Java 바이트 코드는 JVM이 해석할 수 있는 언어이며 *.class 확장자를 가진다. Java 실행 과정  Java Compiler를 통해 만들어진 Java Bytecode (*.class)를 Class Loader를 통해 가져온 후 Runtime Data Area에 배치한다. Execution Engine에서 바이트코드를 기계어로 해석한다. Execution Engine은 인터프리터 방식 혹은 JIT(Just-In-Time) Compiler 방식이 있다.  인터프리터 방식은 소스 코드를 한 문장씩 읽으며 해당 문장을 기계어 코드로 변환시켜준다. JIT Compiler는 실행 시점에 기계어 코드로 변환시켜준다.   프로세서는 기계어에 따라 동작을 수행한다.  JIT 컴파일러 JIT(Just-In-Time) 컴파일러는 JVM의 Execution Engine이 바이트코드를 사용하는 운영체제에 맞는 기계어로 변환시켜주는 방식중 하나이다. JIT 컴파일러는 프로그램을 실제 실행하는 시점에 기계어를 번역한다. 이렇게만 보면 인터프리터 방식과의 차이점이 없어보이지만 JIT 컴파일러는 같은 코드를 매번 해석하지 않고 기계어로 번역하면서 캐싱한다. 해당 파일이 다시 기계어로 컴파일 된다면 이전 파일과 비교해서 바뀐 부분은 새롭게 컴파일하고 변동 사항이 없는 부분은 캐싱된 코드를 사용한다. 이러한 방식은 인터프리터 속도가 느린 점을 JIT 컴파일러로 개선할 수 있는 장점이 된다. ","permalink":"https://youngeun-in.github.io/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/","tags":["compiler","interpreter"],"title":"Java 실행 과정"},{"categories":["java"],"contents":"JVM의 구성요소 JVM은 크게 Class loader, Runtime Data Areas, Excution Engine 3가지로 구성된다. Class Loader(클래스 로더) Java 컴파일러로 컴파일된 Java 바이트 코드를 Runtime 시점에 JVM내로 가져오고 Runtime Data Area(JVM 메모리 영역)에 배치해주는 역할을 한다. Runtime Data Area JVM의 메모리 영역에 해당하며 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 세분화된다.  Method Area : Class, Interface, Method, Field, Static, Final 변수 등을 보관하는 영역 Heap Area : new 키워드로 생성된 객체나 배열 인스턴스를 보관하는 영역, Runtime 시 동적으로 생성되고 JVM이 사용여부를 판단 후 Garbage Collection을 하는 영역 Stack Area : Heap Area에 동적으로 생성되어 보관되있는 객체(참조 타입)의 래퍼런스를 보관하는 영역, 기본 타입의 경우 직접 Stack Area에 보관됨 PC Register : Thread가 생성될 때 생성되는 영역으로서 Thread마다 하나의 영역을 가진다. JVM이 현재 수행중인 명령의 주소를 가짐 Native Method Stack : Java외 다른 언어로 작성된 Native Code를 위한 Stack 영역  Execution Engine Class Loader를 통해 Runtime Data Area영역에 배치된 바이트 코드를 실행하는 역할을 한다. ","permalink":"https://youngeun-in.github.io/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/","tags":["jvm"],"title":"JVM의 구성요소"},{"categories":["DB"],"contents":"캐시란 cache란 사용자의 입장에서 데이터의 원래 소스보다 더 빠르게 그리고 더 효율적으로 액세스할 수 있는 임시 데이터 저장소를 뜻한다. 대부분의 애플리케이션에서 속도 향상을 위해 cache를 사용하고 있다. 캐시에 데이터나 계산된 결과 값의 복사본을 저장해 둠으로써 전체적인 처리 속도를 향상시킨다. 캐시를 사용하는 경우는 다음과 같다.  데이터에 직접적으로 접근하는 데 걸리는 시간이 오래 걸릴 때 데이터가 잘 변하지 않는 경우 반복적으로 동일한 결과를 돌려주는 경우 (이미지와 썸네일 등)  Redis란 레디스는 전 세계에서 가장 유명한 caching 솔루션이다. 단순하게 key-value 형태로 저장할 수 있기 때문에 어떤 데이터라도 쉽게 저장할 수 있다. 또한 레디스는 모든 데이터를 메모리에 올려두는 인메모리 데이터 스토어이다. 평균 읽기 및 쓰기 작업 속도가 1밀리 세컨드 미만이니 초당 수백만 건의 작업이 가능하다. 캐싱 전략 레디스를 cache로 사용할 때 어떻게 배치하는지가 시스템의 성능에 큰 영향을 끼치기 때문에 caching 전략은 데이터의 유형과 해당 데이터에 대한 액세스 패턴을 잘 고려해서 선택해야 한다. 읽기 전략 Look-Aside(Lazy Loading) 이 구조는 레디스를 cache로 쓸 때 가장 일반적으로 사용하는 방법이다. 애플리케이션은 데이터를 찾을 때 cache에 먼저 확인한다. cache에 데이터가 있으면 cache에서 데이터를 가지고 오는 작업을 반복한다. 만약 레디스에 찾는 키가 없다면 애플리케이션은 DB에 접근해서 데이터를 직접 가지고 온 뒤 다시 레디스에 저장하는 과정을 거쳐야 한다. 따라서 cache는 찾는 데이터가 없을 때에만 입력되기 때문에 이를 lazy loading이라고도 부른다. 이 구조는 레디스가 다운되더라도 바로 장애로 이어지지 않고 DB에서 데이터를 가지고 올 수 있다. 대신 cache로 붙어있던 커넥션이 많이 있었다면 그 커넥션이 모두 데이터베이스로 붙기 때문에 DB에 갑자기 많은 부하가 몰릴 수 있다. 그래서 이런 경우에 cache를 새로 투입하거나 DB에만 새로운 데이터를 저장했다면 처음에 캐시 미스가 엄청 발생해서 성능에 저하가 올 수 있다. 이럴 때에는 미리 DB에서 cache로 데이터를 밀어 넣어주는 작업을 할 수 있는데, 이를 cache warming이라고도 한다. 쓰기 전략 Write-Around write around 방식은 DB에만 데이터를 저장한다. 일단 모든 데이터는 DB에 저장되고 cache miss가 발생한 경우에만 cache에 데이터를 끌어오게 된다. 이 경우엔 cahce 내의 데이터와 DB 내의 데이터가 다를 수 있다는 단점이 있다. Write-Through write-through 전략은 DB에 데이터를 저장할 때 cache에도 함께 저장하는 방법이다. cache는 항상 최신 정보를 가지고 있다는 장점이 있지만 저장할 때마다 두 단계 스텝을 거쳐야 하기 때문에 상대적으로 느리다고 볼 수 있다. 그리고 저장하는 데이터가 재사용되지 않을 수도 있는데 무조건 캐시에 넣어버리기 때문에 이는 일종의 리소스 낭비라고도 볼 수 있다. 따라서 이렇게 데이터를 저장할 때는 몇 분 혹은 몇 시간 동안만 데이터를 보관하겠다는 의미인 expire time을 설정해 주는 것이 좋다. 출처 https://youtu.be/92NizoBL4uA ","permalink":"https://youngeun-in.github.io/redis/","tags":["cache"],"title":"Redis"},{"categories":["network"],"contents":"HTTP 캐시 Static file(js, css, image) 뿐만 아니라 API와 같은 Dynamic content에도 간단하게 Cache기능을 사용하게 설정하면 API속도도 증가되고 유저 입장에서는 네트웍 트래픽을 줄일 수 있다. API와 같이 언제 바뀔지 모르는 데이터의 Cache는 쉽지 않은데, Etag를 이용하면 서버에서 새로운 데이터를 먼저 확인하고 줄 수 있기 때문에 API에도 충분히 적용가능하다. Etag API데이터의 MD5 Hash를 ETag로 사용하게 되면 DB부하를 줄일 순 없지만, Response 시간을 줄이는데 도움이 될 수 있다. Response에 다음과 같은 Etag 헤더를 추가해주면, 다음 동일한 API를 부르면 아래와 같은 Request 헤더에 체크하는 헤더가 추가된다. 1  If-None-Match: \u0026#34;15f0fff99ed5aae4edffdd6496d7131f\u0026#34;   서버에서 같은 ETag를 가지고 있다면 Http code 304 를 리턴해주면 된다. Etag 작동 순서  API 핸들러 처리(DB query) 결과 Json에 MD5 Hash If-None-Match 헤더에 있는 값과 hash값을 비교 만약 동일하다면 304로 리턴 다르다면 200에 결과 Json리턴  ","permalink":"https://youngeun-in.github.io/etag/","tags":["http-cache"],"title":"Etag"},{"categories":["DB"],"contents":"인덱스의 종류 클러스터형 인덱스(Clustered Index)  영어 사전처럼 책의 내용 자체가 순서대로 정렬되어 있어서 인덱스 자체가 책의 내용과 같은 것 테이블 당 한 개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하는지에 따라서 시스템의 성능이 달라질 수 있다. 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 신중하게 생각해야 한다. 보조 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다.  보조 인덱스(Secondary Index)  \u0026lt;찾아보기\u0026gt;가 별도로 있고, \u0026lt;찾아보기\u0026gt;를 찾은 후에 그 옆에 표시된 페이지로 가야 실제 찾는 내용이 있는 것 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다. 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소값이다. 클러스터형 인덱스보다 검색 속도는 더 느리지만 입력/수정/삭제는 덜 느리다. 테이블 당 여러 개를 생성할 수 있다. 하지만 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있으므로 꼭 필요한 열에만 생성하는 것이 좋다.  MYSQL 인덱스의 특징  PRIMARY KEY로 지정한 열은 클러스터형 인덱스가 생성된다. UNIQUE NOT NULL로 지정한 열은 클러스터형 인덱스가 생성된다. UNIQUE(또는 UNIQUE NULL)로 지정한 열은 보조 인덱스가 생성된다. PRIMARY KEY와 UNIQUE NOT NULL이 있으면 PRIMARY KEY로 지정한 열에 우선 클러스터형 인덱스가 생성된다. PRIMARY KEY로 지정한 열로 데이터가 오름차순 정렬된다.  인덱스를 생성할 때 고려할 점  테이블 조회 시에 WHERE 절의 조건에 해당 열이 나오는 경우에만 인덱스를 사용한다. WHERE절에 사용되더라도 자주 사용해야 가치가 있다. 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다. 외래 키를 지정한 열에는 자동으로 외래 키 인데스가 생성된다. JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다. 사용하지 않는 인덱스는 제거하자.  ","permalink":"https://youngeun-in.github.io/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/","tags":["index"],"title":"DB 인덱스"},{"categories":["개발방법론"],"contents":"📕 AOP AOP는 OOP를 더욱 OOP답게 프로그래밍 할 수 있게 도와주는 것으로 애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법이다. 실제로 Spring doc document 에서는 아래와 같이 말하고 있다. 1 2 3 4 5  Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by providing another way of thinking about program structure AOP는 프로그램 구조에 대한 다른 생각의 방향을 제공해주면서 OOP를 보완하고 있다.   예를 들면 어떠한 클래스를 대상으로 핵심 기능과 부가적인 기능의 관점으로 공통 사용 부가 기능들을 외부의 독립된 클래스로 분리하고 이를 모듈화하여 재사용할 수 있게끔 하는 프로그래밍 기법이다. 📘 AOP 용어    용어 설명     Aspect(Advisor) ✔ 특정 한 가지 기능에 대해 흩어진 관심사를 모듈화하여 묶은 클래스 - PointCut + Advice를 묶은 메서드를 정의 및 관리한다.   Target ✔ 비즈니스(핵심) 로직을 구현하는 AOP의 대상 \u0026lsquo;클래스\u0026rsquo;   Advice ✔ AOP 메서드 : 부가 기능을 적용시키는 메서드(부가 기능 로직 메서드) 적용 시점도 지정할 수 있다. - before : 비즈니스 메소드 실행 전에 동작 - after : 비즈니스 메소드 실행 후에 동작 - after-returning : 비즈니스 메소드 실행 중 리턴 되는 순간 - after-throwing : 비즈니스 메소드 실행 중 에러 발생 순간 - around\t: 비즈니스 메소드 실행 전/후에 동작   JoinPoint ✔ AOP가 적용될 수 있는 메소드, 필드, 객체, 생성자 등의 요소 - 타겟 클래스의 요소들을 의미하며 PointCut의 후보 - Spring AOP에서는 메서드만 지정 가능   PointCut ✔ AOP 적용 가능 요소들 중에서 \u0026lsquo;실제 적용될 요소들\u0026rsquo;을 의미한다. - JoinPoint에서 실제 Advice가 적용될 지점 - Spring AOP 에서는 advice가 적용될 메서드를 의미   Weaving ✔ PointCut이 호출될 때 Advice가 호출되는 과정을 의미한다. 즉, PointCut에 Advice 메서드가 삽입되는 과정을 의미한다. - 컴파일 전에는 핵심 로직과 인프라 로직이 분리되어있지만 - 컴파일타임에 바이트 코드를 넣는다던지 런타임에 프록시를 만들던지 - 관심사를 분리한 코드를 비즈니스 코드와 병합하는 작업을 의미한다. Weaving 처리 방식 (AOP 구현 방법) - 컴파일 타임 위빙 : a.java -\u0026gt; a.clss 컴파일 될 때 - 로딩 타임 위빙 : 클래스파일을 클래스 로더가 메모리에 로드할 때 - 런타임/프록시 위빙 : 타겟 클래스에 부가 기능을 추가하도록 Proxy 객체를 만들어(감싸서) 실행 - 스프링 AOP는 런타임 위빙만을 지원한다.(IOC/DI를 이용한 방법)   proxy ✔ Target 객체에 Advice를 적용시키는 래퍼 클래스     애플리케이션은 자연스럽게 여러 메서드(Join Point)를 호출한다. 이때 특정 PointCut으로 지정한 메소드가 호출되는 순간 Aspect 의 Advice 메소드가 호출된다. Advice 메소드의 동작 시점은 5가지로 정할 수 있다. 애스팩트 설정에 따라 위빙 처리되어 프록시 객체가 생성된다.(동적 프록시 생성) 프록시 객체를 통해 부가기능이 포함된 비즈니스 로직을 수행한다.  📖 AOP 구현 1  implementation \u0026#39;org.springframework.boot:spring-boot-starter-aop\u0026#39;   1 2 3 4 5  // @EnableAspectJAutoProxy 생략 가능 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } }   1 2 3 4 5 6  @Service public class AuthServiceImpl { public void businessLogicMethod(){ System.out.println(\u0026#34;businessLogicMethod process!\u0026#34;); } }   📄 일반적인 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Aspect @Configuration public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\u0026#34;execution(* com.demo.study.service.AuthServiceImpl.*(..))\u0026#34;) public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\u0026#34;request spent {} ms\u0026#34;, stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\u0026#34;execution(* com.demo.study.service.AuthServiceImpl.*(..))\u0026#34;) public void After() throws Throwable { log.info(\u0026#34;After 어드바이스\u0026#34;); } }   📄 어노테이션으로 구현 1 2 3 4  @Target(ElementType.METHOD) @Retention(RetentionPolicy.CLASS) public @interface PerformanceCheck { }   1 2 3 4 5 6 7  @Service public class AuthServiceImpl { @PerformanceCheck public void businessLogicMethod(){ System.out.println(\u0026#34;businessLogicMethod process!\u0026#34;); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\u0026#34;@annotation(com.demo.study.annotation.PerformanceCheck)\u0026#34;) public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\u0026#34;request spent {} ms\u0026#34;, stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\u0026#34;@annotation(com.demo.study.annotation.PerformanceCheck)\u0026#34;) public void After() throws Throwable { log.info(\u0026#34;After 어드바이스\u0026#34;); } }    어노테이션과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다.  📄 빈으로 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\u0026#34;bean(com.demo.study.service.AuthServiceImpl)\u0026#34;) public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\u0026#34;request spent {} ms\u0026#34;, stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\u0026#34;bean(com.demo.study.service.AuthServiceImpl)\u0026#34;) public void After() throws Throwable { log.info(\u0026#34;After 어드바이스\u0026#34;); } }    빈과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다.  📖 AOP PointCut 설정 1  execution(* com.springbook.biz..*Impl.get*(..))\u0026#34;    * : 리턴값 com.springbook.biz.. : 패키지 *Impl: 클래스 이름 get* : 메서드 이름 (..) : 매개변수 중간마다의 . : 구분점  📄 execution 포인트 컷 리턴    표현식 설명     * 모든 리턴타입 허용   void 리턴타입이 void인 메서드 선택   !void 리턴타입이 void가 아닌 메서드 선택    📄 execution 포인트 컷 패키지    표현식 설명     com.springbook.biz 정학하게 해당 패키지만 선택   com.springbook.biz.. 해당 패키지 및 모든 하위 패키지 선택   com.springbook..impl ..앞 패키지로 시작하면서 마지막 패키지 이름이 ..뒤로 끝나는 패키지 선택    📄 execution 포인트 컷 클래스    표현식 설명     BoardServiceImpl 정학하게 해당 클래스만 선택   *Impl 클래스 이름이 *뒷 글자로 끝나는 클래스만 선택   BoardService+ 해당 클래스는 물론 파생된 모든 자식 클래스도 선택 가능   variable+ 해당 인터페이스를 구현한 모든 클래스 선택 가능    📄 execution execution 포인트 컷 메서드    표현식 설명     *(..) 가장 기본 설정으로 모든 메서드 선택   get*(..) 메서드 이름이 get으로 시작하는 모든 메서드 선택   매서드이름(..) 특정 메서드 이름을 가진 메서드 선택    📄 execution 포인트 컷 매개변수    표현식 설명     (..) 가장 기본 설정으로서 매개변수 타입의 제한이 없음을 의미   (*) 반드시 1개의 매개변수를 가지는 메서드만 허용한다는 의미   (com.spring.user.User) 해당 패키지의 클래스를 가지는 메서드만 허용한다는 의미   (!com.spring.user.User) 해당 패키지의 클래스를 가지지 않는 메서드만 허용한다는 의미   (Integer, ..) 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용   (Integer, *) 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용    📗 스프링 AOP 스프링 AOP 는 런타임 위빙을 지원하기에 Proxy 기반의 AOP 구현 기능을 지원한다. 이러한 Proxy 기반의 AOP는 스프링 빈에만 적용가능하기에 빈으로 등록된 대상만 AOP 대상이 된다. 또한, 스프링 AOP 특징상 메서드만을 지원할 수 있다. 프록시 패턴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Primary @Service public class ProxySimpleEventService implements EventService{ private final EventService simpleEventService; ProxySimpleEventService(EventService simpleEventService) { this.simpleEventService = simpleEventService; } @Override public void createEvent() { long begin = System.currentTimeMillis(); simpleEventService.createEvent(); System.out.println(\u0026#34;createEvent 실행시간: \u0026#34;+(System.currentTimeMillis()-begin)); } @Override public void publishEvent() { long begin = System.currentTimeMillis(); simpleEventService.publishEvent(); System.out.println(\u0026#34;createEvent 실행시간: \u0026#34;+(System.currentTimeMillis()-begin)); } @Override public void deleteEvent() { simpleEventService.deleteEvent(); } }   프록시 패턴은 AOP에서 기존 코드의 변경 없이 접근 제어 또는 부가 기능 추가하기 위해 사용된다. 그러나 일반적인 방법으로 프록시 패턴을 구현하면 아래와 같은 문제점이 발생한다. 문제점  매번 Proxy 클래스를 작성해야 한다. 하나의 클래스가 아닌 여러 클래스를 대상으로 적용하기 힘들다. 객체 관계가 복잡해지고 관리하기 어렵다.  이러한 문제점을 해결하기 위해 등장한 것이 바로 Spring AOP와 Dynamic Proxy다. 스프링 IoC 컨테이너가 제공하는 기반 시설과 Dynamic Proxy를 사용하여 여러 복잡한 문제 해결했다.  Dynamic Proxy : 동적으로 프록시 객체 생성하는 방법 JDK Dynamic Proxy : 자바가 제공하는 인터페이스 기반 프록시 생성 라이브러리  CGlib : 자바가 제공하는 클래스 기반 프록시 생성 라이브러리   Spring IoC : 기존 빈을 대체하는 \u0026lsquo;동적 프록시 빈\u0026rsquo;을 만들어 등록한다.  클라이언트 코드 변경이 없다. AbstractAutoProxyCreator implements BeanPostProcessor를 기반으로 만든다. 즉 빈이 생성된 후, 프록시를 생성하는 로직을 수행한다.    이렇듯 런타임시에 동적으로 프록시 빈을 생성하고 AOP를 적용시키는 것을 런타임 위빙이라 부른다. 🔍 런타임 위빙(프록시 위빙) 런타임 위빙은 런타임에 동적으로 Proxy를 생성하여 실제 Target 객체의 변형없이 AOP를 수행하는 것을 의미한다. 스프링을 기준으로 말하자면 메서드만이 JoinPoint가 될 수 있기에 Method 호출 시에 위빙이 이루어 지는 방식이다. 런타임 위빙 또한, 일반적인 Proxy 패턴을 개선한 Dynamic Proxy를 사용하고 있지만 아래와 같은 문제가 있다.  포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다. 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.(프록시이기에)  AOP 프록시 객체 1  org.woowacourse.aoppractice.service.AuthServiceImpl$$EnhancerBySpringCGLIB$$dbdb402d   위 코드를 보면, Target 클래스 자체를 프록시로 감싸는 것을 알 수 있다. 프록시 위빙이 가능한 이유는 상속을 이용한 방식이기에 다형성을 적용시킬 수 있다. 즉, 위 그림에서 AuthController가 AuthService의 프록시 클래스인 AuthService$$블라블라를 참조할 수 있던 것이다. 그런데 한가지 생각해볼 점이 있다. DynamicProxy는 상속/구현을 적용하니 아래와 같은 요소들은 가능할까? 🤔  final 클래스 final 메서드 private 메서드  당연하게도, 자바 문법적으로 상속 및 오버라이딩을 지원하지 못하므로 적용이 되지 않는다. 이와 비슷하게 Spring에서 지원해주는 @Trancsactional 어노테이션이 있는데 @Trancsactional 어노테이션 또한 AOP기반이기에 private 메서드를 붙이면 작동을 하지 않는다. @Trancsactional  로직 시작시 트랜잭션을 열어줌 로직 끝날시 commit하고 트랜잭션을 닫아줌 트랜잭션에 관련된 인프라 로직을 지원하기에 우리는 비즈니스 로직에 집중할 수 있게해준다.   참고 백기선-스프링 프레임워크 핵심 기술 스프링 퀵 스타트 테코톡-스프링 AOP 장인 개발자를 꿈꾸는 : 기록하는 공간 Carrey\u0026rsquo;s 기술블로그 진짜 개발자 기억보단 기록을 리다양의 개발 세상 Carrey\u0026rsquo;s 기술블로그-AspectJ 나중에 참고하면 좋음 논리적 코딩 ","permalink":"https://youngeun-in.github.io/aop/","tags":["spring-aop","dynamic-proxy"],"title":"AOP"},{"categories":["java"],"contents":"서블릿 컨테이너 서블릿 컨테이너는 서블릿을 담아 관리한다. 서블릿은 싱글톤으로 관리된다. 서블릿이 호출되는 과정  Servlet Request / Servlet Response 객체 생성 설정 파일을 참고하여 매핑할 Servlet을 확인  1 2 3 4 5 6 7 8 9  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.jsp.web.MyServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;   해당 서블릿 인스턴스 존재를 유무를 확인하여 없으면 생성(init()) Servlet Container에 스레드를 생성하고, res req를 인자로 service 실행  참고 https://youtu.be/calGCwG_B4Y ","permalink":"https://youngeun-in.github.io/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/","tags":["servlet-container"],"title":"Servlet 동작 방식"},{"categories":["java"],"contents":"Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다. 위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다.  캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다. - 나무위키  Array 는 연속적인 memory block 으로, array 에 처음 접근할 때 전체 array 가 cache 에 로드된다. 첫 액세스 이후로는 공간 지역성이 생기는 것이다. 그러나 java 는 jvm 이 알아서 메모리를 관리 하기 때문에 array 사용시 cache locality 가 적용되는지 여부는 jvm 이 메모리 관리하는 방법을 공부해서 좀 더 알아봐야 할 것 같다. 지금 자세한 설명을 할 지식은 없지만 아마 java 에서는 ‘해당사항 없음’ 이라는 결론이 날 것 같다. ArrayList Java 의 ArrayList 는 AbstractList 를 상속받고 List 인터페이스를 구현한 클래스이다. Array 와 비슷하지만 size 가 dynamic 하게 조절된다. ArrayList.java 코드를 열어보면 default size 는 10 인 것을 알 수 있다. 1  private static final int DEFAULT_CAPACITY = 10;   ArrayList 에서 새로운 element 를 추가하는 메소드는 add() 로, 두 가지 방식의 오버로딩 된 메소드가 정의되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return \u0026lt;tt\u0026gt;true\u0026lt;/tt\u0026gt; (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!!  System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; }   아래에 있는 add() 메소드는 특정 index 에 element 를 삽입하는 메소드로, 어떤 작업을 한 다음에 기존 array 를 copy 한 더 큰 size 를 가진 새로운 array 를 만들어 낸다. 결국 copy 라는 작업이 필요한 것이다. 그럼 매개변수 하나만 받는 위에있는 add() 는 어떻게 동작하는 걸까? 방금 언급한 어떤 작업 에서 ensureCapacityInternal() 메소드가 사이즈 조절을 담당한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); }   ensureCapacityInternal() 메소드로 가보면, 사이즈 조절을 위해 ensureExplicitCapacity() 를 또 호출한다. ensureExplicitCapacity() 메소드에서는 if (minCapacity - elementData.length \u0026gt; 0) 이 if 문에 의해 현재 data 를 담고 있는 array 의 length 가 full 이면 grow() 라는 함수를 호출해서 size 를 늘린다. grow() 함수로 가보면 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  elementData = Arrays.copyOf(elementData, newCapacity); }   int newCapacity = oldCapacity + (oldCapacity \u0026raquo; 1); 여기가 포인트다. 비트연산으로 기존 size 의 1/2 만큼 새로운 capacity 를 할당하도록 한다. oldCapacity 값이 10 (default) 이었다면, 10 \u0026raquo; 1 의 경우 10 의 2진수인 1010(2) 을 1-bit right shifting 한 값인 0101(2) , 즉 10진수 5 만큼 size 를 키우는 것이다. 이렇게 size 키워서 결국 한다는 게 copy 다. 결국 java 에서 제공하는 ArrayList 도 별다른 신박한 방법으로 관리하는 array 가 아니라 그냥 array 인 것이다. 즉, size 가 고정되지 않게 하려면 비용이 많이 든다는 단점이 있는 것은 확실하다. ","permalink":"https://youngeun-in.github.io/array-arraylist/","tags":["array","array-list"],"title":"Array \u0026 ArrayList"},{"categories":["java"],"contents":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. Local Class 중괄호 내에, 특히 메소드 내에 정의 Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","permalink":"https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/","tags":["nested-class"],"title":"자바의 Nested Class"},{"categories":["java"],"contents":"equals 메소드 Object 클래스에 정의된 equals 메소드는 다음과 같다. 1 2 3  public boolean equals(Object obj) { return (this == obj); }   단순히 Object의 ==로 비교하는 것을 확인할 수 있다. 두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다. 1 2 3 4 5 6 7  @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AttachFile that = (AttachFile) o; return Objects.equals(id, that.id) \u0026amp;\u0026amp; Objects.equals(fileName, that.fileName) \u0026amp;\u0026amp; Objects.equals(minutes, that.minutes); }   hashCode 메소드 Object 클래스에 정의된 hashCode 메소드는 인스턴스가 다르면 구성 내용에 상관없이 전혀 다른 해시 값을 반환하도로 정의되어 있다. Object 클래스에 정의된 hashCode 메소드는 다음과 같다. 1 2  @HotSpotIntrinsicCandidate public native int hashCode();   다음은 [hotspot의 jvm.cpp 파일에서 발췌][jvm-cpp-583]한 것이다. 버전은 JDK10 이지만, JDK8과 차이점은 없다. 1 2 3 4 5  JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(\u0026#34;JVM_IHashCode\u0026#34;); // as implemented in the classic virtual machine; return 0 if object is NULL  return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END   [JVM_IHashCode 는 ObjectSynchronizer::FastHashCode][synchronizer-714]를 사용하고 있다. 그리고 이 함수를 잘 읽어보면 새로운 해시 코드 할당은 get_next_hash 함수를 사용한다는 것을 알 수 있다. 다음은 get_next_hash 함수의 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  // hashCode() generation : // // Possibilities: // * MD5Digest of {obj,stwRandom} // * CRC32 of {obj,stwRandom} or any linear-feedback shift register function. // * A DES- or AES-style SBox[] mechanism // * One of the Phi-based schemes, such as: // 2654435761 = 2^32 * Phi (golden ratio) // HashCodeValue = ((uintptr_t(obj) \u0026gt;\u0026gt; 3) * 2654435761) ^ GVars.stwRandom ; // * A variation of Marsaglia\u0026#39;s shift-xor RNG scheme. // * (obj ^ stwRandom) is appealing, but can result // in undesirable regularity in the hashCode values of adjacent objects // (objects allocated back-to-back, in particular). This could potentially // result in hashtable collisions and reduced hashtable efficiency. // There are simple ways to \u0026#34;diffuse\u0026#34; the middle address bits over the // generated hashCode values:  static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG.  // On MP system we\u0026#39;ll have lots of RW access to a global, so the  // mechanism induces lots of coherency traffic.  value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent)  // between STW operations. This can be useful in some of the 1-0  // synchronization schemes.  intptr_t addrBits = cast_from_oop\u0026lt;intptr_t\u0026gt;(obj) \u0026gt;\u0026gt; 3; value = addrBits ^ (addrBits \u0026gt;\u0026gt; 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing  } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop\u0026lt;intptr_t\u0026gt;(obj); } else { // Marsaglia\u0026#39;s xor-shift scheme with thread-specific state  // This is probably the best overall implementation -- we\u0026#39;ll  // likely make this the default in future releases.  unsigned t = Self-\u0026gt;_hashStateX; t ^= (t \u0026lt;\u0026lt; 11); Self-\u0026gt;_hashStateX = Self-\u0026gt;_hashStateY; Self-\u0026gt;_hashStateY = Self-\u0026gt;_hashStateZ; Self-\u0026gt;_hashStateZ = Self-\u0026gt;_hashStateW; unsigned v = Self-\u0026gt;_hashStateW; v = (v ^ (v \u0026gt;\u0026gt; 19)) ^ (t ^ (t \u0026gt;\u0026gt; 8)); Self-\u0026gt;_hashStateW = v; value = v; } value \u0026amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, \u0026#34;invariant\u0026#34;); return value; }   equals와 hashCode는 왜 같이 재정의해야 할까? hash 값을 사용하는 Collection(HashMap, HashSet, HashTable)은 객체가 논리적으로 같은지 비교할 때 아래 그림과 같은 과정을 거친다. hashCode 메소드의 반환값을 이용해서 검색의 범위를 확 줄여버리고, 해당 부류 내에 존재하는 데이터의 내용 비교는 equals 메소드를 통해서 진행한다. Object 클래스의 hashCode 메서드는 객체의 고유한 주소 값을 int 값으로 변환하기 때문에 객체마다 다른 값을 리턴한다. 두 개의 Car 객체는 equals로 비교도 하기 전에 서로 다른 hashCode 메서드의 리턴 값으로 인해 다른 객체로 판단된 것이다. 성능에 아주 민감하지 않은 대부분의 프로그램은 간편하게 Objects.hash 메서드를 사용해서 hashCode 메서드를 재정의해도 문제없다. 민감한 경우에는 직접 재정의해주는 게 좋다. 1 2 3 4  @Override public int hashCode() { return Objects.hash(id, fileName, minutes); }   Objects 클래스에 정의된 hash 메소드는 다음과 같다. 1 2 3  public static int hash(Object... values) { return Arrays.hashCode(values); }   Arrays 클래스에 정의된 hashCode 메소드는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11  public static int hashCode(Object a[]) { if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; }   ","permalink":"https://youngeun-in.github.io/equals%EC%99%80-hashcode/","tags":["equals","hashcode"],"title":"equals와 hashCode"},{"categories":["java"],"contents":"Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다. 1 2 3  public interface Comparable\u0026lt;T\u0026gt; { int compareTo(T obj); }   사용 예시는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable\u0026lt;Person\u0026gt; { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void showData() { System.out.printf(\u0026#34;%s %d \\n\u0026#34;, name, age); } public int compareTo(Person p) { if (age \u0026gt; p.age) return 1; else if (age \u0026lt; p.age) return -1; else return 0; } } class ComparablePerson { public static void main(String[] args) { TreeSet\u0026lt;Person\u0026gt; sTree = new TreeSet\u0026lt;Person\u0026gt;(); sTree.add(new Person(\u0026#34;Lee\u0026#34;, 24)); sTree.add(new Person(\u0026#34;Hong\u0026#34;, 29)); sTree.add(new Person(\u0026#34;Choi\u0026#34;, 21)); Iterator\u0026lt;Person\u0026gt; itr = sTree.iterator(); while (itr.hasNext()) itr.next().showData(); } }   Comparator 인터페이스 String 클래스는 이미 compareTo 메소드를 구현하고 있다. 이 때 정령기준을 변경하기 위해서 String 클래스를 상속하는 클래스를 새로 정의하는 것은 번거롭다 따라서 새로운 정렬 기준을 파라미터로 넘길 수 있도록 정의된 것이 Comparator 인터페이스이다. 1 2 3  public interface Comparator\u0026lt;T\u0026gt; { int compare(T o1, T o2); }   사용 예시는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  import java.util.TreeSet; import java.util.Iterator; import java.util.Comparator; class StrLenComparator implements Comparator\u0026lt;String\u0026gt; { public int compare(String str1, String str2) { if (str1.length() \u0026gt; str2.length()) return 1; else if (str1.length() \u0026lt; str2.length()) return -1; else return 0; /* * return str1.length()-str2.length(); */ } } class IntroComparator { public static void main(String[] args) { TreeSet\u0026lt;String\u0026gt; tSet = new TreeSet\u0026lt;String\u0026gt;(new StrLenComparator()); tSet.add(\u0026#34;Orange\u0026#34;); tSet.add(\u0026#34;Apple\u0026#34;); tSet.add(\u0026#34;Dog\u0026#34;); tSet.add(\u0026#34;Individual\u0026#34;); Iterator\u0026lt;String\u0026gt; itr = tSet.iterator(); while (itr.hasNext()) System.out.println(itr.next()); } }   ","permalink":"https://youngeun-in.github.io/comparable-and-comparator/","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이"},{"categories":["spring"],"contents":"Spring의 대표적인 핵심가치 3가지로 IoC, AOP, PSA가 있다. PSA (Portable Service Abstraction) @Transactional 어노테이션을 선언하는 것 만으로 별도의 코드 추가 없이 트랜잭션 서비스를 사용할 수 있다. 내부적으로 트랜잭션 코드가 추상화되어 숨겨져 있는 것이다. 이렇게 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이며, 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다. PSA의 원리 트랜잭션을 예로 들어 설명하겠다. 위 그림처럼 Spring의 @Transactional은 각 TransactionManager를 각각 구현하고 있는 것이 아니라 최상위 PlatformTransactionManager를 이용하고 필요한 TransactionManager를 DI로 주입받아 사용하고 있다. PlatformTransactionManager 인터페이스의 소스코드는 다음과 같다. 1 2 3 4 5 6 7 8  public interface PlatformTransactionManager extends TransactionManager { TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException; }   ","permalink":"https://youngeun-in.github.io/spring-psa/","tags":["PSA"],"title":"Spring PSA"},{"categories":["design pattern"],"contents":"프록시 패턴 Proxy는 우리말로 대리자, 대변인 이라는 뜻이다. 대리자, 대변인은 다른 누군가를 대신해서 그 역할을 수행하는 존재를 말한다. 프록시는 타겟의 기능을 확장하거나 타깃에 대한 접근을 제어하기 위한 목적으로 사용된다. 상속을 사용한 구현 아래와 같은 타겟 클래스가 있다고 하자. 1 2 3 4 5  public class GameService { public void startGame() { System.out.println(\u0026#34;Hello\u0026#34;); } }   다음과 같이 프록시 클래스가 타겟 클래스를 상속받도록 만든다. 1 2 3 4 5 6 7 8 9  public class GameServiceProxy extends GameService { @Override public void startGame() { long before = System.currentTimeMillis(); //상위 메소드 실행  super.startGame(); System.out.println(System.currentTimeMillis() - before); } }   1 2 3 4 5 6  public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(); gameService.startGame(); } }   결과는 다음과 같다. 1 2  Hello 0   인터페이스를 사용한 구현 인터페이스를 사용할 경우, 좀 더 구조가 유연하며 테스트하기에도 쉽다. 다음과 같이 인터페이스를 선언한다. 1 2 3  public interface GameService { void startGame(); }   인터페이스를 구현한 클래스를 만들고, 메소드를 오버라이드한다. 1 2 3 4 5 6  public class DefaultGameService implements GameService{ @Override public void startGame() { System.out.println(\u0026#34;Hello\u0026#34;); } }   다음과 같이 프록시 클래스를 선언한다. 1 2 3 4 5 6 7 8 9 10 11 12  @RequiredArgsConstructor public class GameServiceProxy implements GameService { //GameService를 외부에서 주입받는다.  private final GameService gameService; @Override public void startGame() { long before = System.currentTimeMillis(); gameService.startGame(); System.out.println(System.currentTimeMillis() - before); } }   클라이언트에서는 GameService 구현체를 생성하여 프록시 객체에 넘겨준다. 1 2 3 4 5 6  public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(new DefaultGameService()); gameService.startGame(); } }   다이나믹 프록시 프록시 패턴의 단점은 다음과 같다.  인터페이스를 직접 구현해야 한다. 프록시 클래스 내에 중복이 발생한다.  위와 같은 문제는 다이나믹 프록시를 사용하여 해결할 수 있다. Dynamic Proxy는 런타임 시점에 인터페이스를 구현하는 클래스 또는 인스턴스를 만드는 기술을 말한다. 다이나믹 프록시를 사용하면, 일일이 구현해야한다는 문제는 reflection API가 해결해주고, 중복은 InvocationHandler가 해결해준다. InvocationHandler의 invoke() 메소드에서 타겟의 어떤 메소드에 적용할지 검사하고, 적용해야 하는 메소드라면 타겟의 원래 메소드를 호출하여 결과를 담아둔 뒤 추가 기능을 적용하여 리턴한다. 적용하지 말아야 하는 메소드라면 타겟의 원래 메소드의 리턴을 그대로 리턴한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  BookService bookService = (BookService) Proxy.newProxyInstance(BookService.class.getClassLoader(), new Class[]{BookService.class}, new InvocationHandler() { BookService bookService = new RealSubjectBookService(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName() == \u0026#34;rent\u0026#34;) { System.out.println(\u0026#34;11111\u0026#34;); Object invoke = method.invoke(bookService, args); System.out.println(\u0026#34;22222\u0026#34;); return invoke; } return method.invoke(bookService, args); } });   Proxy.newProxyInstance 메소드를 이용해 프록시 객체를 생성한다.  첫번째 인자는 프록시 객체를 생성할 인터페이스 타입의 클래스로더 두번째 인자는 해당 프록시가 어떤 인터페이스를 구현체인가 3번째 인자는 이를 구현하는 InvocationHandler 이다.  InvocationHandler는 invoke 메소드를 구현한다.  첫번째 인자는 newProxyInstance를 사용해 생성된 프록시 객체의 참조 두번째 인자는 프록시를 통해 호출된 메소드의 참조 세번째 인자는 해당 메소드의 파라메터들의 참조  invoke 메소드 내에서 method.invoke 를 통해 메소드를 호출할 수 있다. 만약 프록시 객체를 통해 부가적인 기능을 추가하고싶다면 invoke 메소드 내에서 구현을 해주면 된다. ","permalink":"https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/","tags":["dynamic-proxy"],"title":"프록시 패턴"},{"categories":["java"],"contents":"데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다. 결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다. 이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public enum PayType { ACCOUNT_TRANSFER(\u0026#34;계좌이체\u0026#34;), REMITTANCE(\u0026#34;무통장입금\u0026#34;), ON_SITE_PAYMENT(\u0026#34;현장결제\u0026#34;), TOSS(\u0026#34;토스\u0026#34;), PAYCO(\u0026#34;페이코\u0026#34;), CARD(\u0026#34;신용카드\u0026#34;), KAKAO_PAY(\u0026#34;카카오페이\u0026#34;), BAEMIN_PAY(\u0026#34;배민페이\u0026#34;), POINT(\u0026#34;포인트\u0026#34;), COUPON(\u0026#34;쿠폰\u0026#34;); private final String title; PayType(String title) { this.title = title; } public String getTitle() { return title; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import lombok.Getter; import java.util.Arrays; import java.util.Collections; import java.util.List; @Getter public enum PayGroup { CASH(\u0026#34;현금\u0026#34;, Arrays.asList(PayType.ACCOUNT_TRANSFER, PayType.REMITTANCE, PayType.ON_SITE_PAYMENT, PayType.TOSS)), CARD(\u0026#34;카드\u0026#34;, Arrays.asList(PayType.PAYCO, PayType.CARD, PayType.KAKAO_PAY, PayType.BAEMIN_PAY)), ETC(\u0026#34;기타\u0026#34;, Arrays.asList(PayType.POINT, PayType.COUPON)), EMPTY(\u0026#34;없음\u0026#34;, Collections.EMPTY_LIST); private final String title; private final List\u0026lt;PayType\u0026gt; payList; PayGroup(String title, List\u0026lt;PayType\u0026gt; payList) { this.title = title; this.payList = payList; } public static PayGroup findByPayType(PayType payType){ return Arrays.stream(PayGroup.values()) .filter(payGroup -\u0026gt; payGroup.hasPayType(payType)) .findAny() .orElse(EMPTY); } private boolean hasPayType(PayType payType){ return payList.stream() .anyMatch(pay -\u0026gt; pay == payType); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PayGroupTest { @Test public void PayGroup에게_직접_결제종류_물어보기_PayType () { PayType payType = selectPayType(); PayGroup payGroup = PayGroup.findByPayType(payType); assertEquals(payGroup.name(), \u0026#34;CARD\u0026#34;); assertEquals(payGroup.getTitle(), \u0026#34;카드\u0026#34;); } private PayType selectPayType(){ return PayType.BAEMIN_PAY; } }   DB 혹은 API에서 PayType으로 데이터를 받아, 타입 안전성까지 확보하여 PayGroup 관련된 처리를 진행할 수 있게 되었다. 참고 https://github.com/jojoldu/blog-code/tree/master/enum-settler ","permalink":"https://youngeun-in.github.io/enum-usage-2/","tags":["enum"],"title":"Enum 사용 (활용)"},{"categories":["java"],"contents":"상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 \u0026ldquo;CALC_A\u0026quot;일 경우엔 값 그대로, \u0026ldquo;CALC_B\u0026quot;일 경우엔 10 한 값을, \u0026ldquo;CALC_C\u0026quot;일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 \u0026ldquo;DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.\u0026ldquo;는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import java.util.function.Function; public enum CalculatorType { CALC_A(value -\u0026gt; value), CALC_B(value -\u0026gt; value * 10), CALC_C(value -\u0026gt; value * 30), CALC_ETC(value -\u0026gt; 0L); private Function\u0026lt;Long, Long\u0026gt; expression; CalculatorType(Function\u0026lt;Long, Long\u0026gt; expression) { this.expression = expression; } public long calculate(long value) { return expression.apply(value); } }   1 2 3 4 5 6 7 8 9 10  import javax.persistence.Column; import javax.persistence.EnumType; import javax.persistence.Enumerated; public class Entity { @Column //@Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다.  @Enumerated(EnumType.STRING) private CalculatorType calculatorType; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.testng.annotations.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTypeTest { private CalculatorType selectType() { return CalculatorType.CALC_B; } @Test public void 코드에_따라_서로다른_계산하기_Enum() { CalculatorType code = selectType(); long originValue = 10000L; long result = code.calculate(originValue); assertEquals(result, 100000L); } }   값(상태)과 메소드(행위)가 어떤 관계가 있는지에 대해 더이상 다른 곳을 찾을 필요가 없게 되었다. 코드내에 전부 표현되어 있고, Enum 상수에게 직접 물어보면 되기 때문이다. ","permalink":"https://youngeun-in.github.io/enum-usage-1/","tags":["enum"],"title":"Enum 사용 (개념)"},{"categories":["ML"],"contents":"Step Function 활성화 함수는 신경망의 행동을 결정하는 중요한 역할을 합니다. 가장 간단한 형태의 활성화 함수는 계단 함수(Step function) 라고 합니다. 계단 함수는 입력값의 합이 임계값을 넘으면 $0$ 을, 넘지 못하면 $1$ 을 출력하게 됩니다. 계단 함수의 그래프는 다음과 같이 생겼습니다. 이미지 출처 : wikipedia - Heaviside step function 계단 함수는 활성화 함수의 조건을 가장 잘 만족하는 함수이고 직관적으로도 이해하기 쉽습니다. 하지만 불연속 함수라는 단점 때문에 실제 신경망에 사용되지는 않습니다. 그래프를 보면 알 수 있듯 임계값 지점에서 불연속점을 갖게 되는데 이 점에서 미분이 불가능하기 때문에 학습이 필요한 신경망에 사용할 수 없습니다. 이런 문제점을 해결하기 위해서 등장한 것이 시그모이드 함수(Sigmoid) 입니다. Sigmoid Function 시그모이드 함수는 기본적으로 $S$ 모양을 그리는 곡선 함수를 통칭하여 부르는 말입니다. 이 중 대표적인 함수는 로지스틱(Logistic) 함수와 하이퍼탄젠트(Hyper tangent, $\\tanh$) 함수가 있습니다. 두 함수의 수식과 그래프를 보며 시그모이드 함수와 계단 함수가 다른 점이 무엇인지 알아보도록 하겠습니다. 로지스틱 함수(Logistic Function) $$ \\text{Logistic} : \\frac{1}{1+e^{-x}} $$ 이미지 출처 : wikipedia - Logistic function 하이퍼탄젠트 함수(Hypertangent Function) $$ \\text{Hypertangent} : \\frac{e^x-e^{-x}}{e^x+e^{-x}} = \\frac{e^{2x}-1}{e^{2x}+1} $$ 이미지 출처 : mathworld.wolfram.com 두 함수는 모두 연속함수입니다. 계단 함수의 치명적인 단점이었던 불연속을 해결했지요. 계단 함수와 시그모이드 함수의 중요한 공통점은 비선형 함수(Non-linear) 라는 점입니다. 활성화 함수는 비선형 함수를 사용해야 합니다. 활성화 함수가 선형 함수이면 안되는 이유는 무엇일까요? 선형인 활성화 함수 $l(x) = ax + b$ 가 있다고 해보겠습니다. 이 함수를 사용하여 3개의 층을 쌓는다면 최종적인 활성화 함수는 $l(l(l(x))) = l^3(x) = a(a(ax+b)+b)+b = a^3x+a^2b+ab+b$가 됩니다. $a^3 = c, d = a^2b+ab+b$라고 하면 $l^3(x) = cx+d$로 여전히 같은 형태의 함수를 사용하게 됩니다. 이렇듯 층을 아무리 깊게 쌓아도 여러 층을 쌓는 이점을 살리지 못하게 되지요. 여러 층을 쌓을 때의 장점을 살리기 위해 비선형 함수를 사용하게 되는 것이지요. ReLU Function 시그모이드 함수는 불연속이라는 계단 함수의 단점을 해결했습니다. 하지만 시그모이드는 대부분의 점에서 기울기 값이 0이 됩니다. 이 때문에 **기울기 소실(Gradient vanishing)**이라는 문제가 발생합니다. 기울기 소실은 시그모이드 함수를 활성화 함수로 사용하여 층을 깊게 쌓았을 때 학습이 잘 되지 않는 현상입니다. 이런 현상이 왜 발생하는지 알아보겠습니다. 로지스틱 함수 $L(x)$를 미분한 함수 $L^\\prime(x)$ 의 수식은 다음과 같습니다. $$ L^\\prime(x) = \\bigg(\\frac{1}{1+e^{-x}}\\bigg)^\\prime = \\frac{e^x}{(1+e^{-x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 그래프에서 볼 수 있듯 최댓값이 $0.25$ 밖에 되지 않고 $x\u0026lt;-5, x\u0026gt;5$ 범위에서는 거의 $0$ 에 가깝습니다. 역전파(Back propagation) 과정에서는 미분값을 사용하여 학습을 하게 됩니다. 따라서 이 값이 0에 가까워 지면 정보가 유실되면서 학습이 잘 안되게 됩니다. 특히 층을 깊게 쌓을 경우에는 정보가 모두 유실되는 사태가 발생하게 되지요. 그렇다면 하이퍼탄젠트 함수는 어떻게 될까요? 하이퍼탄젠트 함수 $\\tanh$를 미분한 함수의 수식은 다음과 같습니다. $$ \\tanh^\\prime(x) = \\bigg(\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\bigg)^\\prime = \\frac{4e^{2x}}{(1+e^{2x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 하이퍼탄젠트 함수를 미분한 함수의 최댓값은 $1$ 입니다. 최댓값이 $0.25$ 밖에 안되었던 로지스틱 함수 보다는 정보를 잘 전달하게 되지요. 하지만 여전히 $x$ 가 0에서 멀어질수록 원래 함수의 미분값은 0에 가까워집니다. 그래서 하이퍼탄젠트 함수를 활성화 함수로 하더라도 퍼셉트론을 여러 층으로 쌓는다면 학습이 제대로 안되게 되지요. 이렇게 시그모이드 함수를 활성화 함수로 사용할 때 역전파시 학습이 제대로 진행되지 않는 현상을 기울기 소실이라고 합니다. 기울기 소실 문제를 극복하기 위해서 등장한 함수가 바로 ReLU(Rectified Linear Unit)함수입니다. ReLU함수는 입력값이 0보다 작을 경우에는 0을 반환하고, 0보다 클 경우에는 입력값을 그대로 반환합니다. 아래는 ReLU함수의 그래프를 나타낸 것입니다. 이미지 출처 : medium.com ReLU함수는 $x$ 가 $0$ 보다 클 때, 미분값이 항상 $1$ 입니다. 그래서 층이 아무리 깊어져도 손실없이 정보를 전달할 수 있습니다. 미분값이 항상 $0$과 $1$ 이기 때문에 연산이 빠르다는 점도 ReLU함수의 장점입니다. 덕분에 ReLU함수는 은닉층에서 가장 많이 사용되는 활성화 함수가 되었습니다. 물론 ReLU함수에게도 문제가 있습니다. 0이하의 값이 그대로 보존되지 않고 버려진다는 것이지요. 이를 보완하기 위해 Leaky ReLU함수가 고안되어 사용되고 있습니다. 일반적으로는 $a=0.01$을 사용하며 그래프는 다음과 같습니다. 이미지 출처 : medium.com ","permalink":"https://youngeun-in.github.io/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/","tags":["step-function","sigmoid","relu"],"title":"활성화 함수"},{"categories":["spring"],"contents":"Spring mocking 없이 테스트하려면? 아래 코드를 mocking 없이 테스트하려면 어떻게 해야 할까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import java.io.IOException; public class RepositoryRank { public int getPoint(String repositoryName) throws IOException { GitHub github = GitHub.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u0026gt; 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public static void main(String[] args) throws IOException { RepositoryRank repositoryRank = new RepositoryRank(); int point = repositoryRank.getPoint(\u0026#34;whiteship/live-study\u0026#34;); System.out.println(point); } }   Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입하면 된다. 설명과 코드는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import org.kohsuke.github.GitHubBuilder; import java.io.IOException; public class RepositoryRank { //인터페이스 선언  interface GitHubService { GitHub connect() throws IOException; } //인터페이스를 구현한 클래스 생성하고 모킹하고자 하는 메소드를 오버라이드한다.  static class DefaultGitHubService implements GitHubService { @Override public GitHub connect() throws IOException { return new GitHubBuilder().build(); } } private final GitHubService gitHubService; //서비스를 주입받는다.  public RepositoryRank(GitHubService gitHubService) { this.gitHubService = gitHubService; } public int getPoint(String repositoryName) throws IOException { GitHub github = gitHubService.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u0026gt; 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public void main(String[] args) throws IOException { GitHubService gitHubService = new DefaultGitHubService(); //Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입  RepositoryRank repositoryRank = new RepositoryRank(gitHubService); int point = repositoryRank.getPoint(\u0026#34;whiteship/live-study\u0026#34;); System.out.println(point); } }   참고 백기선님의 유튜브를 참고했다. https://youtu.be/bJfbPWEMj_c ","permalink":"https://youngeun-in.github.io/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법"},{"categories":null,"contents":"","permalink":"https://youngeun-in.github.io/search/","tags":null,"title":"Search"}]