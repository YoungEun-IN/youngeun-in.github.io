[{"categories":["java"],"contents":"Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다. 위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다.  캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다. - 나무위키  Array 는 연속적인 memory block 으로, array 에 처음 접근할 때 전체 array 가 cache 에 로드된다. 첫 액세스 이후로는 공간 지역성이 생기는 것이다. 그러나 java 는 jvm 이 알아서 메모리를 관리 하기 때문에 array 사용시 cache locality 가 적용되는지 여부는 jvm 이 메모리 관리하는 방법을 공부해서 좀 더 알아봐야 할 것 같다. 지금 자세한 설명을 할 지식은 없지만 아마 java 에서는 ‘해당사항 없음’ 이라는 결론이 날 것 같다. ArrayList Java 의 ArrayList 는 AbstractList 를 상속받고 List 인터페이스를 구현한 클래스이다. Array 와 비슷하지만 size 가 dynamic 하게 조절된다. ArrayList.java 코드를 열어보면 default size 는 10 인 것을 알 수 있다. 1  private static final int DEFAULT_CAPACITY = 10;   ArrayList 에서 새로운 element 를 추가하는 메소드는 add() 로, 두 가지 방식의 오버로딩 된 메소드가 정의되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return \u0026lt;tt\u0026gt;true\u0026lt;/tt\u0026gt; (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!!  System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; }   아래에 있는 add() 메소드는 특정 index 에 element 를 삽입하는 메소드로, 어떤 작업을 한 다음에 기존 array 를 copy 한 더 큰 size 를 가진 새로운 array 를 만들어 낸다. 결국 copy 라는 작업이 필요한 것이다. 그럼 매개변수 하나만 받는 위에있는 add() 는 어떻게 동작하는 걸까? 방금 언급한 어떤 작업 에서 ensureCapacityInternal() 메소드가 사이즈 조절을 담당한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); }   ensureCapacityInternal() 메소드로 가보면, 사이즈 조절을 위해 ensureExplicitCapacity() 를 또 호출한다. ensureExplicitCapacity() 메소드에서는 if (minCapacity - elementData.length \u0026gt; 0) 이 if 문에 의해 현재 data 를 담고 있는 array 의 length 가 full 이면 grow() 라는 함수를 호출해서 size 를 늘린다. grow() 함수로 가보면 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  elementData = Arrays.copyOf(elementData, newCapacity); }   int newCapacity = oldCapacity + (oldCapacity \u0026raquo; 1); 여기가 포인트다. 비트연산으로 기존 size 의 1/2 만큼 새로운 capacity 를 할당하도록 한다. oldCapacity 값이 10 (default) 이었다면, 10 \u0026raquo; 1 의 경우 10 의 2진수인 1010(2) 을 1-bit right shifting 한 값인 0101(2) , 즉 10진수 5 만큼 size 를 키우는 것이다. 이렇게 size 키워서 결국 한다는 게 copy 다. 결국 java 에서 제공하는 ArrayList 도 별다른 신박한 방법으로 관리하는 array 가 아니라 그냥 array 인 것이다. 즉, size 가 고정되지 않게 하려면 비용이 많이 든다는 단점이 있는 것은 확실하다. ","permalink":"https://youngeun-in.github.io/array-arraylist/","tags":["array","array-list"],"title":"Array \u0026 ArrayList"},{"categories":["java"],"contents":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. Local Class 중괄호 내에, 특히 메소드 내에 정의 Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","permalink":"https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/","tags":["nested-class"],"title":"자바의 Nested Class"},{"categories":["java"],"contents":"Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다. 1 2 3  public interface Comparable\u0026lt;T\u0026gt; { int compareTo(T obj); }   사용 예시는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable\u0026lt;Person\u0026gt; { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void showData() { System.out.printf(\u0026#34;%s %d \\n\u0026#34;, name, age); } public int compareTo(Person p) { if (age \u0026gt; p.age) return 1; else if (age \u0026lt; p.age) return -1; else return 0; } } class ComparablePerson { public static void main(String[] args) { TreeSet\u0026lt;Person\u0026gt; sTree = new TreeSet\u0026lt;Person\u0026gt;(); sTree.add(new Person(\u0026#34;Lee\u0026#34;, 24)); sTree.add(new Person(\u0026#34;Hong\u0026#34;, 29)); sTree.add(new Person(\u0026#34;Choi\u0026#34;, 21)); Iterator\u0026lt;Person\u0026gt; itr = sTree.iterator(); while (itr.hasNext()) itr.next().showData(); } }   Comparator 인터페이스 String 클래스는 이미 compareTo 메소드를 구현하고 있다. 이 때 정령기준을 변경하기 위해서 String 클래스를 상속하는 클래스를 새로 정의하는 것은 번거롭다 따라서 새로운 정렬 기준을 파라미터로 넘길 수 있도록 정의된 것이 Comparator 인터페이스이다. 1 2 3  public interface Comparator\u0026lt;T\u0026gt; { int compare(T o1, T o2); }   사용 예시는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  import java.util.TreeSet; import java.util.Iterator; import java.util.Comparator; class StrLenComparator implements Comparator\u0026lt;String\u0026gt; { public int compare(String str1, String str2) { if (str1.length() \u0026gt; str2.length()) return 1; else if (str1.length() \u0026lt; str2.length()) return -1; else return 0; /* * return str1.length()-str2.length(); */ } } class IntroComparator { public static void main(String[] args) { TreeSet\u0026lt;String\u0026gt; tSet = new TreeSet\u0026lt;String\u0026gt;(new StrLenComparator()); tSet.add(\u0026#34;Orange\u0026#34;); tSet.add(\u0026#34;Apple\u0026#34;); tSet.add(\u0026#34;Dog\u0026#34;); tSet.add(\u0026#34;Individual\u0026#34;); Iterator\u0026lt;String\u0026gt; itr = tSet.iterator(); while (itr.hasNext()) System.out.println(itr.next()); } }   ","permalink":"https://youngeun-in.github.io/comparable-and-comparator/","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이"},{"categories":["spring"],"contents":"Spring의 대표적인 핵심가치 3가지로 IoC, AOP, PSA가 있다. PSA (Portable Service Abstraction) @Transactional 어노테이션을 선언하는 것 만으로 별도의 코드 추가 없이 트랜잭션 서비스를 사용할 수 있다. 내부적으로 트랜잭션 코드가 추상화되어 숨겨져 있는 것이다. 이렇게 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이며, 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다. PSA의 원리 트랜잭션을 예로 들어 설명하겠다. 위 그림처럼 Spring의 @Transactional은 각 TransactionManager를 각각 구현하고 있는 것이 아니라 최상위 PlatformTransactionManager를 이용하고 필요한 TransactionManager를 DI로 주입받아 사용하고 있다. PlatformTransactionManager 인터페이스의 소스코드는 다음과 같다. 1 2 3 4 5 6 7 8  public interface PlatformTransactionManager extends TransactionManager { TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException; }   ","permalink":"https://youngeun-in.github.io/spring-psa/","tags":["PSA"],"title":"Spring PSA"},{"categories":["design pattern"],"contents":"프록시 패턴 Proxy는 우리말로 대리자, 대변인 이라는 뜻이다. 대리자, 대변인은 다른 누군가를 대신해서 그 역할을 수행하는 존재를 말한다. 프록시는 타겟의 기능을 확장하거나 타깃에 대한 접근을 제어하기 위한 목적으로 사용된다. 상속을 사용한 구현 아래와 같은 타겟 클래스가 있다고 하자. 1 2 3 4 5  public class GameService { public void startGame() { System.out.println(\u0026#34;Hello\u0026#34;); } }   다음과 같이 프록시 클래스가 타겟 클래스를 상속받도록 만든다. 1 2 3 4 5 6 7 8 9  public class GameServiceProxy extends GameService { @Override public void startGame() { long before = System.currentTimeMillis(); //상위 메소드 실행  super.startGame(); System.out.println(System.currentTimeMillis() - before); } }   1 2 3 4 5 6  public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(); gameService.startGame(); } }   결과는 다음과 같다. 1 2  Hello 0   인터페이스를 사용한 구현 인터페이스를 사용할 경우, 좀 더 구조가 유연하며 테스트하기에도 쉽다. 다음과 같이 인터페이스를 선언한다. 1 2 3  public interface GameService { void startGame(); }   인터페이스를 구현한 클래스를 만들고, 메소드를 오버라이드한다. 1 2 3 4 5 6  public class DefaultGameService implements GameService{ @Override public void startGame() { System.out.println(\u0026#34;Hello\u0026#34;); } }   다음과 같이 프록시 클래스를 선언한다. 1 2 3 4 5 6 7 8 9 10 11 12  @RequiredArgsConstructor public class GameServiceProxy implements GameService { //GameService를 외부에서 주입받는다.  private final GameService gameService; @Override public void startGame() { long before = System.currentTimeMillis(); gameService.startGame(); System.out.println(System.currentTimeMillis() - before); } }   클라이언트에서는 GameService 구현체를 생성하여 프록시 객체에 넘겨준다. 1 2 3 4 5 6  public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(new DefaultGameService()); gameService.startGame(); } }   다이나믹 프록시 프록시 패턴의 단점은 다음과 같다.  인터페이스를 직접 구현해야 한다. 프록시 클래스 내에 중복이 발생한다.  위와 같은 문제는 다이나믹 프록시를 사용하여 해결할 수 있다. Dynamic Proxy는 런타임 시점에 인터페이스를 구현하는 클래스 또는 인스턴스를 만드는 기술을 말한다. 다이나믹 프록시를 사용하면, 일일이 구현해야한다는 문제는 reflection API가 해결해주고, 중복은 InvocationHandler가 해결해준다. InvocationHandler의 invoke() 메소드에서 타겟의 어떤 메소드에 적용할지 검사하고, 적용해야 하는 메소드라면 타겟의 원래 메소드를 호출하여 결과를 담아둔 뒤 추가 기능을 적용하여 리턴한다. 적용하지 말아야 하는 메소드라면 타겟의 원래 메소드의 리턴을 그대로 리턴한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  BookService bookService = (BookService) Proxy.newProxyInstance(BookService.class.getClassLoader(), new Class[]{BookService.class}, new InvocationHandler() { BookService bookService = new RealSubjectBookService(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName() == \u0026#34;rent\u0026#34;) { System.out.println(\u0026#34;11111\u0026#34;); Object invoke = method.invoke(bookService, args); System.out.println(\u0026#34;22222\u0026#34;); return invoke; } return method.invoke(bookService, args); } });   Proxy.newProxyInstance 메소드를 이용해 프록시 객체를 생성한다.  첫번째 인자는 프록시 객체를 생성할 인터페이스 타입의 클래스로더 두번째 인자는 해당 프록시가 어떤 인터페이스를 구현체인가 3번째 인자는 이를 구현하는 InvocationHandler 이다.  InvocationHandler는 invoke 메소드를 구현한다.  첫번째 인자는 newProxyInstance를 사용해 생성된 프록시 객체의 참조 두번째 인자는 프록시를 통해 호출된 메소드의 참조 세번째 인자는 해당 메소드의 파라메터들의 참조  invoke 메소드 내에서 method.invoke 를 통해 메소드를 호출할 수 있다. 만약 프록시 객체를 통해 부가적인 기능을 추가하고싶다면 invoke 메소드 내에서 구현을 해주면 된다. ","permalink":"https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/","tags":["proxy"],"title":"프록시 패턴"},{"categories":["java"],"contents":"데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다. 결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다. 이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public enum PayType { ACCOUNT_TRANSFER(\u0026#34;계좌이체\u0026#34;), REMITTANCE(\u0026#34;무통장입금\u0026#34;), ON_SITE_PAYMENT(\u0026#34;현장결제\u0026#34;), TOSS(\u0026#34;토스\u0026#34;), PAYCO(\u0026#34;페이코\u0026#34;), CARD(\u0026#34;신용카드\u0026#34;), KAKAO_PAY(\u0026#34;카카오페이\u0026#34;), BAEMIN_PAY(\u0026#34;배민페이\u0026#34;), POINT(\u0026#34;포인트\u0026#34;), COUPON(\u0026#34;쿠폰\u0026#34;); private final String title; PayType(String title) { this.title = title; } public String getTitle() { return title; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import lombok.Getter; import java.util.Arrays; import java.util.Collections; import java.util.List; @Getter public enum PayGroup { CASH(\u0026#34;현금\u0026#34;, Arrays.asList(PayType.ACCOUNT_TRANSFER, PayType.REMITTANCE, PayType.ON_SITE_PAYMENT, PayType.TOSS)), CARD(\u0026#34;카드\u0026#34;, Arrays.asList(PayType.PAYCO, PayType.CARD, PayType.KAKAO_PAY, PayType.BAEMIN_PAY)), ETC(\u0026#34;기타\u0026#34;, Arrays.asList(PayType.POINT, PayType.COUPON)), EMPTY(\u0026#34;없음\u0026#34;, Collections.EMPTY_LIST); private final String title; private final List\u0026lt;PayType\u0026gt; payList; PayGroup(String title, List\u0026lt;PayType\u0026gt; payList) { this.title = title; this.payList = payList; } public static PayGroup findByPayType(PayType payType){ return Arrays.stream(PayGroup.values()) .filter(payGroup -\u0026gt; payGroup.hasPayType(payType)) .findAny() .orElse(EMPTY); } private boolean hasPayType(PayType payType){ return payList.stream() .anyMatch(pay -\u0026gt; pay == payType); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PayGroupTest { @Test public void PayGroup에게_직접_결제종류_물어보기_PayType () { PayType payType = selectPayType(); PayGroup payGroup = PayGroup.findByPayType(payType); assertEquals(payGroup.name(), \u0026#34;CARD\u0026#34;); assertEquals(payGroup.getTitle(), \u0026#34;카드\u0026#34;); } private PayType selectPayType(){ return PayType.BAEMIN_PAY; } }   DB 혹은 API에서 PayType으로 데이터를 받아, 타입 안전성까지 확보하여 PayGroup 관련된 처리를 진행할 수 있게 되었다. 참고 https://github.com/jojoldu/blog-code/tree/master/enum-settler ","permalink":"https://youngeun-in.github.io/enum-usage-2/","tags":["enum"],"title":"Enum 사용 (활용)"},{"categories":["java"],"contents":"상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 \u0026ldquo;CALC_A\u0026quot;일 경우엔 값 그대로, \u0026ldquo;CALC_B\u0026quot;일 경우엔 10 한 값을, \u0026ldquo;CALC_C\u0026quot;일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 \u0026ldquo;DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.\u0026ldquo;는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import java.util.function.Function; public enum CalculatorType { CALC_A(value -\u0026gt; value), CALC_B(value -\u0026gt; value * 10), CALC_C(value -\u0026gt; value * 30), CALC_ETC(value -\u0026gt; 0L); private Function\u0026lt;Long, Long\u0026gt; expression; CalculatorType(Function\u0026lt;Long, Long\u0026gt; expression) { this.expression = expression; } public long calculate(long value) { return expression.apply(value); } }   1 2 3 4 5 6 7 8 9 10  import javax.persistence.Column; import javax.persistence.EnumType; import javax.persistence.Enumerated; public class Entity { @Column //@Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다.  @Enumerated(EnumType.STRING) private CalculatorType calculatorType; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.testng.annotations.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTypeTest { private CalculatorType selectType() { return CalculatorType.CALC_B; } @Test public void 코드에_따라_서로다른_계산하기_Enum() { CalculatorType code = selectType(); long originValue = 10000L; long result = code.calculate(originValue); assertEquals(result, 100000L); } }   값(상태)과 메소드(행위)가 어떤 관계가 있는지에 대해 더이상 다른 곳을 찾을 필요가 없게 되었다. 코드내에 전부 표현되어 있고, Enum 상수에게 직접 물어보면 되기 때문이다. ","permalink":"https://youngeun-in.github.io/enum-usage-1/","tags":["enum"],"title":"Enum 사용 (개념)"},{"categories":["spring"],"contents":"Spring mocking 없이 테스트하려면? 아래 코드를 mocking 없이 테스트하려면 어떻게 해야 할까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import java.io.IOException; public class RepositoryRank { public int getPoint(String repositoryName) throws IOException { GitHub github = GitHub.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u0026gt; 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public static void main(String[] args) throws IOException { RepositoryRank repositoryRank = new RepositoryRank(); int point = repositoryRank.getPoint(\u0026#34;whiteship/live-study\u0026#34;); System.out.println(point); } }   Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입하면 된다. 설명과 코드는 다음과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import org.kohsuke.github.GitHubBuilder; import java.io.IOException; public class RepositoryRank { //인터페이스 선언  interface GitHubService { GitHub connect() throws IOException; } //인터페이스를 구현한 클래스 생성하고 모킹하고자 하는 메소드를 오버라이드한다.  static class DefaultGitHubService implements GitHubService { @Override public GitHub connect() throws IOException { return new GitHubBuilder().build(); } } private final GitHubService gitHubService; //서비스를 주입받는다.  public RepositoryRank(GitHubService gitHubService) { this.gitHubService = gitHubService; } public int getPoint(String repositoryName) throws IOException { GitHub github = gitHubService.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u0026gt; 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public void main(String[] args) throws IOException { GitHubService gitHubService = new DefaultGitHubService(); //Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입  RepositoryRank repositoryRank = new RepositoryRank(gitHubService); int point = repositoryRank.getPoint(\u0026#34;whiteship/live-study\u0026#34;); System.out.println(point); } }   참고 백기선님의 유튜브를 참고했다. https://youtu.be/bJfbPWEMj_c ","permalink":"https://youngeun-in.github.io/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법"},{"categories":null,"contents":"","permalink":"https://youngeun-in.github.io/search/","tags":null,"title":"Search"}]