---
title: Java 동기화
date: 2022-03-23T15:12:26+09:00
categories:
  - java
tags: 
  - mutex
  - semaphore
---

동기화는 **프로세스(스레드)가 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것**을 말한다. 이러한 동기화 메커니즘인 상호배제는 하나의 프로세스가 공유자원을 사용할 때 다른 프로세스가 동일한 공유자원에 접근할 수 없도록 통제하는 것을 뜻한다. 상호배제 방법으로는 Mutex, Semaphore 방식이 사용된다. Java 에서는 Monitor 라는 도구를 통해 객체에 Lock을 걸어 상호배제를 할 수 있다.

## 동기화 메커니즘
### Mutex
Mutex는 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 메커니즘이다. 특징을 살펴보면 다음과 같다.

- Boolean 타입의 Lock 변수를 사용한다. 따라서 **1개의 공유자원에 대한 접근을 제한한**다.
- 공유자원을 사용 중인 스레드가 있을 때, 다른 스레드가 공유자원에 접근한다면 Blocking 후 대기 큐로 보낸다.
- Lock을 건 스레드만 Lock을 해제할 수 있다.

### Semaphore

Semaphore는 멀티프로그래밍 환경에서 **다수의 프로세스나 스레드가 n개의 공유 자원에 대한 접근을 제한**하는 방법으로 사용되는 동기화 기법이다.

- 세마포어 변수를 통해 wait, signal 을 관리한다. 세마포어 변수는 0 이상의 정수형 변수를 갖는다.
- n 개의 공유자원에 대한 접근을 제한할 수 있으며 이를 계수 세마포어라고 한다.
- 접근 가능한 공유 자원의 수가 1개일 때는 이진 세마포어로 뮤텍스처럼 사용할 수 있다.
- 큐에 연결된 스레드를 깨우는 방식에 따라 강성 세마포어(큐에 연결된 스레드를 깨울 때 FIFO 정책), 약성 세마포어(큐에 연결된 스레드를 깨울 때 순서를 특별히 명시하지 않음)로 구분된다.
- Lock을 걸지 않은 스레드도 Signal을 보내 Lock 을 해제할 수 있다.

### Monitor

Monitor는 **임계 구역을 지켜내기 위한 방법인 상호 배제를 프로그램으로 구현한 것**이다. 세마포어는 wait & signal 연산 순서를 바꿔서 실행하거나 둘 중 하나라도 생략하면 상호배제를 위반하는 상황이나 교착 상태가 발생한다. wait & signal 연산이 프로그램 전체에 구성되어 있으면 세마포어의 영향이 미치는 곳이 어딘지 파악하기 어렵기 때문에 세마포어를 사용하여 프로그램을 구현하기 어렵다. 이러한 단점을 극복하기 위해 모니터가 등장했다. 모니터는 프로그래밍 언어 수준에서 제공되며, 순차적으로 사용할  수 있는 공유 자원 혹은 공유 자원 그룹을 할당하는 데 사용된다. 모니터는 이진 세마포어만 가능하다.

공유 자원에 점유 중인 프로세스(스레드)는 Lock을 가지고 있다. 공유 자원을 점유 중인 프로세스(스레드)가 있는 상황에서 다른 프로세스(스레드)가 공유 자원에 접근하려고 하면 외부 모니터 준비 큐에서 진입을 `wait` 한다. Monitor 는 Semaphore 처럼 signal 연산을 보내는  것이 아니라 조건 변수를 사용하여 특정 조건에 대해 대기 큐에 signal 을 보내 작업을 시작시킨다.

## 자바에서 상호배제 구현
### Synchronized

Java 의 `synchronized` 키워드는 스레드 동기화를 할 때 사용하는 대표적인 기법이다. 자바의 모든 인스턴스는 Monitor 를 가지고 있으며 Monitor 를 통해 Thread 동기화를 수행한다. `synchronized` 키워드가 붙은 메서드를 사용하려면 Lock을 가지고 있어야 한다.

`synchronized`를 사용하는 방법으로는 메서드 앞에 키워드 명시, 인스턴스로 사용하기가 있다. 동기화가 필요한 메서드 앞에 `synchronized` 키워드만 붙여주면 편리하게 동기화를 적용할 수 있다. 인스턴스로 사용하려면 메서드 내부에서 `synchronized (메서드) { 구현 }` 으로 사용할 수 있다.

## wait, notify
Monitor 에는 Condition Variable 이 있는데 이를 통해 `wait()`, `notify()` 메서드가 구현되어 있다.

Lock 을 가진 스레드가 다른 스레드에 Lock 을 넘겨준 이후에 대기해야 한다면 `wait()` 를 사용하면 된다. 그리고 대기 중인 임의의 스레드를 깨우려면 `notify()` 를 통해 깨울 수 있다. 대기 중인 모든 스레드를 깨우려면 `notifyAll()` 을 통해 깨울 수 있는데, 이 경우에는 하나의 스레드만 Lock 을 획득하고 나머지 스레드는 다시 대기 상태에 들어간다.

## 참고
https://tecoble.techcourse.co.kr/post/2021-10-23-java-synchronize/
