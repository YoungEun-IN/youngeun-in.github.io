[{"categories":["java"],"content":"Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다. 위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다. 캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다. - 나무위키 Array 는 연속적인 memory block 으로, array 에 처음 접근할 때 전체 array 가 cache 에 로드된다. 첫 액세스 이후로는 공간 지역성이 생기는 것이다. 그러나 java 는 jvm 이 알아서 메모리를 관리 하기 때문에 array 사용시 cache locality 가 적용되는지 여부는 jvm 이 메모리 관리하는 방법을 공부해서 좀 더 알아봐야 할 것 같다. 지금 자세한 설명을 할 지식은 없지만 아마 java 에서는 ‘해당사항 없음’ 이라는 결론이 날 것 같다. ","date":"2022-02-17","objectID":"/array-arraylist/:1:0","tags":["array","array-list"],"title":"Array \u0026 ArrayList","uri":"/array-arraylist/"},{"categories":["java"],"content":"ArrayList Java 의 ArrayList 는 AbstractList 를 상속받고 List 인터페이스를 구현한 클래스이다. Array 와 비슷하지만 size 가 dynamic 하게 조절된다. ArrayList.java 코드를 열어보면 default size 는 10 인 것을 알 수 있다. private static final int DEFAULT_CAPACITY = 10; ArrayList 에서 새로운 element 를 추가하는 메소드는 add() 로, 두 가지 방식의 오버로딩 된 메소드가 정의되어 있다. /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return \u003ctt\u003etrue\u003c/tt\u003e (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 아래에 있는 add() 메소드는 특정 index 에 element 를 삽입하는 메소드로, 어떤 작업을 한 다음에 기존 array 를 copy 한 더 큰 size 를 가진 새로운 array 를 만들어 낸다. 결국 copy 라는 작업이 필요한 것이다. 그럼 매개변수 하나만 받는 위에있는 add() 는 어떻게 동작하는 걸까? 방금 언급한 어떤 작업 에서 ensureCapacityInternal() 메소드가 사이즈 조절을 담당한다. private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u003e 0) grow(minCapacity); } ensureCapacityInternal() 메소드로 가보면, 사이즈 조절을 위해 ensureExplicitCapacity() 를 또 호출한다. ensureExplicitCapacity() 메소드에서는 if (minCapacity - elementData.length \u003e 0) 이 if 문에 의해 현재 data 를 담고 있는 array 의 length 가 full 이면 grow() 라는 함수를 호출해서 size 를 늘린다. grow() 함수로 가보면 /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } int newCapacity = oldCapacity + (oldCapacity » 1); 여기가 포인트다. 비트연산으로 기존 size 의 1/2 만큼 새로운 capacity 를 할당하도록 한다. oldCapacity 값이 10 (default) 이었다면, 10 » 1 의 경우 10 의 2진수인 1010(2) 을 1-bit right shifting 한 값인 0101(2) , 즉 10진수 5 만큼 size 를 키우는 것이다. 이렇게 size 키워서 결국 한다는 게 copy 다. 결국 java 에서 제공하는 ArrayList 도 별다른 신박한 방법으로 관리하는 array 가 아니라 그냥 array 인 것이다. 즉, size 가 고정되지 않게 하려면 비용이 많이 든다는 단점이 있는 것은 확실하다. ","date":"2022-02-17","objectID":"/array-arraylist/:2:0","tags":["array","array-list"],"title":"Array \u0026 ArrayList","uri":"/array-arraylist/"},{"categories":["java"],"content":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:1:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:2:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:3:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Local Class 중괄호 내에, 특히 메소드 내에 정의 ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:4:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:5:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["essay"],"content":"시작은 언제든지 새롭고 떨리고 가슴벅차는 순간이다. 과연 이 블로그를 잘 운영할수 있을런지.. 제대로 한번 관리 해보고, 나만의 공간으로 꾸며보자! ","date":"2022-02-16","objectID":"/first/:0:0","tags":null,"title":"First","uri":"/first/"}]