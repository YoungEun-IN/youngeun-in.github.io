[{"categories":["java"],"content":"싱글톤 패턴 싱글톤 패턴은 프로세스(Java에서는 JVM) 내에 1개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역 접근점을 제공하는 패턴이다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:0","tags":["singleton"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Eager Initialization 싱글톤 패턴을 가장 단순하게 구현하는 방법은 외부에서 해당 클래스의 인스턴스를 생성할 수 없도록 private 생성자를 만들고, 1개의 인스턴스만을 초기화(public static final)하여 이에 대한 접근을 제공하는 방식이다. public class SimpleSingleton { //public static final으로 1개의 인스턴스만을 초기화하여 접근점을 제공하고, 2개 이상의 인스턴스를 못 만들게 한다. public static final SimpleSingleton INSTANCE = new SimpleSingleton(); private SimpleSingleton(){ //생성자는 private으로 만들어 외부에서 새로운 인스턴스를 만들 수 없도록 한다. } } static 필드와 메소드를 가지지 않는 Eager Initialization 방식의 Singleton의 경우 Class.forName()과 같은 메소드를 호출하지 않는 한, Eager Initialization 방식을 써도 INSTANCE에 접근하지 않는 한 객체 초기화가 발생하지 않는다. Java에서 Class가 Loading되는 경우는 아래와 같다. new를 통한 초기화 class.forName()과 함께 Reflection을 사용하는 경우 해당 클래스의 static 메소드가 실행된 경우 해당 클래스의 static 필드에 값을 할당 혹은 사용하는 경우(단, static final 제외) Top-Level Class인데, assert 문을 사용하는 경우 이 중 첫번째(new는 private method로 막아두었음)와 마지막 케이스를 제외한 세 가지 경우에 대해 ClassLoading이 발생하고 Singleton 객체가 초기화되는지 확인해보자. class.forName()과 함께 Reflection을 사용하는 경우 Singleton.java public class Singleton { public static final Singleton INSTANCE = new Singleton(); private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Class.forName(\"com.leeyh0216.test.Singleton\"); } } 실행 결과 Hello world Simple singleton instance initialized. 위 Test 클래스에서는 Class.forName 메서드를 통해 강제로 ClassLoading을 유발한다. 따라서 Singleton 객체가 초기화되며 “Simple singleton instance initialized” 메시지가 출력된다. 해당 클래스의 static 메소드가 실행된 경우 Singleton.java public class Singleton { public static final Singleton INSTANCE = new Singleton(); private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } public static void func() { System.out.println(\"This is static method\"); } public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Singleton.func(); } } 실행 결과 Hello world Simple singleton instance initialized. This is static method 위 Test 클래스에서는 Singleton 클래스의 정적 메소드인 func를 호출한다. 정적 메소드 호출 시에는 ClassLoading이 발생하기 때문에 func 메소드 실행 전에 Singleton 객체가 초기화되며 “Simple singleton instance initialized” 메시지가 호출되는 것을 확인할 수 있다. 해당 클래스의 static 필드의 값을 할당 혹은 사용하는 경우 Singleton.java public class Singleton { public static final Singleton INSTANCE = new Singleton(); public static int VALUE = 1; private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } } Test.java(할당) public class Test { public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Singleton.VALUE = 2; } } 실행 결과 Hello world Simple singleton instance initialized. Test.java(사용) public class Test { public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); System.out.println(Singleton.VALUE); } } 실행 결과 Hello world Simple singleton instance initialized. 1 위 두 케이스 모두 ClassLoading이 발생한다. 다만, VALUE를 final로 지정하여 상수로 만드는 경우는 ClassLoading이 발생하지 않는다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:1","tags":["singleton"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Lazy Initialization Singleton의 static 필드나 메소드를 사용해야 하지만, 싱글톤 객체는 초기화시키지 않고 싶은 경우가 있을 수 있다. 이러한 경우에는 Lazy Initialization 방식을 사용할 수 있다. Lazy Initialization 방식은 Singleton 객체가 필요한 경우에만 이를 초기화(초기화되어 있지 않은 경우에만)하고, Singleton 객체를 반환받을 수 있는 진입점(static 메소드)를 제공하는 방식이다. Singleton.java public class Singleton { public static Singleton INSTANCE; private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } public static Singleton getInstance(){ if(INSTANCE == null) INSTANCE = new Singleton(); return INSTANCE; } public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Singleton singleton = Singleton.getInstance(); } } 실행 결과 Hello world Simple singleton instance initialized. 명시적으로 getInstance 메소드를 호출하지 않는 이상 Singleton 객체(INSTANCE)가 초기화되지 않기 때문에, Eager Initialization 방식의 단점을 보완할 수 있다. Multi Thread 환경에서의 문제점 Lazy Initialization 방식은 Multi Thread 환경에서의 문제점을 가지고 있다. Multi Thread 환경에서 서로 다른 Thread들이 동시에 getInstance를 호출한다고 생각해보자. 위의 getInstance는 Multi Thread 환경에 대한 고려가 되어 있지 않기 떄문에, if(INSTANCE == null)이 여러번 참인 경우가 발생하여 여러 개의 객체가 생성될 수 있다. Singleton.java public class Singleton { public static final AtomicInteger NUM_INSTANCE = new AtomicInteger(0); private static Singleton INSTANCE; private Singleton() { System.out.println(\"Constructor called\"); } public static Singleton getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton(); NUM_INSTANCE.incrementAndGet(); } return INSTANCE; } public static int getNumberOfInstance() { return NUM_INSTANCE.get(); } public static void main(String[] args) throws Exception { Thread[] threads = new Thread[1000]; for (int i = 0; i \u003c threads.length; i++) { threads[i] = new Thread(new Runnable() { public void run() { Singleton.getInstance(); } }); } for (int i = 0; i \u003c threads.length; i++) { threads[i].start(); } for (int i = 0; i \u003c threads.length; i++) { threads[i].join(); } System.out.println(Singleton.getNumberOfInstance()); } } 실행 결과 Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called 24 ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:2","tags":["singleton"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Multi Thread 환경에서 Lazy Initialization 방법 Multi Thread 환경에서 Singleton 객체를 Lazy Initialization하는 몇가지 방법을 소개한다. 정적 팩터리 메서드에 동기화 키워드 사용하기 Singleton 객체를 생성하는 정적 팩터리 메서드 자체에 synchronized를 붙여주거나, 내부 초기화 구문을 synchronized 구문으로 감싸주는 방법이 있다. 정적 팩터리 메서드 자체에 synchronized 붙이기 기존의 public static Singleton getInstance() 를 public static synchronized Singleton getInstance()와 같이 바꾸는 방법이다. 내부 초기화 구문을 synchronized로 감싸주기 초기화에 사용할 Lock 객체를 만들고, Singleton 객체의 초기화 여부 확인 시 동기화하는 방법이다. private static Object lock = new Object(); public static Singleton getInstance() { synchronized (lock) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } return INSTANCE; } 동기화 방식은 Multi Thread 환경에서 객체를 안전하게 1개를 생성할 수 있지만, 객체 획득 시의 병렬성을 잃어버린다는 단점이 존재한다. 또한 초기 호출 이후에는 객체 초기화 확인 구문(if(INSTANCE) == null))이 계속해서 참을 반환하기 때문에 불필요한 Lock을 거는 상황이 발생하게 된다. DCL(Double-Checked-Locking) 방식 사용하기 Multi Thread 환경에서 병렬성을 확보하기 위해서는 동기화 구문을 필요한 곳에서만 사용해야 한다. DCL 방식은 동기화를 최소화하므로써 위의 방식의 단점(불필요한 Lock을 거는)을 없앤 방식이다. private static Object lock = new Object(); public static Singleton getInstance() { if (INSTANCE == null) { synchronized (lock) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } } return INSTANCE; } 첫번째 if문을 통해 객체가 초기화되었는지 검사할 때는 동기화를 하지 않고, 두번째 if문을 통해 객체가 초기화되었는지 검사할 때는 동기화를 수행한다. getInstance 호출 후 충분한 시간이 지나 동기화가 필요 없을 때는 첫번째 if문만 실행하므로써 동기화에 따른 병렬성 감소를 감소시킬 수 있는 방식이다. 언뜻 보기에는 동기화 문제도 없고 성능적으로 뛰어난 방식이라고 생각할 수 있다. 그러나 위 코드는 문제점을 가지고 있다. 위 DCL 코드의 문제점과 해결 위 DCL 코드는 JVM의 Low-Level 동작 방식때문에 문제가 발생한다. 예를 들어 2개의 Thread(A, B)가 getInstance를 호출했다고 생각해보자. Thread A는 INSTANCE = new Singleton() 구문을 수행하고 있고, 이 때 Thread B는 첫번째 if문에서 INSTANCE의 초기화 여부를 검사(if(INSTANCE == null))하고 있다. 여기서 Thread A가 수행하는 ‘객체 생성’과 ‘변수 할당’ 구문은 한번에 실행되지 않고, 특정 시점에는 INSTANCE에는 일부만 초기화된 객체가 할당되어 있을 수 있다. 이 때 Thread B는 non-null check만 하기 때문에 일부만 초기화된 객체를 가져다 쓰게 되어 Crash가 발생할 수 있다. 이러한 문제점을 해결하기 위해서는 INSTANCE 객체에 volatile 키워드를 붙여주는 것이다. volatile은 원자적으로 동작하기 때문에 첫번째 if문이 완전히 초기화된 객체를 얻거나 아닌 경우 둘 중 하나로 동작하게 된다. Lazy Holder 방식 사용하기 Multi Thread 환경에서도 잘 동작하고, Lazy Initialization도 가능한 방식이다. public class LazySingletonHolder { public static Singleton getInstance() { return Singleton.INSTANCE; } public static class Singleton { private static final Singleton INSTANCE = new Singleton(); private Singleton() { } } } 위 코드를 보면 ‘Lazy Initialization 방식이 아니지 않은가?’ 라고 생각할 수 있다. LazySingletonHolder의 getInstance에서 Singleton 클래스의 INSTANCE를 그대로 반환하기 때문이다. 그러나 Singleton 클래스의 INSTANCE는 Singleton 클래스의 클래스 로딩이 일어날 때 발생하게 되고, 이는 LazySingletonHolder의 getInstance가 호출되었을 때이다. 또한 INSTANCE는 static final 이기 때문에 클래스 로딩에 의해 1회만 초기화되고, 이로써 Multi Thread 환경에서의 문제점도 없어지게 된다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:3","tags":["singleton"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"각 자료구조는 필요에 따라 선택되고 활용된다. Map 인터페이스의 구현체로는 HashMap, HashTable, ConcurrentHashMap 등이 있다. Map 인터페이스를 구현하면, \u003cKey, Value\u003e 형태를 띈다. 그렇다면 이 셋은 무슨 특징을 가지고, 서로 어떤 차이가 있을까? 이번 글에서 해당 구현체를 비교하며 확인해보자. ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:0:0","tags":["hashmap","hashtable","concurrenthashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"HashMap key와 value에 null을 허용한다. 동기화를 보장하지 않는다. HashMap은 thread-safe하지 않아, 싱글 쓰레드 환경에서 사용하는 게 좋다. 한편, 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다. 결국 HashTable과 ConcurrentHashMap보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어진다. public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable { ... public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u003e= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:1:0","tags":["hashmap","hashtable","concurrenthashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"HashTable key와 value에 null을 허용하지 않는다. 동기화를 보장한다. HashTable은 thread-safe하기 때문에, 멀티 쓰레드 환경에서 사용할 수 있다. 이는 데이터를 다루는 메소드(get(), put(), remove() 등)에 synchronized 키워드가 붙어 있다. 해당 키워드는 메소드를 호출하기 전에 쓰레드간 동기화 락을 건다. 그래서 멀티 쓰레드 환경에서도 데이터의 무결성을 보장한다. 그러나, 쓰레드간 동기화 락은 매우 느린 동작이라는 단점이 있다. public class Hashtable\u003cK,V\u003e extends Dictionary\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, java.io.Serializable { ... public synchronized V put(K key, V value) { if (value == null) { throw new NullPointerException(); } Entry\u003c?,?\u003e tab[] = table; int hash = key.hashCode(); int index = (hash \u0026 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry\u003cK,V\u003e entry = (Entry\u003cK,V\u003e)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) \u0026\u0026 entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } addEntry(hash, key, value, index); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:2:0","tags":["hashmap","hashtable","concurrenthashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"ConcurrentHashMap key와 value에 null을 허용하지 않는다. 동기화를 보장한다. ConcurrentHashMap은 thread-safe하기 때문에, 멀티 쓰레드 환경에서 사용할 수 있다. 이 구현체는 HashMap의 동기화 문제를 보완하기 위해 나타났다. 동기화 처리를 할 때, 어떤 Entry를 조작하는 경우에 해당 Entry에 대해서만 락을 건다. 그래서 HashTable보다 데이터를 다루는 속도가 빠르다. 즉, Entry 아이템별로 락을 걸어 멀티 쓰레드 환경에서의 성능을 향상시킨다. public class ConcurrentHashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements ConcurrentMap\u003cK,V\u003e, Serializable { ... public V put(K key, V value) { return putVal(key, value, false); } final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) { throw new NullPointerException(); } int hash = spread(key.hashCode()); int binCount = 0; for (Node\u003cK,V\u003e[] tab = table;;) { Node\u003cK,V\u003e f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) { if (casTabAt(tab, i, null, new Node\u003cK,V\u003e(hash, key, value, null))) break; } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh \u003e= 0) { binCount = 1; for (Node\u003cK,V\u003e e = f;; ++binCount) { K ek; if (e.hash == hash \u0026\u0026 ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node\u003cK,V\u003e pred = e; if ((e = e.next) == null) { pred.next = new Node\u003cK,V\u003e(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { Node\u003cK,V\u003e p; binCount = 2; if ((p = ((TreeBin\u003cK,V\u003e)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { if (binCount \u003e= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:3:0","tags":["hashmap","hashtable","concurrenthashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"정리 HashMap HashTable ConcurrentHashMap key와 value에 null 허용 O X X 동기화 보장(Thread-safe) X O O 추천 환경 싱글 쓰레드 멀티 쓰레드 멀티 쓰레드 ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:4:0","tags":["hashmap","hashtable","concurrenthashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"결론 싱글 쓰레드 환경이면 HashMap을, 멀티 쓰레드 환경이면 HashTable이 아닌 ConcurrentHashMap을 쓰자. 그 이유는 HashTable보다 ConcurrentHashMap이 성능적으로 우수하기 때문이다. 앞에서도 언급했듯이 HashTable은 쓰레드간 락을 걸어 데이터를 다루는 속도가 느리다. 반면, ConcurrentHashMap은 Entry 아이템별로 락을 걸어 데이터를 다루는 속도가 빠르다. ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:5:0","tags":["hashmap","hashtable","concurrenthashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-26-hashmap-hashtable-concurrenthashmap/ ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:6:0","tags":["hashmap","hashtable","concurrenthashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"Reflection API란? 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메서드, 타입, 변수 등등)에 접근할 수 있게 해주는 자바 API다. 아래와 같이 Car 클래스가 존재한다. public class Car { private final String name; private int position; public Car(String name, int position) { this.name = name; this.position = position; } public void move() { this.position++; } public int getPosition() { return position; } } 자바의 특징 중 하나인 다형성 덕분에 아래와 같이 객체 생성이 가능하다. public static void main(String[] args) { Object obj = new Car(\"foo\", 0); } 그럼 이렇게 생성된 obj라는 이름의 객체가 Car 클래스의 move 메서드를 사용할 수 있을까? 정답은 불가능이다. 왜일까? 자바는 컴파일러를 사용한다. 즉 컴파일 타임에 타입이 결정된다. obj라는 이름의 객체는 컴파일 타임에 Object로 타입이 결정됐기 때문에 Object 클래스의 인스턴스 변수와 메서드만 사용할 수 있다. 그러므로 아래와 같은 코드는 필연적으로 컴파일 에러가 난다. public static void main(String[] args) { Object obj = new Car(\"foo\", 0); obj.move(); // 컴파일 에러 발생 java: cannot find symbol } 생성된 obj라는 객체는 Object 클래스라는 타입만 알 뿐, Car 클래스라는 구체적인 타입은 모른다. 결국 컴파일러가 있는 자바는 구체적인 클래스를 모르면 해당 클래스의 정보에 접근할 수 없다는 것을 알 수 있다. 이렇게 불가능한 일을 마법처럼 가능하게 해주는 것이 Reflection API이다. 위에서 봤던 예제와 똑같은 상황에서 Reflection API를 활용해 Car 클래스의 move 메서드를 호출해보자. public static void main(String[] args) throws Exception { Object obj = new Car(\"foo\", 0); Class carClass = Car.class; Method move = carClass.getMethod(\"move\"); // move 메서드 실행, invoke(메서드를 실행시킬 객체, 해당 메서드에 넘길 인자) move.invoke(obj, null); Method getPosition = carClass.getMethod(\"getPosition\"); int position = (int)getPosition.invoke(obj, null); System.out.println(position); // 출력 결과: 1 } move 메서드가 실행되고 0으로 초기화했던 Car 클래스 인스턴스 변수 position이 1로 출력되는 걸 확인할 수 있다. Reflection API로 구체적인 클래스 Car 타입을 알지 못해도 move 메서드에 접근한 것이다. Class carClass2 = Class.forName(\"Car\"); 위의 예제처럼 클래스의 이름만으로도 해당 클래스의 정보를 가져올 수 있다. 다시 말해서 Reflection API는 클래스의 이름만 가지고도 생성자, 필드, 메서드 등등 해당 클래스에 대한 거의 모든 정보를 가져올 수 있는 마법 같은 API라는 것이다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:1:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Reflection은 어떻게 가능할까? 자바에서는 JVM이 실행되면 사용자가 작성한 자바 코드가 컴파일러를 거쳐 바이트 코드로 변환되어 static 영역에 저장된다. Reflection API는 이 정보를 활용한다. 그래서 클래스 이름만 알고 있다면 언제든 static 영역을 뒤져서 정보를 가져올 수 있는 것이다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:2:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Reflection을 어디에 활용할 수 있을까? 위에서 살펴봤던 예제 코드를 보면 멀쩡한 Car 객체를 Object 타입으로 생성하고 있다. 실제로 우리가 코드를 작성할 때는 예제와 같이 작성하지 않는다. 그러므로 우리가 코드를 작성하면서 Reflection을 활용할 일은 거의 없다. 구체적인 클래스를 모를 일이 거의 없기 때문이다. 게다가 Reflection은 마법 같은 힘을 가지고 있는 만큼 치명적인 단점들을 가지고 있다. 당연히 사용하지 않을 수 있다면 대부분의 경우 사용하지 않는 게 좋다. 치명적인 단점 중 대표적으로 성능 오버헤드가 있다. 컴파일 타임이 아닌 런타임에 동적으로 타입을 분석하고 정보를 가져오므로 JVM을 최적화할 수 없기 때문이다. 뿐만 아니라 직접 접근할 수 없는 private 인스턴스 변수, 메서드에 접근하기 때문에 내부를 노출하면서 추상화가 깨진다. 이로 인해 예기치 못한 부작용이 발생할 수 있다. 결론적으로 Reflection은 애플리케이션 개발보다는 프레임워크나 라이브러리에서 많이 사용된다. 프레임워크나 라이브러리는 사용자가 어떤 클래스를 만들지 예측할 수 없기 때문에 동적으로 해결해주기 위해 Reflection을 사용한다. 실제로 intellij의 자동완성, jackson 라이브러리, Hibernate 등등 많은 프레임워크나 라이브러리에서 Reflection을 사용하고 있다. Spring Framework에서도 Reflection API를 사용하는데 대표적으로 Spring Container의 BeanFactory가 있다. Bean은 애플리케이션이 실행한 후 런타임에 객체가 호출될 때 동적으로 객체의 인스턴스를 생성하는데 이때 Spring Container의 BeanFactory에서 리플렉션을 사용한다. Spring Data JPA 에서 Entity에 기본 생성자가 필요한 이유도 동적으로 객체 생성 시 Reflection API를 활용하기 때문이다. Reflection API로 가져올 수 없는 정보 중 하나가 생성자의 인자 정보이다. 그래서 기본 생성자가 반드시 있어야 객체를 생성할 수 있는 것이다. 기본 생성자로 객체를 생성만 하면 필드 값 등은 Reflection API로 넣어줄 수 있다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:3:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"출처 https://tecoble.techcourse.co.kr/post/2020-07-16-reflection-api/ ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:4:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Java 컴파일 과정 자바 소스 파일(*.java)을해당 파일을 Java Compiler가 JVM이 해석할 수 있는 파일인 Java ByteCode (*.class)파일로 변환한다. Java Compiler는 Java 설치 시 Javac.exe라는 실행 파일 형태로 존재한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:1:0","tags":["compiler","interpreter"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"Java 바이트 코드란? Java 바이트 코드란 Java Source File을 Java Compiler가 컴파일해 만든 파일이다. Java Compiler에 의해 변환되는 코드의 명령어 크기가 1byte이기 때문에 Java 바이트코드라고 불린다. Java 바이트 코드는 JVM이 해석할 수 있는 언어이며 *.class 확장자를 가진다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:1:1","tags":["compiler","interpreter"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"Java 실행 과정 Java Compiler를 통해 만들어진 Java Bytecode (*.class)를 Class Loader를 통해 가져온 후 Runtime Data Area에 배치한다. Execution Engine에서 바이트코드를 기계어로 해석한다. Execution Engine은 인터프리터 방식 혹은 JIT(Just-In-Time) Compiler 방식이 있다. 인터프리터 방식은 소스 코드를 한 문장씩 읽으며 해당 문장을 기계어 코드로 변환시켜준다. JIT Compiler는 실행 시점에 기계어 코드로 변환시켜준다. 프로세서는 기계어에 따라 동작을 수행한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:0","tags":["compiler","interpreter"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"JIT 컴파일러 JIT(Just-In-Time) 컴파일러는 JVM의 Execution Engine이 바이트코드를 사용하는 운영체제에 맞는 기계어로 변환시켜주는 방식중 하나이다. JIT 컴파일러는 프로그램을 실제 실행하는 시점에 기계어를 번역한다. 이렇게만 보면 인터프리터 방식과의 차이점이 없어보이지만 JIT 컴파일러는 같은 코드를 매번 해석하지 않고 기계어로 번역하면서 캐싱한다. 해당 파일이 다시 기계어로 컴파일 된다면 이전 파일과 비교해서 바뀐 부분은 새롭게 컴파일하고 변동 사항이 없는 부분은 캐싱된 코드를 사용한다. 이러한 방식은 인터프리터 속도가 느린 점을 JIT 컴파일러로 개선할 수 있는 장점이 된다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:1","tags":["compiler","interpreter"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"JVM의 구성요소 JVM은 크게 Class loader, Runtime Data Areas, Excution Engine 3가지로 구성된다. ","date":"2022-03-01","objectID":"/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/:1:0","tags":["jvm"],"title":"JVM의 구성요소","uri":"/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"},{"categories":["java"],"content":"Class Loader(클래스 로더) Java 컴파일러로 컴파일된 Java 바이트 코드를 Runtime 시점에 JVM내로 가져오고 Runtime Data Area(JVM 메모리 영역)에 배치해주는 역할을 한다. ","date":"2022-03-01","objectID":"/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/:1:1","tags":["jvm"],"title":"JVM의 구성요소","uri":"/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"},{"categories":["java"],"content":"Runtime Data Area JVM의 메모리 영역에 해당하며 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 세분화된다. Method Area : Class, Interface, Method, Field, Static, Final 변수 등을 보관하는 영역 Heap Area : new 키워드로 생성된 객체나 배열 인스턴스를 보관하는 영역, Runtime 시 동적으로 생성되고 JVM이 사용여부를 판단 후 Garbage Collection을 하는 영역 Stack Area : Heap Area에 동적으로 생성되어 보관되있는 객체(참조 타입)의 래퍼런스를 보관하는 영역, 기본 타입의 경우 직접 Stack Area에 보관됨 PC Register : Thread가 생성될 때 생성되는 영역으로서 Thread마다 하나의 영역을 가진다. JVM이 현재 수행중인 명령의 주소를 가짐 Native Method Stack : Java외 다른 언어로 작성된 Native Code를 위한 Stack 영역 ","date":"2022-03-01","objectID":"/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/:1:2","tags":["jvm"],"title":"JVM의 구성요소","uri":"/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"},{"categories":["java"],"content":"Execution Engine Class Loader를 통해 Runtime Data Area영역에 배치된 바이트 코드를 실행하는 역할을 한다. ","date":"2022-03-01","objectID":"/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/:1:3","tags":["jvm"],"title":"JVM의 구성요소","uri":"/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"},{"categories":["DB"],"content":"캐시란 cache란 사용자의 입장에서 데이터의 원래 소스보다 더 빠르게 그리고 더 효율적으로 액세스할 수 있는 임시 데이터 저장소를 뜻한다. 대부분의 애플리케이션에서 속도 향상을 위해 cache를 사용하고 있다. 캐시에 데이터나 계산된 결과 값의 복사본을 저장해 둠으로써 전체적인 처리 속도를 향상시킨다. 캐시를 사용하는 경우는 다음과 같다. 데이터에 직접적으로 접근하는 데 걸리는 시간이 오래 걸릴 때 데이터가 잘 변하지 않는 경우 반복적으로 동일한 결과를 돌려주는 경우 (이미지와 썸네일 등) ","date":"2022-02-28","objectID":"/redis/:1:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"Redis란 레디스는 전 세계에서 가장 유명한 caching 솔루션이다. 단순하게 key-value 형태로 저장할 수 있기 때문에 어떤 데이터라도 쉽게 저장할 수 있다. 또한 레디스는 모든 데이터를 메모리에 올려두는 인메모리 데이터 스토어이다. 평균 읽기 및 쓰기 작업 속도가 1밀리 세컨드 미만이니 초당 수백만 건의 작업이 가능하다. ","date":"2022-02-28","objectID":"/redis/:2:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"캐싱 전략 레디스를 cache로 사용할 때 어떻게 배치하는지가 시스템의 성능에 큰 영향을 끼치기 때문에 caching 전략은 데이터의 유형과 해당 데이터에 대한 액세스 패턴을 잘 고려해서 선택해야 한다. ","date":"2022-02-28","objectID":"/redis/:3:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"읽기 전략 Look-Aside(Lazy Loading) 이 구조는 레디스를 cache로 쓸 때 가장 일반적으로 사용하는 방법이다. 애플리케이션은 데이터를 찾을 때 cache에 먼저 확인한다. cache에 데이터가 있으면 cache에서 데이터를 가지고 오는 작업을 반복한다. 만약 레디스에 찾는 키가 없다면 애플리케이션은 DB에 접근해서 데이터를 직접 가지고 온 뒤 다시 레디스에 저장하는 과정을 거쳐야 한다. 따라서 cache는 찾는 데이터가 없을 때에만 입력되기 때문에 이를 lazy loading이라고도 부른다. 이 구조는 레디스가 다운되더라도 바로 장애로 이어지지 않고 DB에서 데이터를 가지고 올 수 있다. 대신 cache로 붙어있던 커넥션이 많이 있었다면 그 커넥션이 모두 데이터베이스로 붙기 때문에 DB에 갑자기 많은 부하가 몰릴 수 있다. 그래서 이런 경우에 cache를 새로 투입하거나 DB에만 새로운 데이터를 저장했다면 처음에 캐시 미스가 엄청 발생해서 성능에 저하가 올 수 있다. 이럴 때에는 미리 DB에서 cache로 데이터를 밀어 넣어주는 작업을 할 수 있는데, 이를 cache warming이라고도 한다. ","date":"2022-02-28","objectID":"/redis/:3:1","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"쓰기 전략 Write-Around write around 방식은 DB에만 데이터를 저장한다. 일단 모든 데이터는 DB에 저장되고 cache miss가 발생한 경우에만 cache에 데이터를 끌어오게 된다. 이 경우엔 cahce 내의 데이터와 DB 내의 데이터가 다를 수 있다는 단점이 있다. Write-Through write-through 전략은 DB에 데이터를 저장할 때 cache에도 함께 저장하는 방법이다. cache는 항상 최신 정보를 가지고 있다는 장점이 있지만 저장할 때마다 두 단계 스텝을 거쳐야 하기 때문에 상대적으로 느리다고 볼 수 있다. 그리고 저장하는 데이터가 재사용되지 않을 수도 있는데 무조건 캐시에 넣어버리기 때문에 이는 일종의 리소스 낭비라고도 볼 수 있다. 따라서 이렇게 데이터를 저장할 때는 몇 분 혹은 몇 시간 동안만 데이터를 보관하겠다는 의미인 expire time을 설정해 주는 것이 좋다. ","date":"2022-02-28","objectID":"/redis/:3:2","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"출처 https://youtu.be/92NizoBL4uA ","date":"2022-02-28","objectID":"/redis/:4:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["network"],"content":"HTTP 캐시 Static file(js, css, image) 뿐만 아니라 API와 같은 Dynamic content에도 간단하게 Cache기능을 사용하게 설정하면 API속도도 증가되고 유저 입장에서는 네트웍 트래픽을 줄일 수 있다. API와 같이 언제 바뀔지 모르는 데이터의 Cache는 쉽지 않은데, Etag를 이용하면 서버에서 새로운 데이터를 먼저 확인하고 줄 수 있기 때문에 API에도 충분히 적용가능하다. ","date":"2022-02-27","objectID":"/etag/:1:0","tags":["http-cache"],"title":"Etag","uri":"/etag/"},{"categories":["network"],"content":"Etag API데이터의 MD5 Hash를 ETag로 사용하게 되면 DB부하를 줄일 순 없지만, Response 시간을 줄이는데 도움이 될 수 있다. Response에 다음과 같은 Etag 헤더를 추가해주면, 다음 동일한 API를 부르면 아래와 같은 Request 헤더에 체크하는 헤더가 추가된다. If-None-Match: \"15f0fff99ed5aae4edffdd6496d7131f\" 서버에서 같은 ETag를 가지고 있다면 Http code 304 를 리턴해주면 된다. ","date":"2022-02-27","objectID":"/etag/:2:0","tags":["http-cache"],"title":"Etag","uri":"/etag/"},{"categories":["network"],"content":"Etag 작동 순서 API 핸들러 처리(DB query) 결과 Json에 MD5 Hash If-None-Match 헤더에 있는 값과 hash값을 비교 만약 동일하다면 304로 리턴 다르다면 200에 결과 Json리턴 ","date":"2022-02-27","objectID":"/etag/:3:0","tags":["http-cache"],"title":"Etag","uri":"/etag/"},{"categories":["DB"],"content":"인덱스의 종류 ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"클러스터형 인덱스(Clustered Index) 영어 사전처럼 책의 내용 자체가 순서대로 정렬되어 있어서 인덱스 자체가 책의 내용과 같은 것 테이블 당 한 개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하는지에 따라서 시스템의 성능이 달라질 수 있다. 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 신중하게 생각해야 한다. 보조 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:1","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"보조 인덱스(Secondary Index) \u003c찾아보기\u003e가 별도로 있고, \u003c찾아보기\u003e를 찾은 후에 그 옆에 표시된 페이지로 가야 실제 찾는 내용이 있는 것 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다. 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소값이다. 클러스터형 인덱스보다 검색 속도는 더 느리지만 입력/수정/삭제는 덜 느리다. 테이블 당 여러 개를 생성할 수 있다. 하지만 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있으므로 꼭 필요한 열에만 생성하는 것이 좋다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:2","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"MYSQL 인덱스의 특징 PRIMARY KEY로 지정한 열은 클러스터형 인덱스가 생성된다. UNIQUE NOT NULL로 지정한 열은 클러스터형 인덱스가 생성된다. UNIQUE(또는 UNIQUE NULL)로 지정한 열은 보조 인덱스가 생성된다. PRIMARY KEY와 UNIQUE NOT NULL이 있으면 PRIMARY KEY로 지정한 열에 우선 클러스터형 인덱스가 생성된다. PRIMARY KEY로 지정한 열로 데이터가 오름차순 정렬된다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:2:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"인덱스를 생성할 때 고려할 점 테이블 조회 시에 WHERE 절의 조건에 해당 열이 나오는 경우에만 인덱스를 사용한다. WHERE절에 사용되더라도 자주 사용해야 가치가 있다. 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다. 외래 키를 지정한 열에는 자동으로 외래 키 인데스가 생성된다. JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다. 사용하지 않는 인덱스는 제거하자. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:3:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["개발방법론"],"content":"📕 AOP AOP는 OOP를 더욱 OOP답게 프로그래밍 할 수 있게 도와주는 것으로 애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법이다. 실제로 Spring doc document 에서는 아래와 같이 말하고 있다. Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by providing another way of thinking about program structure AOP는 프로그램 구조에 대한 다른 생각의 방향을 제공해주면서 OOP를 보완하고 있다. 예를 들면 어떠한 클래스를 대상으로 핵심 기능과 부가적인 기능의 관점으로 공통 사용 부가 기능들을 외부의 독립된 클래스로 분리하고 이를 모듈화하여 재사용할 수 있게끔 하는 프로그래밍 기법이다. ","date":"2022-02-24","objectID":"/aop/:1:0","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📘 AOP 용어 용어 설명 Aspect(Advisor) ✔ 특정 한 가지 기능에 대해 흩어진 관심사를 모듈화하여 묶은 클래스 - PointCut + Advice를 묶은 메서드를 정의 및 관리한다. Target ✔ 비즈니스(핵심) 로직을 구현하는 AOP의 대상 ‘클래스’ Advice ✔ AOP 메서드 : 부가 기능을 적용시키는 메서드(부가 기능 로직 메서드) 적용 시점도 지정할 수 있다. - before : 비즈니스 메소드 실행 전에 동작 - after : 비즈니스 메소드 실행 후에 동작 - after-returning : 비즈니스 메소드 실행 중 리턴 되는 순간 - after-throwing : 비즈니스 메소드 실행 중 에러 발생 순간 - around : 비즈니스 메소드 실행 전/후에 동작 JoinPoint ✔ AOP가 적용될 수 있는 메소드, 필드, 객체, 생성자 등의 요소 - 타겟 클래스의 요소들을 의미하며 PointCut의 후보 - Spring AOP에서는 메서드만 지정 가능 PointCut ✔ AOP 적용 가능 요소들 중에서 ‘실제 적용될 요소들’을 의미한다. - JoinPoint에서 실제 Advice가 적용될 지점 - Spring AOP 에서는 advice가 적용될 메서드를 의미 Weaving ✔ PointCut이 호출될 때 Advice가 호출되는 과정을 의미한다. 즉, PointCut에 Advice 메서드가 삽입되는 과정을 의미한다. - 컴파일 전에는 핵심 로직과 인프라 로직이 분리되어있지만 - 컴파일타임에 바이트 코드를 넣는다던지 런타임에 프록시를 만들던지 - 관심사를 분리한 코드를 비즈니스 코드와 병합하는 작업을 의미한다. Weaving 처리 방식 (AOP 구현 방법) - 컴파일 타임 위빙 : a.java -\u003e a.clss 컴파일 될 때 - 로딩 타임 위빙 : 클래스파일을 클래스 로더가 메모리에 로드할 때 - 런타임/프록시 위빙 : 타겟 클래스에 부가 기능을 추가하도록 Proxy 객체를 만들어(감싸서) 실행 - 스프링 AOP는 런타임 위빙만을 지원한다.(IOC/DI를 이용한 방법) proxy ✔ Target 객체에 Advice를 적용시키는 래퍼 클래스 애플리케이션은 자연스럽게 여러 메서드(Join Point)를 호출한다. 이때 특정 PointCut으로 지정한 메소드가 호출되는 순간 Aspect 의 Advice 메소드가 호출된다. Advice 메소드의 동작 시점은 5가지로 정할 수 있다. 애스팩트 설정에 따라 위빙 처리되어 프록시 객체가 생성된다.(동적 프록시 생성) 프록시 객체를 통해 부가기능이 포함된 비즈니스 로직을 수행한다. ","date":"2022-02-24","objectID":"/aop/:2:0","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📖 AOP 구현 implementation 'org.springframework.boot:spring-boot-starter-aop' // @EnableAspectJAutoProxy 생략 가능 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } } @Service public class AuthServiceImpl { public void businessLogicMethod(){ System.out.println(\"businessLogicMethod process!\"); } } ","date":"2022-02-24","objectID":"/aop/:3:0","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📄 일반적인 구현 @Aspect @Configuration public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"execution(* com.demo.study.service.AuthServiceImpl.*(..))\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"execution(* com.demo.study.service.AuthServiceImpl.*(..))\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } ","date":"2022-02-24","objectID":"/aop/:3:1","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📄 어노테이션으로 구현 @Target(ElementType.METHOD) @Retention(RetentionPolicy.CLASS) public @interface PerformanceCheck { } @Service public class AuthServiceImpl { @PerformanceCheck public void businessLogicMethod(){ System.out.println(\"businessLogicMethod process!\"); } } @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"@annotation(com.demo.study.annotation.PerformanceCheck)\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"@annotation(com.demo.study.annotation.PerformanceCheck)\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } 어노테이션과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다. ","date":"2022-02-24","objectID":"/aop/:3:2","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📄 빈으로 구현 @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"bean(com.demo.study.service.AuthServiceImpl)\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"bean(com.demo.study.service.AuthServiceImpl)\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } 빈과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다. ","date":"2022-02-24","objectID":"/aop/:3:3","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📖 AOP PointCut 설정 execution(* com.springbook.biz..*Impl.get*(..))\" * : 리턴값 com.springbook.biz.. : 패키지 *Impl: 클래스 이름 get* : 메서드 이름 (..) : 매개변수 중간마다의 . : 구분점 ","date":"2022-02-24","objectID":"/aop/:4:0","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📄 execution 포인트 컷 리턴 표현식 설명 * 모든 리턴타입 허용 void 리턴타입이 void인 메서드 선택 !void 리턴타입이 void가 아닌 메서드 선택 ","date":"2022-02-24","objectID":"/aop/:4:1","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📄 execution 포인트 컷 패키지 표현식 설명 com.springbook.biz 정학하게 해당 패키지만 선택 com.springbook.biz.. 해당 패키지 및 모든 하위 패키지 선택 com.springbook..impl ..앞 패키지로 시작하면서 마지막 패키지 이름이 ..뒤로 끝나는 패키지 선택 ","date":"2022-02-24","objectID":"/aop/:4:2","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📄 execution 포인트 컷 클래스 표현식 설명 BoardServiceImpl 정학하게 해당 클래스만 선택 *Impl 클래스 이름이 *뒷 글자로 끝나는 클래스만 선택 BoardService+ 해당 클래스는 물론 파생된 모든 자식 클래스도 선택 가능 variable+ 해당 인터페이스를 구현한 모든 클래스 선택 가능 ","date":"2022-02-24","objectID":"/aop/:4:3","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📄 execution execution 포인트 컷 메서드 표현식 설명 *(..) 가장 기본 설정으로 모든 메서드 선택 get*(..) 메서드 이름이 get으로 시작하는 모든 메서드 선택 매서드이름(..) 특정 메서드 이름을 가진 메서드 선택 📄 execution 포인트 컷 매개변수 표현식 설명 (..) 가장 기본 설정으로서 매개변수 타입의 제한이 없음을 의미 (*) 반드시 1개의 매개변수를 가지는 메서드만 허용한다는 의미 (com.spring.user.User) 해당 패키지의 클래스를 가지는 메서드만 허용한다는 의미 (!com.spring.user.User) 해당 패키지의 클래스를 가지지 않는 메서드만 허용한다는 의미 (Integer, ..) 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용 (Integer, *) 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용 ","date":"2022-02-24","objectID":"/aop/:4:4","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"📗 스프링 AOP 스프링 AOP 는 런타임 위빙을 지원하기에 Proxy 기반의 AOP 구현 기능을 지원한다. 이러한 Proxy 기반의 AOP는 스프링 빈에만 적용가능하기에 빈으로 등록된 대상만 AOP 대상이 된다. 또한, 스프링 AOP 특징상 메서드만을 지원할 수 있다. 프록시 패턴 @Primary @Service public class ProxySimpleEventService implements EventService{ private final EventService simpleEventService; ProxySimpleEventService(EventService simpleEventService) { this.simpleEventService = simpleEventService; } @Override public void createEvent() { long begin = System.currentTimeMillis(); simpleEventService.createEvent(); System.out.println(\"createEvent 실행시간: \"+(System.currentTimeMillis()-begin)); } @Override public void publishEvent() { long begin = System.currentTimeMillis(); simpleEventService.publishEvent(); System.out.println(\"createEvent 실행시간: \"+(System.currentTimeMillis()-begin)); } @Override public void deleteEvent() { simpleEventService.deleteEvent(); } } 프록시 패턴은 AOP에서 기존 코드의 변경 없이 접근 제어 또는 부가 기능 추가하기 위해 사용된다. 그러나 일반적인 방법으로 프록시 패턴을 구현하면 아래와 같은 문제점이 발생한다. 문제점 매번 Proxy 클래스를 작성해야 한다. 하나의 클래스가 아닌 여러 클래스를 대상으로 적용하기 힘들다. 객체 관계가 복잡해지고 관리하기 어렵다. 이러한 문제점을 해결하기 위해 등장한 것이 바로 Spring AOP와 Dynamic Proxy다. 스프링 IoC 컨테이너가 제공하는 기반 시설과 Dynamic Proxy를 사용하여 여러 복잡한 문제 해결했다. Dynamic Proxy : 동적으로 프록시 객체 생성하는 방법 JDK Dynamic Proxy : 자바가 제공하는 인터페이스 기반 프록시 생성 라이브러리 CGlib : 자바가 제공하는 클래스 기반 프록시 생성 라이브러리 Spring IoC : 기존 빈을 대체하는 ‘동적 프록시 빈’을 만들어 등록한다. 클라이언트 코드 변경이 없다. AbstractAutoProxyCreator implements BeanPostProcessor를 기반으로 만든다. 즉 빈이 생성된 후, 프록시를 생성하는 로직을 수행한다. 이렇듯 런타임시에 동적으로 프록시 빈을 생성하고 AOP를 적용시키는 것을 런타임 위빙이라 부른다. ","date":"2022-02-24","objectID":"/aop/:5:0","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"🔍 런타임 위빙(프록시 위빙) 런타임 위빙은 런타임에 동적으로 Proxy를 생성하여 실제 Target 객체의 변형없이 AOP를 수행하는 것을 의미한다. 스프링을 기준으로 말하자면 메서드만이 JoinPoint가 될 수 있기에 Method 호출 시에 위빙이 이루어 지는 방식이다. 런타임 위빙 또한, 일반적인 Proxy 패턴을 개선한 Dynamic Proxy를 사용하고 있지만 아래와 같은 문제가 있다. 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다. 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.(프록시이기에) AOP 프록시 객체 org.woowacourse.aoppractice.service.AuthServiceImpl$$EnhancerBySpringCGLIB$$dbdb402d 위 코드를 보면, Target 클래스 자체를 프록시로 감싸는 것을 알 수 있다. 프록시 위빙이 가능한 이유는 상속을 이용한 방식이기에 다형성을 적용시킬 수 있다. 즉, 위 그림에서 AuthController가 AuthService의 프록시 클래스인 AuthService$$블라블라를 참조할 수 있던 것이다. 그런데 한가지 생각해볼 점이 있다. DynamicProxy는 상속/구현을 적용하니 아래와 같은 요소들은 가능할까? 🤔 final 클래스 final 메서드 private 메서드 당연하게도, 자바 문법적으로 상속 및 오버라이딩을 지원하지 못하므로 적용이 되지 않는다. 이와 비슷하게 Spring에서 지원해주는 @Trancsactional 어노테이션이 있는데 @Trancsactional 어노테이션 또한 AOP기반이기에 private 메서드를 붙이면 작동을 하지 않는다. @Trancsactional 로직 시작시 트랜잭션을 열어줌 로직 끝날시 commit하고 트랜잭션을 닫아줌 트랜잭션에 관련된 인프라 로직을 지원하기에 우리는 비즈니스 로직에 집중할 수 있게해준다. ","date":"2022-02-24","objectID":"/aop/:5:1","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"참고 백기선-스프링 프레임워크 핵심 기술 스프링 퀵 스타트 테코톡-스프링 AOP 장인 개발자를 꿈꾸는 : 기록하는 공간 Carrey’s 기술블로그 진짜 개발자 기억보단 기록을 리다양의 개발 세상 Carrey’s 기술블로그-AspectJ 나중에 참고하면 좋음 논리적 코딩 ","date":"2022-02-24","objectID":"/aop/:6:0","tags":["spring-aop","dynamic-proxy"],"title":"AOP","uri":"/aop/"},{"categories":["java"],"content":"서블릿 컨테이너 서블릿 컨테이너는 서블릿을 담아 관리한다. 서블릿은 싱글톤으로 관리된다. ","date":"2022-02-23","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:1:0","tags":["servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"서블릿이 호출되는 과정 Servlet Request / Servlet Response 객체 생성 설정 파일을 참고하여 매핑할 Servlet을 확인 \u003cservlet\u003e \u003cservlet-name\u003eMyServlet\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.jsp.web.MyServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eMyServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 해당 서블릿 인스턴스 존재를 유무를 확인하여 없으면 생성(init()) Servlet Container에 스레드를 생성하고, res req를 인자로 service 실행 ","date":"2022-02-23","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:2:0","tags":["servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"참고 https://youtu.be/calGCwG_B4Y ","date":"2022-02-23","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:3:0","tags":["servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다. 위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다. 캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다. - 나무위키 Array 는 연속적인 memory block 으로, array 에 처음 접근할 때 전체 array 가 cache 에 로드된다. 첫 액세스 이후로는 공간 지역성이 생기는 것이다. 그러나 java 는 jvm 이 알아서 메모리를 관리 하기 때문에 array 사용시 cache locality 가 적용되는지 여부는 jvm 이 메모리 관리하는 방법을 공부해서 좀 더 알아봐야 할 것 같다. 지금 자세한 설명을 할 지식은 없지만 아마 java 에서는 ‘해당사항 없음’ 이라는 결론이 날 것 같다. ","date":"2022-02-17","objectID":"/array-arraylist/:1:0","tags":["array","array-list"],"title":"Array \u0026 ArrayList","uri":"/array-arraylist/"},{"categories":["java"],"content":"ArrayList Java 의 ArrayList 는 AbstractList 를 상속받고 List 인터페이스를 구현한 클래스이다. Array 와 비슷하지만 size 가 dynamic 하게 조절된다. ArrayList.java 코드를 열어보면 default size 는 10 인 것을 알 수 있다. private static final int DEFAULT_CAPACITY = 10; ArrayList 에서 새로운 element 를 추가하는 메소드는 add() 로, 두 가지 방식의 오버로딩 된 메소드가 정의되어 있다. /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return \u003ctt\u003etrue\u003c/tt\u003e (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 아래에 있는 add() 메소드는 특정 index 에 element 를 삽입하는 메소드로, 어떤 작업을 한 다음에 기존 array 를 copy 한 더 큰 size 를 가진 새로운 array 를 만들어 낸다. 결국 copy 라는 작업이 필요한 것이다. 그럼 매개변수 하나만 받는 위에있는 add() 는 어떻게 동작하는 걸까? 방금 언급한 어떤 작업 에서 ensureCapacityInternal() 메소드가 사이즈 조절을 담당한다. private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u003e 0) grow(minCapacity); } ensureCapacityInternal() 메소드로 가보면, 사이즈 조절을 위해 ensureExplicitCapacity() 를 또 호출한다. ensureExplicitCapacity() 메소드에서는 if (minCapacity - elementData.length \u003e 0) 이 if 문에 의해 현재 data 를 담고 있는 array 의 length 가 full 이면 grow() 라는 함수를 호출해서 size 를 늘린다. grow() 함수로 가보면 /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } int newCapacity = oldCapacity + (oldCapacity » 1); 여기가 포인트다. 비트연산으로 기존 size 의 1/2 만큼 새로운 capacity 를 할당하도록 한다. oldCapacity 값이 10 (default) 이었다면, 10 » 1 의 경우 10 의 2진수인 1010(2) 을 1-bit right shifting 한 값인 0101(2) , 즉 10진수 5 만큼 size 를 키우는 것이다. 이렇게 size 키워서 결국 한다는 게 copy 다. 결국 java 에서 제공하는 ArrayList 도 별다른 신박한 방법으로 관리하는 array 가 아니라 그냥 array 인 것이다. 즉, size 가 고정되지 않게 하려면 비용이 많이 든다는 단점이 있는 것은 확실하다. ","date":"2022-02-17","objectID":"/array-arraylist/:2:0","tags":["array","array-list"],"title":"Array \u0026 ArrayList","uri":"/array-arraylist/"},{"categories":["java"],"content":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:1:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:2:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:3:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Local Class 중괄호 내에, 특히 메소드 내에 정의 ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:4:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:5:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"equals 메소드 Object 클래스에 정의된 equals 메소드는 다음과 같다. public boolean equals(Object obj) { return (this == obj); } 단순히 Object의 ==로 비교하는 것을 확인할 수 있다. 두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다. @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AttachFile that = (AttachFile) o; return Objects.equals(id, that.id) \u0026\u0026 Objects.equals(fileName, that.fileName) \u0026\u0026 Objects.equals(minutes, that.minutes); } ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:1:0","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"hashCode 메소드 Object 클래스에 정의된 hashCode 메소드는 인스턴스가 다르면 구성 내용에 상관없이 전혀 다른 해시 값을 반환하도로 정의되어 있다. Object 클래스에 정의된 hashCode 메소드는 다음과 같다. @HotSpotIntrinsicCandidate public native int hashCode(); 다음은 [hotspot의 jvm.cpp 파일에서 발췌][jvm-cpp-583]한 것이다. 버전은 JDK10 이지만, JDK8과 차이점은 없다. JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(\"JVM_IHashCode\"); // as implemented in the classic virtual machine; return 0 if object is NULL return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END [JVM_IHashCode 는 ObjectSynchronizer::FastHashCode][synchronizer-714]를 사용하고 있다. 그리고 이 함수를 잘 읽어보면 새로운 해시 코드 할당은 get_next_hash 함수를 사용한다는 것을 알 수 있다. 다음은 get_next_hash 함수의 코드이다. // hashCode() generation : // // Possibilities: // * MD5Digest of {obj,stwRandom} // * CRC32 of {obj,stwRandom} or any linear-feedback shift register function. // * A DES- or AES-style SBox[] mechanism // * One of the Phi-based schemes, such as: // 2654435761 = 2^32 * Phi (golden ratio) // HashCodeValue = ((uintptr_t(obj) \u003e\u003e 3) * 2654435761) ^ GVars.stwRandom ; // * A variation of Marsaglia's shift-xor RNG scheme. // * (obj ^ stwRandom) is appealing, but can result // in undesirable regularity in the hashCode values of adjacent objects // (objects allocated back-to-back, in particular). This could potentially // result in hashtable collisions and reduced hashtable efficiency. // There are simple ways to \"diffuse\" the middle address bits over the // generated hashCode values: static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG. // On MP system we'll have lots of RW access to a global, so the // mechanism induces lots of coherency traffic. value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent) // between STW operations. This can be useful in some of the 1-0 // synchronization schemes. intptr_t addrBits = cast_from_oop\u003cintptr_t\u003e(obj) \u003e\u003e 3; value = addrBits ^ (addrBits \u003e\u003e 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop\u003cintptr_t\u003e(obj); } else { // Marsaglia's xor-shift scheme with thread-specific state // This is probably the best overall implementation -- we'll // likely make this the default in future releases. unsigned t = Self-\u003e_hashStateX; t ^= (t \u003c\u003c 11); Self-\u003e_hashStateX = Self-\u003e_hashStateY; Self-\u003e_hashStateY = Self-\u003e_hashStateZ; Self-\u003e_hashStateZ = Self-\u003e_hashStateW; unsigned v = Self-\u003e_hashStateW; v = (v ^ (v \u003e\u003e 19)) ^ (t ^ (t \u003e\u003e 8)); Self-\u003e_hashStateW = v; value = v; } value \u0026= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, \"invariant\"); return value; } ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:2:0","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"equals와 hashCode는 왜 같이 재정의해야 할까? hash 값을 사용하는 Collection(HashMap, HashSet, HashTable)은 객체가 논리적으로 같은지 비교할 때 아래 그림과 같은 과정을 거친다. hashCode 메소드의 반환값을 이용해서 검색의 범위를 확 줄여버리고, 해당 부류 내에 존재하는 데이터의 내용 비교는 equals 메소드를 통해서 진행한다. Object 클래스의 hashCode 메서드는 객체의 고유한 주소 값을 int 값으로 변환하기 때문에 객체마다 다른 값을 리턴한다. 두 개의 Car 객체는 equals로 비교도 하기 전에 서로 다른 hashCode 메서드의 리턴 값으로 인해 다른 객체로 판단된 것이다. 성능에 아주 민감하지 않은 대부분의 프로그램은 간편하게 Objects.hash 메서드를 사용해서 hashCode 메서드를 재정의해도 문제없다. 민감한 경우에는 직접 재정의해주는 게 좋다. @Override public int hashCode() { return Objects.hash(id, fileName, minutes); } Objects 클래스에 정의된 hash 메소드는 다음과 같다. public static int hash(Object... values) { return Arrays.hashCode(values); } Arrays 클래스에 정의된 hashCode 메소드는 다음과 같다. public static int hashCode(Object a[]) { if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; } ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:3:0","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"Iterable 인터페이스 Collection 인터페이스의 상위 인터페이스는 Iterable 이다. package java.lang; public interface Iterable\u003cT\u003e { /** * Returns an iterator over elements of type {@code T}. * * @return an Iterator. */ Iterator\u003cT\u003e iterator(); /** * Performs the given action for each element of the {@code Iterable} * until all elements have been processed or the action throws an * exception. Actions are performed in the order of iteration, if that * order is specified. Exceptions thrown by the action are relayed to the * caller. * \u003cp\u003e * The behavior of this method is unspecified if the action performs * side-effects that modify the underlying source of elements, unless an * overriding class has specified a concurrent modification policy. * * @implSpec * \u003cp\u003eThe default implementation behaves as if: * \u003cpre\u003e{@code * for (T t : this) * action.accept(t); * }\u003c/pre\u003e * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */ default void forEach(Consumer\u003c? super T\u003e action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } } Iterable 인터페이스 안에는 iterator 메소드가 추상메소드로 선언이 되어있다. 이렇게 때문에 Collection 인터페이스 계층구조에서 List, Set, Queue를 구현하는 클래스들은 다 iterator 메소드를 가지고 있다. 따라서 Iterable의 역할은 iterator()메소드를 하위 클래스에서 무조건 구현을 하게 만들기 위함이다. ","date":"2022-02-15","objectID":"/iterable-and-iterator/:1:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"Iterator 인터페이스 Iterator 인터페이스는 Collection과는 별개로 존재하는 인터페이스이다. package java.util; public interface Iterator\u003cE\u003e { /** * Returns {@code true} if the iteration has more elements. * (In other words, returns {@code true} if {@link #next} would * return an element rather than throwing an exception.) * * @return {@code true} if the iteration has more elements */ boolean hasNext(); /** * Returns the next element in the iteration. * * @return the next element in the iteration * @throws NoSuchElementException if the iteration has no more elements */ E next(); /** * Removes from the underlying collection the last element returned * by this iterator (optional operation). This method can be called * only once per call to {@link #next}. * \u003cp\u003e * The behavior of an iterator is unspecified if the underlying collection * is modified while the iteration is in progress in any way other than by * calling this method, unless an overriding class has specified a * concurrent modification policy. * \u003cp\u003e * The behavior of an iterator is unspecified if this method is called * after a call to the {@link #forEachRemaining forEachRemaining} method. * * @implSpec * The default implementation throws an instance of * {@link UnsupportedOperationException} and performs no other action. * * @throws UnsupportedOperationException if the {@code remove} * operation is not supported by this iterator * * @throws IllegalStateException if the {@code next} method has not * yet been called, or the {@code remove} method has already * been called after the last call to the {@code next} * method */ default void remove() { throw new UnsupportedOperationException(\"remove\"); } } Iterator 인터페이스의 내부 구현은 위와 같이 되어있다. 따라서 위의 hasNext(), next(), remove() 등의 메소드를 이용할 수 있다. 용도는 컬렉션클래스의 데이터를 하나씩 읽어올 때 사용한다. 표준화가 되어 있지 않다면 컬렉션 클래스의 데이터를 읽어올 때마다 해당 클래스의 데이터를 꺼내오는 메소드들을 다 알고 있어야 하기 때문에 Iterator이 존재한다. import java.util.Iterator; import java.util.LinkedList; public class Test { public static void main(String[] args) { LinkedList\u003cString\u003e list = new LinkedList\u003c\u003e(); list.add(\"Lee\"); list.add(\"ekk\"); list.add(\"eww\"); Iterator it = list.iterator(); while (it.hasNext()) { System.out.print(it.next() + \" \"); } } } 이처럼 공통 인터페이스를 정의해서 표준을 정의하고 구현하여 표준을 따르도록 함으로써 코드의 일관성을 유지하여 재사용성을 극대화하는 것이 객체지향 프로그래밍의 중요한 목적 중의 하나이다. ","date":"2022-02-15","objectID":"/iterable-and-iterator/:2:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"출처 https://devlog-wjdrbs96.tistory.com/84 ","date":"2022-02-15","objectID":"/iterable-and-iterator/:3:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다. public interface Comparable\u003cT\u003e { int compareTo(T obj); } 사용 예시는 다음과 같다. import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable\u003cPerson\u003e { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void showData() { System.out.printf(\"%s %d \\n\", name, age); } public int compareTo(Person p) { if (age \u003e p.age) return 1; else if (age \u003c p.age) return -1; else return 0; } } class ComparablePerson { public static void main(String[] args) { TreeSet\u003cPerson\u003e sTree = new TreeSet\u003cPerson\u003e(); sTree.add(new Person(\"Lee\", 24)); sTree.add(new Person(\"Hong\", 29)); sTree.add(new Person(\"Choi\", 21)); Iterator\u003cPerson\u003e itr = sTree.iterator(); while (itr.hasNext()) itr.next().showData(); } } ","date":"2022-02-15","objectID":"/comparable-and-comparator/:1:0","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이","uri":"/comparable-and-comparator/"},{"categories":["java"],"content":"Comparator 인터페이스 String 클래스는 이미 compareTo 메소드를 구현하고 있다. 이 때 정령기준을 변경하기 위해서 String 클래스를 상속하는 클래스를 새로 정의하는 것은 번거롭다 따라서 새로운 정렬 기준을 파라미터로 넘길 수 있도록 정의된 것이 Comparator 인터페이스이다. public interface Comparator\u003cT\u003e { int compare(T o1, T o2); } 사용 예시는 다음과 같다. import java.util.TreeSet; import java.util.Iterator; import java.util.Comparator; class StrLenComparator implements Comparator\u003cString\u003e { public int compare(String str1, String str2) { if (str1.length() \u003e str2.length()) return 1; else if (str1.length() \u003c str2.length()) return -1; else return 0; /* * return str1.length()-str2.length(); */ } } class IntroComparator { public static void main(String[] args) { TreeSet\u003cString\u003e tSet = new TreeSet\u003cString\u003e(new StrLenComparator()); tSet.add(\"Orange\"); tSet.add(\"Apple\"); tSet.add(\"Dog\"); tSet.add(\"Individual\"); Iterator\u003cString\u003e itr = tSet.iterator(); while (itr.hasNext()) System.out.println(itr.next()); } } ","date":"2022-02-15","objectID":"/comparable-and-comparator/:2:0","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이","uri":"/comparable-and-comparator/"},{"categories":["spring"],"content":"Spring의 대표적인 핵심가치 3가지로 IoC, AOP, PSA가 있다. ","date":"2022-02-15","objectID":"/spring-psa/:0:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"PSA (Portable Service Abstraction) @Transactional 어노테이션을 선언하는 것 만으로 별도의 코드 추가 없이 트랜잭션 서비스를 사용할 수 있다. 내부적으로 트랜잭션 코드가 추상화되어 숨겨져 있는 것이다. 이렇게 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이며, 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다. ","date":"2022-02-15","objectID":"/spring-psa/:1:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"PSA의 원리 트랜잭션을 예로 들어 설명하겠다. 위 그림처럼 Spring의 @Transactional은 각 TransactionManager를 각각 구현하고 있는 것이 아니라 최상위 PlatformTransactionManager를 이용하고 필요한 TransactionManager를 DI로 주입받아 사용하고 있다. PlatformTransactionManager 인터페이스의 소스코드는 다음과 같다. public interface PlatformTransactionManager extends TransactionManager { TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException; } ","date":"2022-02-15","objectID":"/spring-psa/:2:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["java"],"content":"Java에서 String을 생성하는 방식 Java에서 String을 생성하는 방식은 두가지가 있다. new 연산자를 이용하는 방법 String str = new String(“Hello”); 리터럴을 이용하는 방법 String str = “Hello”; new 연산자를 통해서 생성하게 되면 String은 Heap영역에 존재하게 된다. 하지만 리터럴을 이용할 경우 Heap 영역의 String pool이라는 영역에 존재하게 된다. String a = \"apple\"; String b = new String(\"apple\"); String c = \"apple\"; String d = new String(\"apple\"); System.out.println(a==b); // false System.out.prrintln(a==c); // true 첫 번째 줄에서 String a가 생성될 때, ‘apple’은 리터럴 문자열이므로 Heap영역 중에서 String pool에 위치하게 된다. 두 번째 줄에서 String b는 new연산자를 통해 객체를 생성합니다. Heap영역에 위치하지만 String pool이 아닌 다른 주소값을 참조한다. ‘==‘연산자는 같은 메모리를 참조하는가를 비교한다. 때문에 a와 b의 비교(a==b)는 false를 반환하게 된다. 세번째 줄에서 c가 가리키는 ‘apple’을 String pool에 넣으려고 보니 이미 ‘apple’이 존재한다. 그러면 c는 a와 같은 String pool의 ‘apple’을 가리키게 된다. a와 c가 같은 값을 참조하므로 a==c는 true를 반환합니다. 이를 그림으로 표현해보면 다음과 같다. ","date":"2022-02-14","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:1:0","tags":["string","intern()"],"title":"Java에서 String을 생성하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"리터럴로 선언 시 메모리에서의 동작 String을 리터럴로 선언할 경우 내부적으로 String의 intern()메서드가 호출되게 된다. intern() 메서드는 주어진 문자열이 String pool에 존재하는지 검색하고 있다면 그 주소값을 반환, 없다면 문자열을 String pool에 넣고 그 주소값을 반환한다. String a = \"apple\"; String b = new String(\"apple\"); String c = b.intern() System.out.println(a==b); // false System.out.prrintln(a==c); // true 때문에 c의 경우 b의 값인 ‘apple’이 String pool에 이미 존재하는가를 찾고, 이미 존재하므로 해당 문자열을 반환해 c=‘apple’이 되고, a와 c는 결국 같은 주소를 참조하게 되어 a==c는 true가 된다. ","date":"2022-02-14","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:2:0","tags":["string","intern()"],"title":"Java에서 String을 생성하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"출처 https://simple-ing.tistory.com/3 ","date":"2022-02-14","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:3:0","tags":["string","intern()"],"title":"Java에서 String을 생성하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["design pattern"],"content":"프록시 패턴 Proxy는 우리말로 대리자, 대변인 이라는 뜻이다. 대리자, 대변인은 다른 누군가를 대신해서 그 역할을 수행하는 존재를 말한다. 프록시는 타겟의 기능을 확장하거나 타깃에 대한 접근을 제어하기 위한 목적으로 사용된다. ","date":"2022-02-06","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/:1:0","tags":["dynamic-proxy"],"title":"프록시 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/"},{"categories":["design pattern"],"content":"상속을 사용한 구현 아래와 같은 타겟 클래스가 있다고 하자. public class GameService { public void startGame() { System.out.println(\"Hello\"); } } 다음과 같이 프록시 클래스가 타겟 클래스를 상속받도록 만든다. public class GameServiceProxy extends GameService { @Override public void startGame() { long before = System.currentTimeMillis(); //상위 메소드 실행 super.startGame(); System.out.println(System.currentTimeMillis() - before); } } public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(); gameService.startGame(); } } 결과는 다음과 같다. Hello 0 ","date":"2022-02-06","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/:1:1","tags":["dynamic-proxy"],"title":"프록시 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/"},{"categories":["design pattern"],"content":"인터페이스를 사용한 구현 인터페이스를 사용할 경우, 좀 더 구조가 유연하며 테스트하기에도 쉽다. 다음과 같이 인터페이스를 선언한다. public interface GameService { void startGame(); } 인터페이스를 구현한 클래스를 만들고, 메소드를 오버라이드한다. public class DefaultGameService implements GameService{ @Override public void startGame() { System.out.println(\"Hello\"); } } 다음과 같이 프록시 클래스를 선언한다. @RequiredArgsConstructor public class GameServiceProxy implements GameService { //GameService를 외부에서 주입받는다. private final GameService gameService; @Override public void startGame() { long before = System.currentTimeMillis(); gameService.startGame(); System.out.println(System.currentTimeMillis() - before); } } 클라이언트에서는 GameService 구현체를 생성하여 프록시 객체에 넘겨준다. public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(new DefaultGameService()); gameService.startGame(); } } ","date":"2022-02-06","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/:1:2","tags":["dynamic-proxy"],"title":"프록시 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/"},{"categories":["design pattern"],"content":"다이나믹 프록시 프록시 패턴의 단점은 다음과 같다. 인터페이스를 직접 구현해야 한다. 프록시 클래스 내에 중복이 발생한다. 위와 같은 문제는 다이나믹 프록시를 사용하여 해결할 수 있다. Dynamic Proxy는 런타임 시점에 인터페이스를 구현하는 클래스 또는 인스턴스를 만드는 기술을 말한다. 다이나믹 프록시를 사용하면, 일일이 구현해야한다는 문제는 reflection API가 해결해주고, 중복은 InvocationHandler가 해결해준다. InvocationHandler의 invoke() 메소드에서 타겟의 어떤 메소드에 적용할지 검사하고, 적용해야 하는 메소드라면 타겟의 원래 메소드를 호출하여 결과를 담아둔 뒤 추가 기능을 적용하여 리턴한다. 적용하지 말아야 하는 메소드라면 타겟의 원래 메소드의 리턴을 그대로 리턴한다. BookService bookService = (BookService) Proxy.newProxyInstance(BookService.class.getClassLoader(), new Class[]{BookService.class}, new InvocationHandler() { BookService bookService = new RealSubjectBookService(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName() == \"rent\") { System.out.println(\"11111\"); Object invoke = method.invoke(bookService, args); System.out.println(\"22222\"); return invoke; } return method.invoke(bookService, args); } }); Proxy.newProxyInstance 메소드를 이용해 프록시 객체를 생성한다. 첫번째 인자는 프록시 객체를 생성할 인터페이스 타입의 클래스로더 두번째 인자는 해당 프록시가 어떤 인터페이스를 구현체인가 3번째 인자는 이를 구현하는 InvocationHandler 이다. InvocationHandler는 invoke 메소드를 구현한다. 첫번째 인자는 newProxyInstance를 사용해 생성된 프록시 객체의 참조 두번째 인자는 프록시를 통해 호출된 메소드의 참조 세번째 인자는 해당 메소드의 파라메터들의 참조 invoke 메소드 내에서 method.invoke 를 통해 메소드를 호출할 수 있다. 만약 프록시 객체를 통해 부가적인 기능을 추가하고싶다면 invoke 메소드 내에서 구현을 해주면 된다. ","date":"2022-02-06","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/:2:0","tags":["dynamic-proxy"],"title":"프록시 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/"},{"categories":["java"],"content":"데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다. 결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다. 이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다. public enum PayType { ACCOUNT_TRANSFER(\"계좌이체\"), REMITTANCE(\"무통장입금\"), ON_SITE_PAYMENT(\"현장결제\"), TOSS(\"토스\"), PAYCO(\"페이코\"), CARD(\"신용카드\"), KAKAO_PAY(\"카카오페이\"), BAEMIN_PAY(\"배민페이\"), POINT(\"포인트\"), COUPON(\"쿠폰\"); private final String title; PayType(String title) { this.title = title; } public String getTitle() { return title; } } import lombok.Getter; import java.util.Arrays; import java.util.Collections; import java.util.List; @Getter public enum PayGroup { CASH(\"현금\", Arrays.asList(PayType.ACCOUNT_TRANSFER, PayType.REMITTANCE, PayType.ON_SITE_PAYMENT, PayType.TOSS)), CARD(\"카드\", Arrays.asList(PayType.PAYCO, PayType.CARD, PayType.KAKAO_PAY, PayType.BAEMIN_PAY)), ETC(\"기타\", Arrays.asList(PayType.POINT, PayType.COUPON)), EMPTY(\"없음\", Collections.EMPTY_LIST); private final String title; private final List\u003cPayType\u003e payList; PayGroup(String title, List\u003cPayType\u003e payList) { this.title = title; this.payList = payList; } public static PayGroup findByPayType(PayType payType){ return Arrays.stream(PayGroup.values()) .filter(payGroup -\u003e payGroup.hasPayType(payType)) .findAny() .orElse(EMPTY); } private boolean hasPayType(PayType payType){ return payList.stream() .anyMatch(pay -\u003e pay == payType); } } import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PayGroupTest { @Test public void PayGroup에게_직접_결제종류_물어보기_PayType () { PayType payType = selectPayType(); PayGroup payGroup = PayGroup.findByPayType(payType); assertEquals(payGroup.name(), \"CARD\"); assertEquals(payGroup.getTitle(), \"카드\"); } private PayType selectPayType(){ return PayType.BAEMIN_PAY; } } DB 혹은 API에서 PayType으로 데이터를 받아, 타입 안전성까지 확보하여 PayGroup 관련된 처리를 진행할 수 있게 되었다. ","date":"2022-02-04","objectID":"/enum-usage-2/:1:0","tags":["enum"],"title":"Enum 사용 (활용)","uri":"/enum-usage-2/"},{"categories":["java"],"content":"참고 https://github.com/jojoldu/blog-code/tree/master/enum-settler ","date":"2022-02-04","objectID":"/enum-usage-2/:2:0","tags":["enum"],"title":"Enum 사용 (활용)","uri":"/enum-usage-2/"},{"categories":["java"],"content":"상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 “CALC_A\"일 경우엔 값 그대로, “CALC_B\"일 경우엔 10 한 값을, “CALC_C\"일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 “DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.“는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다. import java.util.function.Function; public enum CalculatorType { CALC_A(value -\u003e value), CALC_B(value -\u003e value * 10), CALC_C(value -\u003e value * 30), CALC_ETC(value -\u003e 0L); private Function\u003cLong, Long\u003e expression; CalculatorType(Function\u003cLong, Long\u003e expression) { this.expression = expression; } public long calculate(long value) { return expression.apply(value); } } import javax.persistence.Column; import javax.persistence.EnumType; import javax.persistence.Enumerated; public class Entity { @Column //@Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다. @Enumerated(EnumType.STRING) private CalculatorType calculatorType; } import org.testng.annotations.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTypeTest { private CalculatorType selectType() { return CalculatorType.CALC_B; } @Test public void 코드에_따라_서로다른_계산하기_Enum() { CalculatorType code = selectType(); long originValue = 10000L; long result = code.calculate(originValue); assertEquals(result, 100000L); } } 값(상태)과 메소드(행위)가 어떤 관계가 있는지에 대해 더이상 다른 곳을 찾을 필요가 없게 되었다. 코드내에 전부 표현되어 있고, Enum 상수에게 직접 물어보면 되기 때문이다. ","date":"2022-02-03","objectID":"/enum-usage-1/:1:0","tags":["enum"],"title":"Enum 사용 (개념)","uri":"/enum-usage-1/"},{"categories":["ML"],"content":"Step Function 활성화 함수는 신경망의 행동을 결정하는 중요한 역할을 합니다. 가장 간단한 형태의 활성화 함수는 계단 함수(Step function) 라고 합니다. 계단 함수는 입력값의 합이 임계값을 넘으면 $0$ 을, 넘지 못하면 $1$ 을 출력하게 됩니다. 계단 함수의 그래프는 다음과 같이 생겼습니다. 이미지 출처 : wikipedia - Heaviside step function 계단 함수는 활성화 함수의 조건을 가장 잘 만족하는 함수이고 직관적으로도 이해하기 쉽습니다. 하지만 불연속 함수라는 단점 때문에 실제 신경망에 사용되지는 않습니다. 그래프를 보면 알 수 있듯 임계값 지점에서 불연속점을 갖게 되는데 이 점에서 미분이 불가능하기 때문에 학습이 필요한 신경망에 사용할 수 없습니다. 이런 문제점을 해결하기 위해서 등장한 것이 시그모이드 함수(Sigmoid) 입니다. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:1:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"Sigmoid Function 시그모이드 함수는 기본적으로 $S$ 모양을 그리는 곡선 함수를 통칭하여 부르는 말입니다. 이 중 대표적인 함수는 로지스틱(Logistic) 함수와 하이퍼탄젠트(Hyper tangent, $\\tanh$) 함수가 있습니다. 두 함수의 수식과 그래프를 보며 시그모이드 함수와 계단 함수가 다른 점이 무엇인지 알아보도록 하겠습니다. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"로지스틱 함수(Logistic Function) $$ \\text{Logistic} : \\frac{1}{1+e^{-x}} $$ 이미지 출처 : wikipedia - Logistic function ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:1","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"하이퍼탄젠트 함수(Hypertangent Function) $$ \\text{Hypertangent} : \\frac{e^x-e^{-x}}{e^x+e^{-x}} = \\frac{e^{2x}-1}{e^{2x}+1} $$ 이미지 출처 : mathworld.wolfram.com 두 함수는 모두 연속함수입니다. 계단 함수의 치명적인 단점이었던 불연속을 해결했지요. 계단 함수와 시그모이드 함수의 중요한 공통점은 비선형 함수(Non-linear) 라는 점입니다. 활성화 함수는 비선형 함수를 사용해야 합니다. 활성화 함수가 선형 함수이면 안되는 이유는 무엇일까요? 선형인 활성화 함수 $l(x) = ax + b$ 가 있다고 해보겠습니다. 이 함수를 사용하여 3개의 층을 쌓는다면 최종적인 활성화 함수는 $l(l(l(x))) = l^3(x) = a(a(ax+b)+b)+b = a^3x+a^2b+ab+b$가 됩니다. $a^3 = c, d = a^2b+ab+b$라고 하면 $l^3(x) = cx+d$로 여전히 같은 형태의 함수를 사용하게 됩니다. 이렇듯 층을 아무리 깊게 쌓아도 여러 층을 쌓는 이점을 살리지 못하게 되지요. 여러 층을 쌓을 때의 장점을 살리기 위해 비선형 함수를 사용하게 되는 것이지요. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:2","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"ReLU Function 시그모이드 함수는 불연속이라는 계단 함수의 단점을 해결했습니다. 하지만 시그모이드는 대부분의 점에서 기울기 값이 0이 됩니다. 이 때문에 **기울기 소실(Gradient vanishing)**이라는 문제가 발생합니다. 기울기 소실은 시그모이드 함수를 활성화 함수로 사용하여 층을 깊게 쌓았을 때 학습이 잘 되지 않는 현상입니다. 이런 현상이 왜 발생하는지 알아보겠습니다. 로지스틱 함수 $L(x)$를 미분한 함수 $L^\\prime(x)$ 의 수식은 다음과 같습니다. $$ L^\\prime(x) = \\bigg(\\frac{1}{1+e^{-x}}\\bigg)^\\prime = \\frac{e^x}{(1+e^{-x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 그래프에서 볼 수 있듯 최댓값이 $0.25$ 밖에 되지 않고 $x\u003c-5, x\u003e5$ 범위에서는 거의 $0$ 에 가깝습니다. 역전파(Back propagation) 과정에서는 미분값을 사용하여 학습을 하게 됩니다. 따라서 이 값이 0에 가까워 지면 정보가 유실되면서 학습이 잘 안되게 됩니다. 특히 층을 깊게 쌓을 경우에는 정보가 모두 유실되는 사태가 발생하게 되지요. 그렇다면 하이퍼탄젠트 함수는 어떻게 될까요? 하이퍼탄젠트 함수 $\\tanh$를 미분한 함수의 수식은 다음과 같습니다. $$ \\tanh^\\prime(x) = \\bigg(\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\bigg)^\\prime = \\frac{4e^{2x}}{(1+e^{2x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 하이퍼탄젠트 함수를 미분한 함수의 최댓값은 $1$ 입니다. 최댓값이 $0.25$ 밖에 안되었던 로지스틱 함수 보다는 정보를 잘 전달하게 되지요. 하지만 여전히 $x$ 가 0에서 멀어질수록 원래 함수의 미분값은 0에 가까워집니다. 그래서 하이퍼탄젠트 함수를 활성화 함수로 하더라도 퍼셉트론을 여러 층으로 쌓는다면 학습이 제대로 안되게 되지요. 이렇게 시그모이드 함수를 활성화 함수로 사용할 때 역전파시 학습이 제대로 진행되지 않는 현상을 기울기 소실이라고 합니다. 기울기 소실 문제를 극복하기 위해서 등장한 함수가 바로 ReLU(Rectified Linear Unit)함수입니다. ReLU함수는 입력값이 0보다 작을 경우에는 0을 반환하고, 0보다 클 경우에는 입력값을 그대로 반환합니다. 아래는 ReLU함수의 그래프를 나타낸 것입니다. 이미지 출처 : medium.com ReLU함수는 $x$ 가 $0$ 보다 클 때, 미분값이 항상 $1$ 입니다. 그래서 층이 아무리 깊어져도 손실없이 정보를 전달할 수 있습니다. 미분값이 항상 $0$과 $1$ 이기 때문에 연산이 빠르다는 점도 ReLU함수의 장점입니다. 덕분에 ReLU함수는 은닉층에서 가장 많이 사용되는 활성화 함수가 되었습니다. 물론 ReLU함수에게도 문제가 있습니다. 0이하의 값이 그대로 보존되지 않고 버려진다는 것이지요. 이를 보완하기 위해 Leaky ReLU함수가 고안되어 사용되고 있습니다. 일반적으로는 $a=0.01$을 사용하며 그래프는 다음과 같습니다. 이미지 출처 : medium.com ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:3:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["spring"],"content":"Spring mocking 없이 테스트하려면? 아래 코드를 mocking 없이 테스트하려면 어떻게 해야 할까? package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import java.io.IOException; public class RepositoryRank { public int getPoint(String repositoryName) throws IOException { GitHub github = GitHub.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u003e 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public static void main(String[] args) throws IOException { RepositoryRank repositoryRank = new RepositoryRank(); int point = repositoryRank.getPoint(\"whiteship/live-study\"); System.out.println(point); } } Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입하면 된다. 설명과 코드는 다음과 같다. package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import org.kohsuke.github.GitHubBuilder; import java.io.IOException; public class RepositoryRank { //인터페이스 선언 interface GitHubService { GitHub connect() throws IOException; } //인터페이스를 구현한 클래스 생성하고 모킹하고자 하는 메소드를 오버라이드한다. static class DefaultGitHubService implements GitHubService { @Override public GitHub connect() throws IOException { return new GitHubBuilder().build(); } } private final GitHubService gitHubService; //서비스를 주입받는다. public RepositoryRank(GitHubService gitHubService) { this.gitHubService = gitHubService; } public int getPoint(String repositoryName) throws IOException { GitHub github = gitHubService.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u003e 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public void main(String[] args) throws IOException { GitHubService gitHubService = new DefaultGitHubService(); //Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입 RepositoryRank repositoryRank = new RepositoryRank(gitHubService); int point = repositoryRank.getPoint(\"whiteship/live-study\"); System.out.println(point); } } ","date":"2022-01-01","objectID":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/:1:0","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법","uri":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/"},{"categories":["spring"],"content":"참고 백기선님의 유튜브를 참고했다. https://youtu.be/bJfbPWEMj_c ","date":"2022-01-01","objectID":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/:2:0","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법","uri":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/"}]