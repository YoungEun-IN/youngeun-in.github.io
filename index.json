[{"categories":["spring"],"content":"리액터(Reactor) 리액터(Reactor)란 리액티브 프로그래밍을 위한 리액티브 라이브러리이다. Reactive Streams 스펙을 구현한 구현체 중 하나이다. Spring 에코 시스템에서 Reactive Stack의 기반이 되며 Spring WebFlux 프레임워크에 포함이 되어 있다. ","date":"2024-03-05","objectID":"/webflux-webclient/:1:0","tags":["WebFlux","WebClient"],"title":"WebFlux, WebClient","uri":"/webflux-webclient/"},{"categories":["spring"],"content":"Spring Webflux Spring Webflux란 Spring 5부터 지원하는 리액티브 웹 프레임워크이다. 비동기 Non-Blocking I/O 방식으로 적은 수의 쓰레드를 사용한다. Spring Webflux는 Reactive Streams의 구현체 중에 하나인 Reactor에 의존하여 비동기 로직을 구성하고 리액티브 스트림을 제공한다. Spring Webflux는 적은 수의 스레드를 사용하여 여러 클라이언트의 요청을 처리할수 있고, 자원(메모리,CPU)를 효율적으로 사용할수 있다. Spring WebFlux를 사용하기 적합한 시스템은 다음과 같다. Blocking I/O 방식으로 처리하는데 한계가 있는 대량의 요청 트래픽이 발생하는 시스템 마이크로 서비스 기반 시스템 스트리밍 시스템 또는 실시간 시스템 네트워크 접속이 느린 클라이언트의 요청 처리가 필요한 시스템 ","date":"2024-03-05","objectID":"/webflux-webclient/:2:0","tags":["WebFlux","WebClient"],"title":"WebFlux, WebClient","uri":"/webflux-webclient/"},{"categories":["spring"],"content":"Spring WebClient WebClient는 Spring WebFlux에서 HTTP Client로 사용되는 비동기적으로 작동하는 모듈이다. 내부적으로 WebClient는 HTTP Client 라이브러리에 위임하는데 디폴트로 Netty의 Http Client를 사용한다. ","date":"2024-03-05","objectID":"/webflux-webclient/:3:0","tags":["WebFlux","WebClient"],"title":"WebFlux, WebClient","uri":"/webflux-webclient/"},{"categories":["spring"],"content":"참고 https://velog.io/@rnqhstlr2297/Spring-Webflux%EC%99%80-WebClient https://www.inflearn.com/course/spring-reactive-web-application-reactor1%EB%B6%80 ","date":"2024-03-05","objectID":"/webflux-webclient/:4:0","tags":["WebFlux","WebClient"],"title":"WebFlux, WebClient","uri":"/webflux-webclient/"},{"categories":["설계방법론"],"content":"프록시 패턴 package hello.proxy.pureproxy.proxy.code; public interface Subject { String operation(); } 예제에서 Subject 인터페이스는 단순히 operation() 메서드 하나만 가지고 있다. package hello.proxy.pureproxy.proxy.code; import lombok.extern.slf4j.Slf4j; @Slf4j public class RealSubject implements Subject { @Override public String operation() { log.info(\"실제 객체 호출\"); sleep(1000); return \"data\"; } private void sleep(int millis) { try { Thread.sleep(millis); } catch (InterruptedException e) { e.printStackTrace(); } } } RealSubject 는 Subject 인터페이스를 구현했다. operation() 은 데이터 조회를 시뮬레이션 하기 위해 1초 쉬도록 했다. 예를 들어서 데이터를 DB나 외부에서 조회하는데 1초가 걸린다고 생각하면 된다. 호출할 때 마다 시스템에 큰 부하를 주는 데이터 조회라고 가정하자. package hello.proxy.pureproxy.proxy.code; import lombok.extern.slf4j.Slf4j; public class ProxyPatternClient { private Subject subject; public ProxyPatternClient(Subject subject) { this.subject = subject; } public void execute() { subject.operation(); } } Subject 인터페이스에 의존하고, Subject 를 호출하는 클라이언트 코드이다. execute() 를 실행하면 subject.operation() 를 호출한다. package hello.proxy.pureproxy.proxy; import lombok.extern.slf4j.Slf4j; import hello.proxy.pureproxy.proxy.code.ProxyPatternClient; import hello.proxy.pureproxy.proxy.code.RealSubject; import hello.proxy.pureproxy.proxy.code.Subject; import org.junit.jupiter.api.Test; public class ProxyPatternTest { @Test void noProxyTest() { RealSubject realSubject = new RealSubject(); ProxyPatternClient client = new ProxyPatternClient(realSubject); client.execute(); client.execute(); client.execute(); } } 테스트 코드에서는 client.execute() 를 3번 호출한다. 데이터를 조회하는데 1초가 소모되므로 총 3초의 시간이 걸린다. RealSubject - 실제 객체 호출 RealSubject - 실제 객체 호출 RealSubject - 실제 객체 호출 결과는 위와 같다. 이미 개발된 로직을 전혀 수정하지 않고, 프록시 객체를 통해서 캐시를 적용해보자. package hello.proxy.pureproxy.proxy.code; import lombok.extern.slf4j.Slf4j; @Slf4j public class CacheProxy implements Subject { private Subject target; private String cacheValue; public CacheProxy(Subject target) { this.target = target; } @Override public String operation() { log.info(\"프록시 호출\"); if (cacheValue == null) { cacheValue = target.operation(); } return cacheValue; } } 프록시도 실제 객체와 그 모양이 같아야 하기 때문에 Subject 인터페이스를 구현해야 한다. package hello.proxy.pureproxy.proxy; import lombok.extern.slf4j.Slf4j; import hello.proxy.pureproxy.proxy.code.CacheProxy; import hello.proxy.pureproxy.proxy.code.ProxyPatternClient; import hello.proxy.pureproxy.proxy.code.RealSubject; import hello.proxy.pureproxy.proxy.code.Subject; import org.junit.jupiter.api.Test; public class ProxyPatternTest { @Test void noProxyTest() { RealSubject realSubject = new RealSubject(); ProxyPatternClient client = new ProxyPatternClient(realSubject); client.execute(); client.execute(); client.execute(); } @Test void cacheProxyTest() { Subject realSubject = new RealSubject(); Subject cacheProxy = new CacheProxy(realSubject); ProxyPatternClient client = new ProxyPatternClient(cacheProxy); client.execute(); client.execute(); client.execute(); } } realSubject 와 cacheProxy 를 생성하고 둘을 연결한다. 결과적으로 cacheProxy 가 realSubject 를 참조하는 런타임 객체 의존관계가 완성된다. 그리고 마지막으로 client 에 realSubject 가 아닌 cacheProxy 를 주입한다. 이 과정을 통해서 client -\u003e cacheProxy -\u003e realSubject 런타임 객체 의존 관계가 완성된다. cacheProxyTest() 는 client.execute() 을 총 3번 호출한다. 이번에는 클라이언트가 실제 realSubject를 호출하는 것이 아니라 cacheProxy 를 호출하게 된다. CacheProxy - 프록시 호출 RealSubject - 실제 객체 호출 CacheProxy - 프록시 호출 CacheProxy - 프록시 호출 실행 결과는 위와 같다. 결과적으로 캐시 프록시를 도입하기 전에는 3초가 걸렸지만, 캐시 프록시 도입 이후에는 최초에 한번만 1초가 걸리고, 이후에는 거의 즉시 반환한다. 프록시 패턴의 핵심은 클라이언트 코드의 변경 없이 자유롭게 프록시를 넣고 뺄 수 있다는 것이다. 실제 클라이언트 입장에서는 프록시 객체가 주입되었는지, 실제 객체가 주입되었는지 알지 못한다. ","date":"2024-02-02","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/:1:0","tags":["proxy-pattern","decorator-pattern"],"title":"프록시 패턴, 데코레이터 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/"},{"categories":["설계방법론"],"content":"프록시 패턴 vs 데코레이터 패턴 데코레이터 패턴의 의존관계는 다음과 같다. 이처럼 프록시 패턴과 데코레이터 패턴은 그 모양이 거의 같고, 상황에 따라 정말 똑같을 때도 있다. 디자인 패턴에서 중요한 것은 해당 패턴의 겉모양이 아니라 그 패턴을 만든 의도이다. 따라서 의도에 따라 패턴을 구분한다. 프록시 패턴의 의도: 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공 권한에 따른 접근 차단 캐싱 지연 로딩 데코레이터 패턴의 의도: 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행 예) 요청 값이나, 응답 값을 중간에 변형한다. 예) 실행 시간을 측정해서 추가 로그를 남긴다. 즉 프록시를 사용하고 해당 프록시가 접근 제어가 목적이라면 프록시 패턴이고, 새로운 기능을 추가하는 것이 목적이라면 데코레이터 패턴이 된다. ","date":"2024-02-02","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/:2:0","tags":["proxy-pattern","decorator-pattern"],"title":"프록시 패턴, 데코레이터 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/"},{"categories":["설계방법론"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8 ","date":"2024-02-02","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/:3:0","tags":["proxy-pattern","decorator-pattern"],"title":"프록시 패턴, 데코레이터 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/"},{"categories":["설계방법론"],"content":"템플릿 메서드 패턴 템플릿은 기준이 되는 거대한 틀이다. 템플릿이라는 틀에 변하지 않는 부분을 몰아둔다. 그리고 일부 변하는 부분을 별도로 호출해서 해결한다. 템플릿 메서드 패턴은 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 일부 변경되는 로직은 자식 클래스에 정의하는 것이다. 이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의할 수 있다. 결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것이다. package hello.advanced.trace.template.code; import lombok.extern.slf4j.Slf4j; @Slf4j public abstract class AbstractTemplate { public void execute() { long startTime = System.currentTimeMillis(); //비즈니스 로직 실행 call(); //상속 //비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"resultTime={}\", resultTime); } protected abstract void call(); } AbstractTemplate 코드를 보자. 변하지 않는 부분인 시간 측정 로직을 몰아둔 것을 확인할 수 있다. 이제 이것이 하나의 템플릿이 된다. 그리고 템플릿 안에서 변하는 부분은 call() 메서드를 호출해서 처리한다. 템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿 코드를 둔다. 그리고 변하는 부분은 자식 클래스에 두고 상속과 오버라이딩을 사용해서 처리한다. package hello.advanced.trace.template.code; import lombok.extern.slf4j.Slf4j; @Slf4j public class SubClassLogic1 extends AbstractTemplate { @Override protected void call() { log.info(\"비즈니스 로직1 실행\"); } } 변하는 부분인 비즈니스 로직1을 처리하는 자식 클래스이다. 템플릿이 호출하는 대상인 call() 메서드를 오버라이딩한다. package hello.advanced.trace.template.code; import lombok.extern.slf4j.Slf4j; @Slf4j public class SubClassLogic2 extends AbstractTemplate { @Override protected void call() { log.info(\"비즈니스 로직2 실행\"); } } 변하는 부분인 비즈니스 로직2를 처리하는 자식 클래스이다. 템플릿이 호출하는 대상인 call() 메서드를 오버라이딩한다. /** * 템플릿 메서드 패턴 적용 */ @Test void templateMethodV1() { AbstractTemplate template1 = new SubClassLogic1(); template1.execute(); AbstractTemplate template2 = new SubClassLogic2(); template2.execute(); } 템플릿 메서드 패턴으로 구현한 코드를 실행해보자. 비즈니스 로직1 실행 resultTime=0 비즈니스 로직2 실행 resultTime=1 이처럼 템플릿 메서드 패턴은 다형성을 사용해서 변하는 부분과 변하지 않는 부분을 분리하는 방법이다. ","date":"2024-02-01","objectID":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/:1:0","tags":["template-method-pattern","strategy-pattern","template-callback-pattern"],"title":"템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴","uri":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/"},{"categories":["설계방법론"],"content":"템플릿 메서드 패턴의 단점 템플릿 메서드 패턴은 상속을 사용한다. 따라서 상속에서 오는 단점들을 그대로 안고간다. 특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다. 이것은 의존관계에 대한 문제이다. 자식 클래스의 extends 다음에 바로 부모 클래스가 코드상에 지정되어 있다. 따라서 부모 클래스의 기능을 사용하든 사용하지 않든 간에 부모 클래스를 강하게 의존하게 된다. 여기서 강하게 의존한다는 뜻은 자식 클래스의 코드에 부모 클래스의 코드가 명확하게 적혀 있다는 뜻이다. 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는데, 부모 클래스를 알아야한다. 이것은 좋은 설계가 아니다. 그리고 이런 잘못된 의존관계 때문에 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있다. 추가로 템플릿 메서드 패턴은 상속 구조를 사용하기 때문에, 별도의 클래스나 익명 내부 클래스를 만들어야 하는 부분도 복잡하다. ","date":"2024-02-01","objectID":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/:1:1","tags":["template-method-pattern","strategy-pattern","template-callback-pattern"],"title":"템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴","uri":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/"},{"categories":["설계방법론"],"content":"전략 패턴 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이 전략 패턴(Strategy Pattern)이다. 전략 패턴은 변하지 않는 부분을 Context 라는 곳에 두고, 변하는 부분을 Strategy 라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 상속에 의한 강한 의존성 문제를 해결한다. 상속이 아니라 위임으로 문제를 해결하는 것이다. 전략 패턴에서 Context 는 변하지 않는 템플릿 역할을 하고, Strategy 는 변하는 알고리즘 역할을 한다. package hello.advanced.trace.strategy.code.strategy; public interface Strategy { void call(); } 이 인터페이스는 변하는 알고리즘 역할을 한다. package hello.advanced.trace.strategy.code.strategy; import lombok.extern.slf4j.Slf4j; @Slf4j public class StrategyLogic1 implements Strategy { @Override public void call() { log.info(\"비즈니스 로직1 실행\"); } } 변하는 알고리즘은 Strategy 인터페이스를 구현하면 된다. 여기서는 비즈니스 로직1을 구현했다. package hello.advanced.trace.strategy.code.strategy; import lombok.extern.slf4j.Slf4j; @Slf4j public class StrategyLogic2 implements Strategy { @Override public void call() { log.info(\"비즈니스 로직1 실행\"); } } 비즈니스 로직2를 구현했다. package hello.advanced.trace.strategy.code.strategy; import lombok.extern.slf4j.Slf4j; /** * 필드에 전략을 보관하는 방식 */ @Slf4j public class ContextV1 { private Strategy strategy; public ContextV1(Strategy strategy) { this.strategy = strategy; } public void execute() { long startTime = System.currentTimeMillis(); //비즈니스 로직 실행 strategy.call(); //위임 //비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"resultTime={}\", resultTime); } } ContextV1 은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다. 전략 패턴에서는 이것을 컨텍스트(문맥)이라 한다. 쉽게 이야기해서 컨텍스트(문맥)는 크게 변하지 않지만, 그 문맥 속에서 strategy 를 통해 일부 전략이 변경되는 것이다. Context는 내부에 Strategy strategy 필드를 가지고 있다. 이 필드에 변하는 부분인 Strategy 의 구현체를 주입하면 된다. 전략 패턴의 핵심은 Context 는 Strategy 인터페이스에만 의존한다는 점이다. 덕분에 Strategy 의 구현체를 변경하거나 새로 만들어도 Context 코드에는 영향을 주지 않는다. /** * 전략 패턴 적용 */ @Test void strategyV1() { Strategy strategyLogic1 = new StrategyLogic1(); ContextV1 context1 = new ContextV1(strategyLogic1); context1.execute(); Strategy strategyLogic2 = new StrategyLogic2(); ContextV1 context2 = new ContextV1(strategyLogic2); context2.execute(); } 전략 패턴을 사용하는 코드를 보면 의존관계 주입을 통해 ContextV1 에 Strategy의 구현체인 strategyLogic1 를 주입하는 것을 확인할 수 있다. 이렇게 해서 Context 안에 원하는 전략을 주입한다. 이렇게 원하는 모양으로 조립을 완료하고 난 다음에 context1.execute() 를 호출해서 context를 실행한다. StrategyLogic1 - 비즈니스 로직1 실행 ContextV1 - resultTime=3 StrategyLogic2 - 비즈니스 로직2 실행 ContextV1 - resultTime=0 ","date":"2024-02-01","objectID":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/:2:0","tags":["template-method-pattern","strategy-pattern","template-callback-pattern"],"title":"템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴","uri":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/"},{"categories":["설계방법론"],"content":"템플릿 콜백 패턴 앞에서는 Context의 필드에 Strategy를 주입해서 사용했다. 이번에는 전략을 실행할 때 직접 파라미터로 전달해서 사용해보자. package hello.advanced.trace.strategy.code.strategy; import lombok.extern.slf4j.Slf4j; /** * 전략을 파라미터로 전달 받는 방식 */ @Slf4j public class ContextV2 { public void execute(Strategy strategy) { long startTime = System.currentTimeMillis(); //비즈니스 로직 실행 strategy.call(); //위임 //비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"resultTime={}\", resultTime); } } ContextV2 는 전략을 필드로 가지지 않는다. 대신에 전략을 execute(..) 가 호출될 때 마다 항상 파라미터로 전달받는다. package hello.advanced.trace.strategy; import hello.advanced.trace.strategy.code.strategy.ContextV2; import hello.advanced.trace.strategy.code.strategy.StrategyLogic1; import hello.advanced.trace.strategy.code.strategy.StrategyLogic2; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; @Slf4j public class ContextV2Test { /** * 전략 패턴 적용 */ @Test void strategyV1() { ContextV2 context = new ContextV2(); context.execute(new StrategyLogic1()); context.execute(new StrategyLogic2()); } } Context 와 Strategy를 ‘선 조립 후 실행’하는 방식이 아니라 Context를 실행할 때 마다 전략을 인수로 전달한다. 이로써 클라이언트는 Context 를 실행하는 시점에 원하는 Strategy 를 전달할 수 있다. 따라서 이전 방식과 비교해서 원하는 전략을 더욱 유연하게 변경할 수 있다. 테스트 코드를 보면 하나의 Context만 생성한다. 그리고 Context 실행 시점에 여러 전략을 인수로 전달해서 유연하게 실행하는 것을 확인할 수 있다. ContextV2는 변하지 않는 템플릿 역할을 한다. 그리고 변하는 부분은 파라미터로 넘어온 Strategy 의 코드를 실행해서 처리한다. 이렇게 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 콜백(callback)이라 한다. 스프링에서는 ContextV2 와 같은 방식의 전략 패턴을 템플릿 콜백 패턴이라 한다. 전략 패턴에서 Context가 템플릿 역할을 하고, Strategy 부분이 콜백으로 넘어온다 생각하면 된다. 스프링에서는 JdbcTemplate , RestTemplate , TransactionTemplate , RedisTemplate 처럼 다양한 템플릿 콜백 패턴이 사용된다. 스프링에서 이름에 XxxTemplate 가 있다면 템플릿 콜백 패턴으로 만들어져 있는 것이다. ","date":"2024-02-01","objectID":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/:3:0","tags":["template-method-pattern","strategy-pattern","template-callback-pattern"],"title":"템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴","uri":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/"},{"categories":["설계방법론"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8 ","date":"2024-02-01","objectID":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/:4:0","tags":["template-method-pattern","strategy-pattern","template-callback-pattern"],"title":"템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴","uri":"/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4/"},{"categories":["spring"],"content":"Spring에서 사용하는 어노테이션 ‘@Transactional’은 해당 메서드를 하나의 트랜잭션 안에서 진행할 수 있도록 만들어주는 역할을 한다. 이때 트랜잭션 내부에서 트랜잭션을 또 호출한다면 스프링에서는 새로운 트랜잭션이 생성될 수도 있고, 이미 트랜잭션이 있다면 부모 트랜잭션에 합류할 수도 있을 것이다. 진행되고 있는 트랜잭션에서 다른 트랜잭션이 호출될 때 어떻게 처리할지 정하는 것을 ‘트랜잭션의 전파 설정’이라고 부른다. ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:0:0","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"전파 설정 옵션 트랜잭션의 전파 설정은 ‘@Transactional’의 옵션 ‘propagation’을 통해 설정할 수 있다. 각 옵션은 아래와 같다. ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:1:0","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"REQUIRED (기본값) 부모 트랜잭션이 존재한다면 부모 트랜잭션으로 합류한다. 부모 트랜잭션이 없다면 새로운 트랜잭션을 생성한다. 중간에 롤백이 발생한다면 모두 하나의 트랜잭션이기 때문에 진행사항이 모두 롤백된다. ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:1:1","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"REQUIRES_NEW 무조건 새로운 트랜잭션을 생성한다. 각각의 트랜잭션이 롤백되더라도 서로 영향을 주지 않는다. ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:1:2","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"MANDATORY 부모 트랜잭션에 합류한다. 만약 부모 트랜잭션이 없다면 예외를 발생시킨다. ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:1:3","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"NESTED 부모 트랜잭션이 존재한다면 중첩 트랜잭션을 생성한다. 중첩된 트랜잭션 내부에서 롤백 발생시 해당 중첩 트랜잭션의 시작 지점 까지만 롤백된다. 중첩 트랜잭션은 부모 트랜잭션이 커밋될 때 같이 커밋된다. 부모 트랜잭션이 존재하지 않는다면 새로운 트랜잭션을 생성한다. ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:1:4","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"NEVER ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:1:5","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"SUPPORTS 부모 트랜잭션이 있다면 합류한다. 진행중인 부모 트랜잭션이 없다면 트랜잭션을 생성하지 않는다. ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:1:6","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"NOT_SUPPORTED 부모 트랜잭션이 있다면 보류시킨다. 진행중인 부모 트랜잭션이 없다면 트랜잭션을 생성하지 않는다. ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:1:7","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"참고 https://deveric.tistory.com/86 ","date":"2023-11-20","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/:2:0","tags":["transaction","propagation"],"title":"트랜잭션 전파 설정","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"DispatcherServlet 구조 스프링 MVC는 프론트 컨트롤러 패턴으로 구현되어 있다. 스프링 MVC의 프론트 컨트롤러가 디스패처 서블릿(DispatcherServlet)이다. FrontController 패턴 특징은 다음과 같다. 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호 입구를 하나로 하여 공통 처리 가능 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨 DispacherServlet는 부모 클래스에서 HttpServlet 을 상속 받아서 사용하고, 서블릿으로 동작한다. 상속관계는 다음과 같다. DispatcherServlet -\u003e FrameworkServlet -\u003e HttpServletBean -\u003e HttpServlet 요청흐름은 다음과 같다. 서블릿이 호출되면 HttpServlet 이 제공하는 serivce() 가 호출된다. 스프링 MVC는 DispatcherServlet 의 부모인 FrameworkServlet 에서 service() 를 오버라이드 해두었다. FrameworkServlet.service() 를 시작으로 여러 메서드가 호출되면서 DispacherServlet.doDispatch() 가 호출된다. 스프링 부트는 DispacherServlet 을 서블릿으로 자동으로 등록하면서 모든 경로( urlPatterns=\"/\" )에 대해서 매핑한다. 더 자세한 경로가 우선순위가 높으므로 기존에 등록한 서블릿도 함께 동작한다. ","date":"2023-11-12","objectID":"/spring-mvc-%EA%B5%AC%EC%A1%B0/:1:0","tags":["mvc"],"title":"Spring MVC 구조","uri":"/spring-mvc-%EA%B5%AC%EC%A1%B0/"},{"categories":["spring"],"content":"요청 흐름 핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다. 핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다. 핸들러 어댑터 실행: 핸들러 어댑터를 실행한다. 핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다. ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다. viewResolver 호출: 뷰 리졸버를 찾고 실행한다. JSP의 경우: InternalResourceViewResolver 가 자동 등록되고, 사용된다. View반환: 뷰리졸버는 뷰의 논리이름을 물리이름으로 바꾸고, 렌더링 역할을 담당하는 뷰객체를 반환한다. JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다. 뷰렌더링: 뷰를 통해서 뷰를 렌더링한다. ","date":"2023-11-12","objectID":"/spring-mvc-%EA%B5%AC%EC%A1%B0/:2:0","tags":["mvc"],"title":"Spring MVC 구조","uri":"/spring-mvc-%EA%B5%AC%EC%A1%B0/"},{"categories":["spring"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1 ","date":"2023-11-12","objectID":"/spring-mvc-%EA%B5%AC%EC%A1%B0/:3:0","tags":["mvc"],"title":"Spring MVC 구조","uri":"/spring-mvc-%EA%B5%AC%EC%A1%B0/"},{"categories":["spring"],"content":"서블릿과 JSP의 한계 서블릿으로 개발할 때는 뷰(View)화면을 위한 HTML을 만드는 작업이 자바 코드에 섞여서 지저분하고 복잡했다. JSP를 사용한 덕분에 뷰를 생성하는 HTML 작업을 깔끔하게 가져가고, 중간중간 동적으로 변경이 필요한 부분에만 자바 코드를 적용했다. 그러나 이러한 형태는 비즈니스 로직과 뷰 영역이 혼재되어 코드를 이해하기 어렵고 유지보수가 힘들어진다는 단점이 있다. ","date":"2023-11-11","objectID":"/mvc-%ED%8C%A8%ED%84%B4/:1:0","tags":["mvc"],"title":"MVC 패턴","uri":"/mvc-%ED%8C%A8%ED%84%B4/"},{"categories":["spring"],"content":"MVC 패턴 - 개요 하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면, 변경의 라이프 사이클이 다르기 때문에 유지보수하기 좋지 않다. MVC 패턴은 지금까지 학습한 것 처럼 하나의 서블릿이나, JSP로 처리하던 것을 컨트롤러(Controller)와 뷰(View)라는 영역으로 서로 역할을 나눈 것을 말한다. 웹 애플리케이션은 보통 이 MVC 패턴을 사용한다. 컨트롤러: HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다. 그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다. 모델: 뷰에 출력할 데이터를 담아둔다. 뷰가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 렌더링 하는 일에 집중할 수 있다. 뷰: 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다. 여기서는 HTML을 생성하는 부분을 말한다. ","date":"2023-11-11","objectID":"/mvc-%ED%8C%A8%ED%84%B4/:2:0","tags":["mvc"],"title":"MVC 패턴","uri":"/mvc-%ED%8C%A8%ED%84%B4/"},{"categories":["spring"],"content":"MVC 패턴 - 한계 MVC 패턴을 적용한 덕분에 컨트롤러의 역할과 뷰를 렌더링 하는 역할을 명확하게 구분할 수 있다. 특히 뷰는 화면을 그리는 역할에 충실한 덕분에, 코드가 깔끔하고 직관적이다. 단순하게 모델에서 필요한 데이터를 꺼내고, 화면을 만들면 된다. 그런데 컨트롤러는 딱 봐도 중복이 많고, 필요하지 않는 코드들도 많이 보인다. ","date":"2023-11-11","objectID":"/mvc-%ED%8C%A8%ED%84%B4/:3:0","tags":["mvc"],"title":"MVC 패턴","uri":"/mvc-%ED%8C%A8%ED%84%B4/"},{"categories":["spring"],"content":"포워드 중복 View로 이동하는 코드가 항상 중복 호출되어야 한다. 물론 이 부분을 메서드로 공통화해도 되지만, 해당 메서드도 항상 직접 호출해야 한다. RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request, response); ","date":"2023-11-11","objectID":"/mvc-%ED%8C%A8%ED%84%B4/:3:1","tags":["mvc"],"title":"MVC 패턴","uri":"/mvc-%ED%8C%A8%ED%84%B4/"},{"categories":["spring"],"content":"ViewPath 중복 String viewPath = \"/WEB-INF/views/new-form.jsp\"; prefix: /WEB-INF/views/ suffix: .jsp 그리고 만약 jsp가 아닌 thymeleaf 같은 다른 뷰로 변경한다면 전체 코드를 다 변경해야 한다. ","date":"2023-11-11","objectID":"/mvc-%ED%8C%A8%ED%84%B4/:3:2","tags":["mvc"],"title":"MVC 패턴","uri":"/mvc-%ED%8C%A8%ED%84%B4/"},{"categories":["spring"],"content":"사용하지 않는 코드 다음 코드를 사용할 때도 있고, 사용하지 않을 때도 있다. HttpServletRequest request, HttpServletResponse response ","date":"2023-11-11","objectID":"/mvc-%ED%8C%A8%ED%84%B4/:3:3","tags":["mvc"],"title":"MVC 패턴","uri":"/mvc-%ED%8C%A8%ED%84%B4/"},{"categories":["spring"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1 ","date":"2023-11-11","objectID":"/mvc-%ED%8C%A8%ED%84%B4/:4:0","tags":["mvc"],"title":"MVC 패턴","uri":"/mvc-%ED%8C%A8%ED%84%B4/"},{"categories":["web"],"content":"웹 서버(Web Server) HTTP 기반으로 동작 정적 리소스 제공, 기타 부가기능 정적(파일) HTML, CSS, JS, 이미지, 영상 예) NGINX, APACHE ","date":"2023-11-10","objectID":"/web-server-vs-was/:1:0","tags":["web-server","was"],"title":"Web Server vs WAS","uri":"/web-server-vs-was/"},{"categories":["web"],"content":"웹 애플리케이션 서버(WAS - Web Application Server) HTTP 기반으로 동작 웹 서버 기능 포함+ (정적 리소스 제공 가능) 프로그램 코드를 실행해서 애플리케이션 로직 수행 동적 HTML, HTTP API(JSON) 서블릿, JSP, 스프링 MVC 예) 톰캣(Tomcat) Jetty, Undertow ","date":"2023-11-10","objectID":"/web-server-vs-was/:2:0","tags":["web-server","was"],"title":"Web Server vs WAS","uri":"/web-server-vs-was/"},{"categories":["web"],"content":"웹 서버, 웹 애플리케이션 서버(WAS) 차이 웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직 사실은 둘의 용어도 경계도 모호함 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함 웹 애플리케이션 서버도 웹 서버의 기능을 제공함 자바는 서블릿 컨테이너 기능을 제공하면 WAS 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있음 WAS는 애플리케이션 코드를 실행하는데 더 특화 ","date":"2023-11-10","objectID":"/web-server-vs-was/:3:0","tags":["web-server","was"],"title":"Web Server vs WAS","uri":"/web-server-vs-was/"},{"categories":["web"],"content":"웹 시스템 구성 - WEB, WAS, DB 정적 리소스는 웹 서버가 처리 웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임 WAS는 중요한 애플리케이션 로직 처리 전담 효율적인 리소스 관리 정적 리소스가 많이 사용되면 Web 서버 증설 애플리케이션 리소스가 많이 사용되면 WAS 증설 WAS, DB 장애시 WEB 서버가 오류 화면 제공 가능 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽음 ","date":"2023-11-10","objectID":"/web-server-vs-was/:4:0","tags":["web-server","was"],"title":"Web Server vs WAS","uri":"/web-server-vs-was/"},{"categories":["web"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1 ","date":"2023-11-10","objectID":"/web-server-vs-was/:5:0","tags":["web-server","was"],"title":"Web Server vs WAS","uri":"/web-server-vs-was/"},{"categories":["web"],"content":"서블릿 사용 시 HTTP 요청, 응답 흐름 HTTP 요청시 WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력 WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성 ","date":"2023-11-09","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:1:0","tags":["servlet","servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["web"],"content":"서블릿 컨테이너 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리 서블릿 객체는 싱글톤으로 관리 고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근 공유 변수 사용 주의 서블릿 컨테이너 종료시 함께 종료 JSP도 서블릿으로 변환 되어서 사용 동시 요청을 위한 멀티 쓰레드 처리 지원 ","date":"2023-11-09","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:2:0","tags":["servlet","servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["web"],"content":"웹 애플리케이션 서버의 요청 응답 구조 ","date":"2023-11-09","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:3:0","tags":["servlet","servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["web"],"content":"HttpServletRequest 역할 HTTP 요청 메시지를 개발자가 직접 파싱해서 사용해도 되지만, 매우 불편할 것이다. 서블릿은 개발자가 HTTP 요청 메시지를 편리하게 사용할 수 있도록 개발자 대신에 HTTP 요청 메시지를 파싱한다. 그리고 그 결과를 HttpServletRequest 객체에 담아서 제공한다. HttpServletRequest를 사용하면 다음과 같은 HTTP 요청 메시지를 편리하게 조회할 수 있다. POST /save HTTP/1.1 Host: localhost:8080 Content-Type: application/x-www-form-urlencoded username=kim\u0026age=20 START LINE HTTP 메소드 URL 쿼리 스트링 스키마, 프로토콜 헤더 헤더 조회 바디 form 파라미터 형식 조회 message body 데이터 직접 조회 HttpServletRequest 객체는 추가로 여러가지 부가기능도 함께 제공한다. 해당 HTTP 요청이 시작부터 끝날 때 까지 유지되는 임시 저장소 기능 저장: request.setAttribute(name, value) 조회: request.getAttribute(name) 세션 관리 기능 request.getSession(create: true) ","date":"2023-11-09","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:3:1","tags":["servlet","servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["web"],"content":"HttpServletResponse 역할 HTTP 응답 메시지 생성 HTTP 응답코드 지정 헤더 생성 바디 생성 편의 기능 제공 Content-Type, 쿠키, Redirect ","date":"2023-11-09","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:3:2","tags":["servlet","servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["web"],"content":"참고 https://youtu.be/calGCwG_B4Y https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1 ","date":"2023-11-09","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:4:0","tags":["servlet","servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["web"],"content":"사설 IP(Private IP) 사설 IP(Private IP)는 한정된 IP 주소를 최대한 활용하기 위해 IP주소를 분할하고자 만든 개념이다. IPV4 기준으로 최대 IP 개수는 약 43억개이다. 사설망 내부에는 외부 인터넷 망으로 통신이 불가능한 사설 IP가 구성된다. 그리고 외부로 통신할 때는 통신 가능한 공인 IP를 사용한다. 보통 하나의 망은 사설 IP를 부여받은 기기들과 NAT 기능을 갖춘 Gateway로 구성한다. ","date":"2023-11-04","objectID":"/%EC%82%AC%EC%84%A4ip-nat-cidr/:1:0","tags":["private-ip","nat","cidr"],"title":"사설IP, NAT, CIDR","uri":"/%EC%82%AC%EC%84%A4ip-nat-cidr/"},{"categories":["web"],"content":"NAT(Network Address Translation) NAT(Network Address Translation)는 사설 IP가 공용 IP로 통신할 수 있도록 주소를 변환해주는 방법이다. Dynamic NAT : 1개의 사설 IP를 가용 가능한 공인 IP로 연결하는 방식 공인 IP 그룹(NAT Pool)에서 현재 사용 가능한 IP를 가져와서 연결한다. Static NAT : 하나의 사설 IP를 고정된 하나의 공인 IP로 연결하는 방식. Public IP와 Private IP의 숫자가 같다. AWS Internat Gateway가 사용하는 방식이다. PAT(Port Address Translation) : 많은 사설 IP를 하나의 공인 IP로 연결. 하나의 Public IP가 사설망을 대표하고 각 통신 시에는 port를 다르게 한다. 대부분의 사설 네트워크가 사용하는 방식이다. ","date":"2023-11-04","objectID":"/%EC%82%AC%EC%84%A4ip-nat-cidr/:2:0","tags":["private-ip","nat","cidr"],"title":"사설IP, NAT, CIDR","uri":"/%EC%82%AC%EC%84%A4ip-nat-cidr/"},{"categories":["web"],"content":"CIDR(Classless Inter Domain Routiong) CIDR(Classless Inter Domain Routiong)는 여러 개의 사설망을 구축하기 위해 망을 나누고 IP를 묶는 방식을 말한다. CIDR 은 네트워크 주소와 호스트 주소로 구성되며, 각 호스트 주소 숫자 만큼의 IP를 가진 네트워크 망 형성 가능하다. CIDR은 A.B.C.D/E 형식으로 구성된다. A.B.C.D는 네트워크 주소+호스트 주소를 표시하며, E는 네트워크 주소가 몇 bit인지 표시한다. 호스트 주소 비트 만큼 IP 주소를 보유 가능하다. 예를 들어 CIDR이 192.168.2.0/24이라면, 네트워크 비트는 24이고 호스트 주소는 32-24=8이다. 즉 2^8 = 256개의 IP 주소 보유 가능하다. ","date":"2023-11-04","objectID":"/%EC%82%AC%EC%84%A4ip-nat-cidr/:3:0","tags":["private-ip","nat","cidr"],"title":"사설IP, NAT, CIDR","uri":"/%EC%82%AC%EC%84%A4ip-nat-cidr/"},{"categories":["web"],"content":"서브넷 서브넷은 네트워크 안의 네트워크를 말한다. 일정 IP주소의 범위를 보유하며, 큰 네트워크에 부여된 IP 범위를 조금씩 잘라 작은 단위로 나눈 후 각 서브넷에 할당하는데 이때 CIDR이 사용된다. ","date":"2023-11-04","objectID":"/%EC%82%AC%EC%84%A4ip-nat-cidr/:3:1","tags":["private-ip","nat","cidr"],"title":"사설IP, NAT, CIDR","uri":"/%EC%82%AC%EC%84%A4ip-nat-cidr/"},{"categories":["web"],"content":"참고 https://www.youtube.com/watch?v=3VXLD0-Iq8A ","date":"2023-11-04","objectID":"/%EC%82%AC%EC%84%A4ip-nat-cidr/:4:0","tags":["private-ip","nat","cidr"],"title":"사설IP, NAT, CIDR","uri":"/%EC%82%AC%EC%84%A4ip-nat-cidr/"},{"categories":["spring"],"content":"스프링 비동기 설정 @Async는 비동기적으로 처리를 할 수 있게끔 스프링에서 제공하는 어노테이션이다. 해당 어노테이션을 붙이게 되면 각기 다른 쓰레드로 실행이 된다. 즉, 호출자는 해당 메서드가 완료되는 것을 기다릴 필요가 없다. 이 어노테이션을 사용하기 위해서는 @EnableAsync 가 달려있는 configuration 클래스가 우선적으로 필요하다. @EnableAsync는 스프링의 @Async 어노테이션을 감지한다. @Configuration @EnableAsync public class AsyncConfig { } 기본적으로, 스프링은 비동기적으로 메서드를 실행하기 위해서 SimpleAsyncTaskExecutor를 사용한다. SimpleAsyncTaskExecutor는 요청이 오는대로 계속해서 쓰레드를 생성하는 방식이다. 이것을 어플리케이션 레벨 또는 각 메서드 레벨에서 override 함으로써 default를 변경할 수 있다. ","date":"2023-10-29","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:0","tags":["async"],"title":"스프링 비동기","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["spring"],"content":"메서드 레벨에서 Override 설정 클래스에서 필요한 실행자를 선언해주어야한다. 그 후 실행자 이름을 @Async에서 속성값으로 제공해주어야 한다. @Configuration @EnableAsync public class AsyncConfig { @Bean(\"customAsyncExecutor\") public Executor customAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(5); executor.setThreadNamePrefix(\"bepoz\"); executor.initialize(); // 꼭 써줘야 한다. return executor; } } @Service @Slf4j public class AsyncService { @Async(\"customAsyncExecutor\") // @Async value로 등록한 Executor의 이름을 입력 public void call() { log.info(\"async Test\"); } } ","date":"2023-10-29","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:1","tags":["async"],"title":"스프링 비동기","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["spring"],"content":"어플리케이션 레벨에서 Override 설정 클래스는 AsyncConfigurer 인터페이스를 구현해주어야한다. 이는 getAsyncExecutor() 메소드를 구현해야한다는 의미이다. @Configuration @EnableAsync public class AsyncConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(5); executor.setThreadNamePrefix(\"bepoz\"); executor.initialize(); // 꼭 써줘야 한다. return executor; } } @Service @Slf4j public class AsyncService { @Async public void call() { log.info(\"async Test\"); } } ","date":"2023-10-29","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:2","tags":["async"],"title":"스프링 비동기","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["spring"],"content":"스프링 비동기 사용 @Async 어노테이션을 사용하기 위해서는 2가지 제약조건이 있다. public 메서드일 것 프록시를 사용하기 위해서 메서드는 public이어야 한다. 동일 클래스에서 호출하는 Self-invocation 이어서는 안된다는 것 Self-invocation를 사용하게되면 프록시를 무시하고 바로 메서드를 호출한다. ","date":"2023-10-29","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:0","tags":["async"],"title":"스프링 비동기","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["spring"],"content":"리턴타입이 없는 메소드 다음과 같이 간단한 설정으로 리턴타입이 void인 메소드가 비동기로 작동한다. @Async public void asyncMethodWithVoidReturnType(){ System.out.println(\"Execute method asynchronously. \" +Thread.currentThread().getName()); } ","date":"2023-10-29","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:1","tags":["async"],"title":"스프링 비동기","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["spring"],"content":"리턴타입이 있는 메소드 Future 객체에 실제 리턴값을 넣음으로서 @Async 는 리턴타입이 있는 메소드에 적용할 수 있다. @Async public Future\u003cString\u003e asyncMethodWithReturnType() { System.out.println(\"Execute method asynchronously - \" + Thread.currentThread().getName()); try { Thread.sleep(5000); return new AsyncResult\u003cString\u003e(\"hello world !!!!\"); } catch (InterruptedException e) {//} return null; } } ","date":"2023-10-29","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:2","tags":["async"],"title":"스프링 비동기","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["spring"],"content":"예외 처리 메소드의 리턴타입이 Future일 경우 예외처리는 쉽다. Future.get() 메소드가 예외를 발생시킨다. 하지만 리턴타입이 void일 때, 예외는 호출 스레드에 전달되지 않을 것이다. 따라서 예외 처리를 위한 추가 설정이 필요하다. AsyncUncaughtExceptionHandler 인터페이스를 구현함으로서 커스텀 비동기 예외처리기를 만들 수 있다. handleUncaughtException() 메소드는 잡히지않은 uncaught 비동기 예외가 발생할때 호출된다. @Override public void handleUncaughtException(Throwable throwable, Method method, Object... obj) { System.out.println(\"Exception message - \" + throwable.getMessage()); System.out.println(\"Method name - \" + method.getName()); for (Object param : obj) { System.out.println(\"Parameter value - \" + param); } } 이후 설정 클래스에 의해 구현된 AsyncConfigurer 인터페이스를에 커스텀 비동기 예외처리기를 리턴하는 getAsyncUncaughtExceptionHandler() 메소드를 오버라이드하여 추가 한다. @Configuration @EnableAsync public class AsyncConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(5); executor.setThreadNamePrefix(\"bepoz\"); executor.initialize(); // 꼭 써줘야 한다. return executor; } } ","date":"2023-10-29","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/:3:0","tags":["async"],"title":"스프링 비동기","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["spring"],"content":"참고 https://bepoz-study-diary.tistory.com/399 https://springboot.tistory.com/38 ","date":"2023-10-29","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/:4:0","tags":["async"],"title":"스프링 비동기","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["docker/kubernetes"],"content":"쿠버네티스 클러스터의 전체 구조 마스터에는 etcd, kube-apiserver, kube-scheduler, kube-controller-manager,kubelet, kube-proxy, docker 등의 컴포넌트가 실행된다. 컴포넌트 각각이 다른 마스터나 노드 서버에서 별개로 실행되어도 실제 쿠버네티스 클러스터를 운영하는 데 이상은 없다. 하지만 마스터가 서버 1대라면 방금 소개한 프로세스 한 묶음을 해당 서버에서 같이 실행하는 것이 일반적인 구성이다. 마스터는 보통 고가용성을 만족하고자 서버 3대 정도 구성해서 운영한다. 평소 실제 클러스터를 관리하는 리더 마스터는 1대고 나머지 2대는 대기한다. 리더 마스터에 장애가 발생하면자연스럽게 나머지 2대 중 1대가 리더 역할을 맡다. 클러스터를 좀 더 안정적으로 운영하려면 마스터를 서버 5대로 구성할 수도 있다. 노드에는 kubelet, kube-proxy, docker 등의 컴포넌트가 실행된다. 실제 사용하는 컨테이너 대부분은 노드에서 실행된다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:1:0","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"마스터용 컴포넌트 마스터용 컴포넌트들은 실제 클러스터 전체를 관리한다. etcd, kube-apiserver, kubescheduler, kube-controller-manager, cloud-controller-manager 등이 마스터용 컴포넌트이다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:2:0","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"etcd etcd는 코어OS에서 개발한 고가용성을 제공하는 키-값Key-value 저장소이다. 분산 시스템에서 노드 사이의 상태를 공유하는 합의 알고리즘 중 하나인 raft 알고리즘을 구현한 것이다. 쿠버네티스에서는 필요한 모든 데이터를 저장하는 데이터베이스 역할을 한다. etcd는 서버 하나당 프로세스 1개만 사용할 수 있다. 보통 etcd 자체를 클러스터링한 후 여러 개 마스터 서버에 분산해서 실행해 데이터의 안정성을 보장하도록 구성한다. etcd 자체는 꽤 안정적이지만 더 안정적으로 쿠버네티스를 운영하려면 주기적으로 etcd에 있는 데이터를 백업할 것을 권한다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:2:1","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"kube-apiserver kube-apiserver는 쿠버네티스 클러스터의 API를 사용할 수 있도록 하는 컴포넌트이다. 클러스터로 온 요청이 유효한지 검증한다. 예를 들어 쿠버네티스 API 스펙에 맞춰 클러스터의특정 네임스페이스에 존재하는 디플로이먼트 목록 조회 요청을 받으면, 이 요청에 사용된 토큰이 해당 네임스페이스와 자원을 대상으로 요청을 실행할 권한이 있는지 검사하고 권한이 있다면 디플로이먼트 목록을 조회하여 되돌려준다. 쿠버네티스는 마이크로서비스 아키텍처이므로 서로 분리된 컴포넌트 여러 개로 구성되어 있다. 쿠버네티스에 보내는 모든 요청은 kube-apiserver를 이용해서 다른 컴포넌트로 전달한다. kube-apiserver는 수평적으로 확장할 수 있도록 설계했으므로 서버 여러 대에 여러 개kube-apiserver를 실행해 사용할 수 있다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:2:2","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"kube-scheduler kube-scheduler는 현재 클러스터 안에서 자원 할당이 가능한 노드 중 알맞은 노드를 선택해서 새롭게 만든 파드를 실행한다. 파드는 처음 실행할 때 여러 가지 조건을 설정하며, kube-scheduler가 조건에 맞는 노드를 찾는다. 조건에는 하드웨어 요구사항, 함께 있어야 하는 파드들을 같은 노드에 실행하는 어피니티(ainity)와 파드를 다양한 노드로분산해서 실행하는 안티 어피니티(anti-affinity) 만족 여부, 특정 데이터가 있는 노드에 할당 등이 있다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:2:3","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"kube-controller-manager 쿠버네티스에는 파드들을 관리하는 컨트롤러 controller가 있다. 컨트롤러 각각은 논리적으로 개별프로세스지만 복잡도를 줄이려고 모든 컨트롤러를 바이너리 파일 하나로 컴파일해 단일 프로세스로 실행한다. kube-controller-manager는 컨트롤러 각각을 실행하는 컴포넌트이다. 쿠버네티스는 Go언어로 개발되었는데, 클러스터 안에서 새로운 컨트롤러를 사용할 때는 컨트롤러에 해당하는 구조체를 만든다. 이 구조체를 kube-controller-manager가 관리하는 큐에 넣어서 실행하는 방식으로 동작한다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:2:4","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"cloud-controller-manager cloud-controller-manager는 쿠버네티스의 컨트롤러들을 클라우드 서비스와 연결해 관리하는 컴포넌트이다. 관련 컴포넌트의 소스 코드는 각 클라우드 서비스에서 직접 관리한다. 보통 네 가지 컨트롤러 컴포넌트를 관리한다. 노드 컨트롤러(Node Controller): 클라우드 서비스 안에서 노드를 관리하는 데 사용한다. 라우트 컨트롤러(Route Controller): 각 클라우드 서비스 안의 네트워크 라우팅을 관리하는데 사용한다. 서비스 컨트롤러(Service Controller): 각 클라우드 서비스에서 제공하는 로드밸런서를 생성, 갱신, 삭제하는 데 사용한다. 볼륨 컨트롤러(Volume Controller): 클라우드 서비스에서 생성한 볼륨을 노드에 연결하거나 마운트하는 등에 사용한다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:2:5","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"노드용 컴포넌트 노드용 컴포넌트는 쿠버네티스 각 노드의 파드 실행 환경을 관리한다. 컴포넌트에는 kubelet, kube-proxy, 컨테이너 런타임 등이 있다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:3:0","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"kubelet kubelet은 클러스터 안 모든 노드에서 실행되는 에이전트이다. 파드 컨테이너들의 실행을 직접 관리한다. kubelet은 파드스펙 Podspecs 이라는 조건이 담긴 설정을 전달받아서 컨테이너를 실행하고 컨테이너가 정상적으로 실행되는지 헬스 체크를 진행한다. 단, 노드 안에 있는 컨테이너라도 쿠버네티스가 만들지 않은 컨테이너는 관리하지 않는다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:3:1","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"kube-proxy 쿠버네티스는 클러스터 안에 별도의 가상 네트워크를 설정하고 관리한다. kube-proxy는 가상 네트워크의 동작을 관리하는 컴포넌트이다. 호스트의 네트워크 규칙을 관리하거나 연결을 전달할 수도 있다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:3:2","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"컨테이너 런타임 컨테이너 런타임(Container Runtime)은 실제로 컨테이너를 실행시킨다. 가장 많이 알려진 런타임으로는 도커 Docker가 있고 containerd, runc 같은 런타임도 지원한다. 보통 컨테이너 표준을 정하는 OCIO(pen Container Initiative) 런타임 규격을 구현한 컨테이너 런타임이라면 쿠버네티스에서 사용할 수 있다. 쿠버네티스 버전 1.10부터는 쿠버네티스와 같은 클라우드 네이티브 컴퓨팅 재단(Cloud Native Computing Foundation, CNCF) 소속인 containerd를 도커 없이 기본 런타임으로 사용할 수도 있다. ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:3:3","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"참고 쿠버네티스 입문, 동양북스 ","date":"2023-10-12","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/:4:0","tags":["etcd","kublet"],"title":"쿠버네티스 컴포넌트","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"categories":["docker/kubernetes"],"content":"쿠버네티스를 제대로 활용하려면 여러 대 서버를 클러스터로 구성해 사용해야 한다. 서버 자원에 쿠버네티스 클러스터를 직접 구성할 때 활용하는 도구는 Kubeadm, Kubespray가 있다. ","date":"2023-10-11","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/:0:0","tags":["kubeadm","kubespray"],"title":"쿠버네티스 관리 도구","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/"},{"categories":["docker/kubernetes"],"content":"Kubeadm Kubeadm은 쿠버네티스에서 공식 제공하는 클러스터 생성/관리 도구이다. 여러 대 서버를 쿠버네티스 클러스터로 손쉽게 구성할 수 있다. 특징은 다음과 같다. 쿠버네티스에서 직접 제공하는 클러스터 생성 tool 클러스터 생성을 위해 필요한 기초 생성, 관리 명령어들이 포함된다. 클러스터를 관리하기 위한 것이므로 개별 node 에 대한 container runtime, kublet, cni 등은 알아서 설치가 필요하다. Kubeadm에서 제공하는 클러스터 고가용성은 다음과 같은 구조이다. 여러 대의 마스터 노드를 두고 그 앞에 로드밸런서를 두었다. 워커 노드들이 마스터 노드에 접근할 때는 로드밸런서를 거쳐 접근한다. ","date":"2023-10-11","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/:1:0","tags":["kubeadm","kubespray"],"title":"쿠버네티스 관리 도구","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/"},{"categories":["docker/kubernetes"],"content":"Kubespray Kubespray는 상용 서비스에 적합한 보안성과 고가용성이 있는 쿠버네티스 클러스터를 배포하는 오픈소스 프로젝트이다. Kubespray는 서버 환경 설정 자동화 도구인 앤서블 기반으로 개발되었다. 설정에 따라 사용자에게 맞는 다양한 형식으로 쿠버네티스 클러스터를 구성할 수 있으므로 온프레미스 환경에서 상용 서비스의 쿠버네티스 클러스터를 구성할 때 유용하다. 특징은 다음과 같다. 쿠버네티스 클러스터 관리를 위한 오픈소스 ansible 을 이용한 play book (인프라 담당자에게 익숙한 ansible 을 사용함) ansible 과 ssh를 사용하므로 대규모 쿠버네티스 클러스터를 관리하기에 적합하다. ansible 을 사용하므로 개별 worker node에 접속하지 않고 원격 설치 및 클러스터 구성이 가능하다. k8s 버전에 맞는 container runtime, cni, kubelet 에 대한 자동 설치를 제공한다. Kubespray에서 제공하는 클러스터 고가용성은 다음과 같은 구조이다. Kubeadm처럼 별도의 로드밸런서를 사용하지 않고 노드 각각의 nginx가 리버스 프록시로 실행된다. 이 nginx-proxy가 전체 마스터 노드를 바라보는 구조이며, 그래서 쿠버네티스의 컴포넌트들은 직접 마스터 노드와 통신하지 않고 자신의 서버 안 nginx와 통신한다. 마스터 노드의 장애 감지는 헬스 체크를 이용해 nginx가 알아서 처리한다. ","date":"2023-10-11","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/:2:0","tags":["kubeadm","kubespray"],"title":"쿠버네티스 관리 도구","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/"},{"categories":["docker/kubernetes"],"content":"참고 쿠버네티스 입문, 동양북스 https://shonm.tistory.com/762 ","date":"2023-10-11","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/:3:0","tags":["kubeadm","kubespray"],"title":"쿠버네티스 관리 도구","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/"},{"categories":["docker/kubernetes"],"content":"클라우드 네이티브 클라우드 네이티브란 클라우드의 장점을 최대한 활용하여 정보 시스템을 구축 및 실행하는 환경이다. 클라우드 네이티브 기술은 조직이 퍼블릭, 프라이빗, 그리고 하이브리드 클라우드와 같은 현대적이고 동적인 환경에서 확장 가능한 애플리케이션을 개발하고 실행할 수 있게 해준다. 컨테이너, 서비스 메쉬, 마이크로서비스, 불변(Immutable) 인프라, 그리고 선언형(Declarative) API가 이러한 접근 방식의 예시들이다. 이 기술은 회복성, 관리 편의성, 가시성을 갖춘 느슨하게 결합된 시스템을 가능하게 한다. 견고한 자동화 기능을 함께 사용하면 엔지니어는 영향이 큰 변경을 최소한의 노력으로 예측 가능하게 수행할 수 있다. 쿠버네티스는 클라우드 네이티브 구성요소를 완전히 수행할 수 있는 최고의 플랫폼이다. ","date":"2023-09-25","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/:1:0","tags":["cloud-native"],"title":"쿠버네티스와 클라우드 네이티브","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/"},{"categories":["docker/kubernetes"],"content":"클라우드 네이티브 애플리케이션의 특징 기존 애플리케이션은 장기간에 걸쳐 긴밀하게 결합된 모놀리식 기반 위에서 동작한다. 반면에 클라우드 네이티브 애플리케이션은 소규모 서비스 단위의 마이크로서비스로 구성되며 가상 컨테이너 환경에서 동작되도록 설계되고 구현된다. 구분 기존 애플리케이션 클라우드 네이티브 애플리케이션 애플리케이션 구조 모놀리식 구조 마이크로서비스 결합 조밀한 결합 느슨한 결합 실행환경 물리서버 중심 가상 컨테이너 중심 확장 수직 확장(Scal-Up) 수평 확장(Scale-Out) 인프라 의존성 인프라 의존 인프라 독립, 이식성 보장 개발방법 폭포수 애자일 빌드/배포 수작업, 긴 시간 CI/CD 자동화, 짧은 시간 조직구조 단절된 개발 데브옵스 협업 ","date":"2023-09-25","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/:2:0","tags":["cloud-native"],"title":"쿠버네티스와 클라우드 네이티브","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/"},{"categories":["docker/kubernetes"],"content":"클라우드 네이티브 구성 요소 마이크로 서비스 : 서비스를 각각 고유한 논리 상태 및 데이터가 있는 독립적인 서비스로 기능을 분리 컨테이너 : 코드, 의존성 및 런타임은 컨테이너 이미지라는 이진 파일로 패키지 서비스 지원 : 데이터 저장소, 메시지 브로커, 모니터링 및 idcert 서비스와 같은 다양한 보조 리소스 구성 자동화 : 스크립트를 활용한 인프라 CI/CD 자동화 ","date":"2023-09-25","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/:3:0","tags":["cloud-native"],"title":"쿠버네티스와 클라우드 네이티브","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/"},{"categories":["docker/kubernetes"],"content":"참고 https://www.inflearn.com/course/%EB%8D%B0%EB%B8%8C%EC%98%B5%EC%8A%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%A7%88%EC%8A%A4%ED%84%B0 ","date":"2023-09-25","objectID":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/:4:0","tags":["cloud-native"],"title":"쿠버네티스와 클라우드 네이티브","uri":"/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/"},{"categories":["system"],"content":"inode 리눅스에는 inode 라는 개념이 있다. inode는 유닉스 계통의 파일 시스템에서 사용하는 자료 구조이다. 모든 파일과 디렉토리는 inode를 하나씩 가지고 있다. 그리고 여기에는 해당 파일의 허가권, 소유권, 파일의 실제 위치 등 중요한 정보들이 들어있다. inode는 실제 파일의 내용을 갖고 있지는 않다. inode는 데이터의 우편번호 역할을 한다고 볼 수 있다. 즉, 파일의 내용을 갖고 있는 주소를 포함할 뿐이다. ","date":"2023-09-11","objectID":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/:1:0","tags":["hard-link","symbolic-link"],"title":"하드링크, 심볼릭링크","uri":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/"},{"categories":["system"],"content":"리눅스 파일 링크 종류 ","date":"2023-09-11","objectID":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/:2:0","tags":["hard-link","symbolic-link"],"title":"하드링크, 심볼릭링크","uri":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/"},{"categories":["system"],"content":"하드 링크 (Hard link) 하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킨다. 따라서 원본 파일이 사라지더라도 데이터만 살아 있다면 원본 파일에 접근이 가능하다. ","date":"2023-09-11","objectID":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/:2:1","tags":["hard-link","symbolic-link"],"title":"하드링크, 심볼릭링크","uri":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/"},{"categories":["system"],"content":"심볼릭 링크(Symbolic link) =소프트 링크(Soft link) 심볼릭 링크(소프트 링크)는 만들게 되면 또 다른 inode를 생성해서 이를 바라본다. 복사 생성된 inode는 포인터를 카리키고, 포인터는 다시 원본 파일을 가리키는 것이다. ","date":"2023-09-11","objectID":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/:2:2","tags":["hard-link","symbolic-link"],"title":"하드링크, 심볼릭링크","uri":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/"},{"categories":["system"],"content":"하드 링크, 심볼릭 링크 차이점 하드 링크 소프트 링크 동일한 파일시스템 내에서만 하드링크 생성가능 파일시스템과 대상파일이 존재하는 파일시스템이 달라도 생성가능 디렉터리 링크 불가능 파일이나 디렉토리를 가리킬 텍스트 포인터를 가짐으로써 참조 가능 대상파일과 동일한 inode 번호와 허가권 가짐 대상파일과 심볼릭링크 파일은 서로 inode 번호와 파일허가권이 다름 대상파일을 옮기거나 삭제하더라도 대상파일을 참조 대상 파일의 inode가 아닌 대상 파일의 데이터 경로만을 참조 원본이 삭제되어도 원본과 동일한 내용의 파일을 가지고 있음 원본 파일이 사라지면 해당 데이터에 접근할 수 없음 ","date":"2023-09-11","objectID":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/:2:3","tags":["hard-link","symbolic-link"],"title":"하드링크, 심볼릭링크","uri":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/"},{"categories":["system"],"content":"참고 https://inpa.tistory.com/entry/LINUX-%F0%9F%93%9A-%ED%95%98%EB%93%9C-%EB%A7%81%ED%81%AChard-link-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%A7%81%ED%81%ACsymbolic-link-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9Cinode#%EC%9D%BC%EB%B0%98_%EB%B3%80%EC%88%98%EC%9D%98_%EA%B0%92_%EB%B3%B5%EC%82%AC_%ED%95%98%EB%93%9C_%EB%A7%81%ED%81%AC ","date":"2023-09-11","objectID":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/:3:0","tags":["hard-link","symbolic-link"],"title":"하드링크, 심볼릭링크","uri":"/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/"},{"categories":["web"],"content":"HTTP HTTP는 HyperText Transfer Protocol의 약자로, HTML, text, image, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터를 전송 가능한 프로토콜이다. ","date":"2023-09-06","objectID":"/http/:1:0","tags":["HTTP"],"title":"HTTP","uri":"/http/"},{"categories":["web"],"content":"HTTP 특징 ","date":"2023-09-06","objectID":"/http/:2:0","tags":["HTTP"],"title":"HTTP","uri":"/http/"},{"categories":["web"],"content":"클라이언트-서버 구조 클라이언트는 서버에 요청을 보내고, 응답을 대기한다. 서버는 요청에 대한 결과를 만들어서 응답한다. ","date":"2023-09-06","objectID":"/http/:2:1","tags":["HTTP"],"title":"HTTP","uri":"/http/"},{"categories":["web"],"content":"무상태 프로토콜(Stateless)) 서버가 클라이언트의 상태를 보존하지 않는다. 장점: 서버 확장성 높음(스케일 아웃) 단점: 클라이언트가 추가 데이터 전송 모든 것을 무상태로 설계 할 수 없는 경우에는 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지를 함으로써 무상태 프로토콜의 한계를 극복할 수 있다. ","date":"2023-09-06","objectID":"/http/:2:2","tags":["HTTP"],"title":"HTTP","uri":"/http/"},{"categories":["web"],"content":"비연결성(Connectionless) HTTP는 연결을 유지하지 않는 모델이다. 일반적으로 초 단위의 이하의 빠른 속도로 응답하므로, 서버 자원을 매우 효율적으로 사용할 수 있다. ","date":"2023-09-06","objectID":"/http/:2:3","tags":["HTTP"],"title":"HTTP","uri":"/http/"},{"categories":["web"],"content":"참고 https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC ","date":"2023-09-06","objectID":"/http/:3:0","tags":["HTTP"],"title":"HTTP","uri":"/http/"},{"categories":["web"],"content":"URI URI는 로케이터(locator), 이름(name)을 포함한 개념이다. URI는 다음과 같이 풀이할 수 있다. Uniform: 리소스 식별하는 통일된 방식 Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음) Identifier: 다른 항목과 구분하는데 필요한 정보 ","date":"2023-09-05","objectID":"/uri-url-urn/:1:0","tags":["URI","URL","URN"],"title":"URI, URL, URN","uri":"/uri-url-urn/"},{"categories":["web"],"content":"URL, URN URL, URN은 다음과 같이 풀이할 수 있다. URL: Uniform Resource Locator : 리소스가 있는 위치를 지정 URN: Uniform Resource Name : 리소스에 이름을 부여 URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않아, 잘 사용하지 않는다. ","date":"2023-09-05","objectID":"/uri-url-urn/:2:0","tags":["URI","URL","URN"],"title":"URI, URL, URN","uri":"/uri-url-urn/"},{"categories":["web"],"content":"URL 전체 문법 전체 문법은 다음과 같다. scheme://[userinfo@]host[:port][/path][?query][#fragment] scheme : 주로 프로토콜 사용 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 userinfo : URL에 사용자정보를 포함해서 인증 거의 사용하지 않음 host : 호스트명, 도메인명 또는 IP 주소를 직접 사용가능 port : 접속 포트 일반적으로 생략, 생략시 http는 80, https는 443 path : 리소스 경로(path), 계층적 구조 query : key=value 형태 ?로 시작, \u0026로 추가 가능 query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터, 문자 형태 fragment : html 내부 북마크 등에 사용 서버에 전송하는 정보 아님 ","date":"2023-09-05","objectID":"/uri-url-urn/:2:1","tags":["URI","URL","URN"],"title":"URI, URL, URN","uri":"/uri-url-urn/"},{"categories":["web"],"content":"참고 https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC ","date":"2023-09-05","objectID":"/uri-url-urn/:3:0","tags":["URI","URL","URN"],"title":"URI, URL, URN","uri":"/uri-url-urn/"},{"categories":["JPA"],"content":"페치 조인 (Fetch Join) 페치 조인은 JPQL에서 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능을 한다. 사용 문법은 다음과 같다. 페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로 페치 조인은 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화할 수 있다. 페치 조인은 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선한다. 실무에서는 글로벌 로딩 전략은 모두 지연 로딩이므로, 최적화가 필요한 곳은 페치 조인을 적용하면 효과적이다. ","date":"2023-07-30","objectID":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/:1:0","tags":["fetch-join"],"title":"페치 조인","uri":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/"},{"categories":["JPA"],"content":"페치 조인과 DISTINCT SQL의 DISTINCT는 중복된 결과를 제거하는 명령이다. 반면 JPQL의 DISTINCT는 2가지 기능 제공한다. SQL에 DISTINCT를 추가한다. 애플리케이션에서 엔티티 중복을 제거한다. ","date":"2023-07-30","objectID":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/:2:0","tags":["fetch-join"],"title":"페치 조인","uri":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/"},{"categories":["JPA"],"content":"페치 조인의 한계 페치 조인 대상에는 별칭을 줄 수 없다. 따라서 SELECT, WHERE 절, 서브 쿼리에 페치 조인 대상을 사용할 수 없다. 하이버네이트는 가능하지만, 가급적 사용하지 않는 것이 좋다. 둘 이상의 컬렉션을 페치 할 수 없다. 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다. 하이버네이트는 경고 로그를 남기고 메모리에서 페이징하지만, 매우 위험하다. ","date":"2023-07-30","objectID":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/:3:0","tags":["fetch-join"],"title":"페치 조인","uri":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/"},{"categories":["JPA"],"content":"정리 모든 것을 페치 조인으로 해결할 수 는 없다. 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적이다. 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적이다. ","date":"2023-07-30","objectID":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/:4:0","tags":["fetch-join"],"title":"페치 조인","uri":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/"},{"categories":["JPA"],"content":"참고 https://www.inflearn.com/course/ORM-JPA-Basic https://choiyeonho903.tistory.com/93 ","date":"2023-07-30","objectID":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/:5:0","tags":["fetch-join"],"title":"페치 조인","uri":"/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/"},{"categories":["JPA"],"content":"상속관계 매핑 객체는 상속관계가 존재하지만, 관계형 데이터베이스는 상속 관계가 없다. 그나마 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다. 상속관계 매핑이라는 것은 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑하는 것이다. DB의 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법은 세가지 있다. DB입장에서 세가지로 구현하지만 JPA에서는 어떤 방식을 선택하던 매핑이 가능하다. ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:1:0","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"주요 어노테이션 ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:2:0","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"@Inheritance(strategy=InheritanceType.XXX) JPA가 DB의 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 세가지 방식과 매핑하려면 @Inheritance(strategy=InheritanceType.XXX)의 stategy를 설정해주면 된다. default 전략은 SINGLE_TABLE(단일 테이블 전략)이다. InheritanceType 종류는 다음과 같다. JOINED : 조인 전략, 각각 테이블로 변환 SINGLE_TABLE : 단일 테이블 전략, 통합 테이블로 변환 TABLE_PER_CLASS : 구현 클래스마다 테이블 전략, 서브타입 테이블로 변환 ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:2:1","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"@DiscriminatorColumn(name=“DTYPE”) 부모 클래스명 상단에 선언한다. 하위 클래스를 구분하는 용도의 컬럼이다. 관례는 default = DTYPE ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:2:2","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"@DiscriminatorValue(“XXX”) 하위 클래스명 상단에 선언한다. 엔티티를 저장할 때 슈퍼타입의 구분(DTYPE) 컬럼에 저장할 값을 지정한다. 어노테이션을 선언하지 않을 경우 기본값으로 클래스 이름이 들어간다. ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:2:3","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"상속관계 매핑 전략 ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:3:0","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"조인 전략(@Inheritance(strategy = InheritanceType.JOINED)) 장점 테이블이 정규화가 되어있고, 외래 키 참조 무결성 제약조건 활용 가능 ITEM의 PK가 ALBUM, MOVIE, BOOK의 PK이자 FK이다. 그래서 다른 테이블에서 아이템 테이블만 바라보도록 설계하는 것이 가능하다. 저장공간 효율화 테이블 정규화로 저장공간이 딱 필요한 만큼 소비된다. 단점 조회시 조인을 많이 사용하므로 단일 테이블 전략에 비하면 성능이 안 나온다. 조회 쿼리가 복잡하다. 데이터 저장시에 INSERT 쿼리가 상위, 하위 테이블 두번 발생한다. 정리 성능 저하라고 되어있지만, 실제로는 영향이 크지 않다. 오히려 저장공간이 효율화 되기 때문에 장점이 크다. 기본적으로는 조인 정략이 정석이라고 보면 된다. 객체랑도 잘 맞고, 정규화도 되고, 그래서 설계가 깔끔하게 나온다. ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:3:1","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"단일 테이블 전략 장점 조인이 필요 없으므로 일반적인 조회 성능이 빠르다. 조회 쿼리가 단순하다. 단점 자식 엔티티가 매핑한 컬럼은 모두 NULL을 허용해야 한다. 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조인 전략보다 성능이 오히려 느려질 수 있다. 그러나 보통 이 상황에 해당하는 임계점을 넘을 일은 많지 않다. ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:3:2","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"구현 클래스마다 테이블 전략 장점 서브 타입을 명확하게 구분해서 처리할 때 효과적이다 NOT NULL 제약조건을 사용할 수 있다. 단점 여러 자식 테이블을 함께 조회할 때 성능이 느리다(UNION SQL) 자식 테이블을 통합해서 쿼리하기 어렵다. 변경이라는 관점으로 접근할 때 굉장히 좋지 않다. 정리 ORM을 하다보면 데이터 쪽과 객체 쪽에서 trade off를 할 때가 있는데, 이 전략은 두 쪽 모두에서 추천하지 않는다. ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:3:3","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"정리 기본적으로는 조인 전략을 선택한다. 그리고 조인 전략과 단일 테이블 전략의 trade off를 생각해서 전략을 선택한다. 굉장히 심플하고 확장의 가능성도 적으면 단일 테이블 전략을 선택한다. 그러나 비즈니스 적으로 중요하고, 복잡하고, 확장될 확률이 높으면 조인 전략을 선택한다. ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:3:4","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"참고 https://www.inflearn.com/course/ORM-JPA-Basic https://ict-nroo.tistory.com/128 ","date":"2023-07-29","objectID":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:4:0","tags":["InheritanceType"],"title":"상속관계 매핑","uri":"/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"양방향 연관관계 양방향 매핑은 단방향 매핑에서 반대 방향으로 객체 조회(객체 그래프 탐색) 기능이 추가된 매핑 방법이다. 아래와 같은 연관 관계가 있다고 가정하자. 예제 시나리오 회원과 팀이 있다 회원은 하나의 팀에만 소속될 수 있다. 회원과 팀은 다대일 관계다. 위의 시나리오를 구현하기 위해서 Member(=회원), Team Entity를 작성해보자. package hello.jpa; import javax.persistence.*; @Entity public class Member { @Id @GeneratedValue @Column(name = \"MEMBER_ID\") private Long id; @Column(name = \"USERNAME\") private String username; @ManyToOne // 추가1! Member \u003c-\u003e Team은 N:1 관계 @JoinColumn(name = \"TEAM_ID\") // 추가2! 외래키의 이름 private Team team; // GETTER, SETTER 생략 } package hello.jpa; import javax.persistence.*; @Entity public class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private Long id; private String name; @OneToMany(mappedBy = \"team\") // 반대편 연관관계를 갖는 엔티티의 필드명 private List\u003cMember\u003e members = new ArrayList\u003c\u003e(); // GETTER, SETTER 생략 } JPA에서 외래키를 도맡아서 관리하는 하는 클래스의 필드를 연관관계의 주인이라고 한다. 외래키가 있는 쪽이 주인이다. 컬렉션을 필드에서 초기화해야 하는 이유 컬렉션은 필드에서 바로 초기화 하는 것이 안전하다. null문제에서 안전하다. 하이버네이트는 엔티티를 영속화 할때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 만약 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 따라서 필드레벨에서 생성하는 것이 가장 안전하고, 코드도 간결하다. ","date":"2023-07-28","objectID":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:1:0","tags":["many-to-one","one-to-many"],"title":"연관관계 매핑","uri":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"양방향 매핑 규칙 양방향 매핑에는 다음과 같은 규칙이 있다. 두 객체의 참조 변수 중 하나를 연관관계의 주인으로 지정 연관관계의 주인만이 외래키를 관리(등록, 수정) 주인이 아닌쪽은 읽기만 가능 주인은 mappedBy 속성 사용 X 참고로 @ManyToOne 은 mappedBy 속성 자체가 없음 주인이 아니면 mappedBy 속성으로 주인 지정 ","date":"2023-07-28","objectID":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:2:0","tags":["many-to-one","one-to-many"],"title":"연관관계 매핑","uri":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"연관관계 편의 메소드 다대일 관계에서 양쪽에 값을 설정할 수 있도록 하는 메소드를 연관관계 편의 메소드라고 한다. 연관관계 편의 메소드 작성시 알아둘 점은 다음과 같다. 연관관계 편의 메소드는 관례적인 setXXX 라는 이름 말고 다른 걸 쓰도록 한다. 단순한 setter가 아니라 어떤 중요한 로직이 있다는 것을 인식할 수 있도록 한다. 연관관계 편의 메소드는 둘 중 한 군데에서만 작성한다. 무한 루프를 방지하기 위함이다. 실제 개발 시 편의 메소드를 둘 중 어디에 둬야될지 상황에 따라 결정하게 된다. ","date":"2023-07-28","objectID":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:3:0","tags":["many-to-one","one-to-many"],"title":"연관관계 매핑","uri":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"연관관계 편의 메소드의 예 @Entity @Getter @Setter @NoArgsConstructor public class Member { @Id @Column(name = \"member_id\") private String id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"team_id\") private Team team; // 연관관계 편의 메소드 public void setTeam(Team team) { if(this.team != null) { this.team.getMembers().remove(this); } this.team = team; team.getMembers().add(this); } //... 생략 ... } ","date":"2023-07-28","objectID":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:3:1","tags":["many-to-one","one-to-many"],"title":"연관관계 매핑","uri":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"참고 https://www.inflearn.com/course/ORM-JPA-Basic ","date":"2023-07-28","objectID":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/:4:0","tags":["many-to-one","one-to-many"],"title":"연관관계 매핑","uri":"/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},{"categories":["JPA"],"content":"영속성 컨텍스트 처음 생성된 엔티티 매니저 팩토리는 클라이언트의 요청에 따라 엔티티 매니저를 생성한다. 그리고 엔티티 매니저는 DB Connection Pool에 있는 Connection을 이용해서 DB에 접근한다. 영속성 컨텍스트란 엔티티를 영구 저장하는 환경이다. 영속성 컨텍스트는 논리적인 개념이며, 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다. ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:1:0","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"엔티티의 생명주기 비영속(new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태. 객체를 단순히 생성한 상태 영속(managed) 영속성 컨텍스트에 의해 관리되는 상태 객체를 생성한 뒤 엔티티 매니저를 통해 persist 해주면 영속 상태가 된다. 준영속(detached) 영속성 컨텍스트에 저장되었다가 분리된 상태 em.detach(member); 삭제(removed) 삭제된 상태 em.remove(member); 준영속 상태 만드는 법 em.detach(entity) 특정 엔티티만 준영속 상태로 전환 1차 캐시에서 빠진다라고 생각하면 쉬움 em.clear() 영속성 컨텍스트 완전히 초기화 테스트 케이스 작성시 사용 em.close() 영속성 컨텍스트를 종료 ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:2:0","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"영속성 컨텍스트의 이점 ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:3:0","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"1차 캐시 1차 캐시를 통해 DB에서의 접근을 줄일 수 있게 된다. 영속된 엔티티들은 영속 컨텍스트의 1차캐시에 저장되기 때문에 이미 1차캐시에 있는 엔티티를 찾기 위해서 쿼리를 실행할 필요가 없게 된다. persist를 통해 엔티티를 영속 컨텍스트에 저장하면 1차 캐시에 저장되며, find를 통해 조회할 때 캐시를 통해 조회하게 된다. member2를 조회하게 되면 1차 캐시에 없기 때문에 DB에서 조회(SELECT문 실행)를 해서 1차 캐시에 저장하게 됩니다. 이후 member2를 반환한다. ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:3:1","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"영속 엔티티의 동일성 보장 1차 캐시를 통해 REPEATABLE READ를 가능하게 만들어준다. ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:3:2","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"트랜잭션을 지원하는 쓰기 지연(Transactional write-behind) 쓰기 지연 SQL 저장소를 통해 버퍼링을 가능하게 한다. 트랜잭션 내에서의 persist를 호출할 때마다 INSERT SQL을 데이터베이스에 보내는 게 아니라 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다. 영속 컨텍스트에는 쓰기 지연 SQL 저장소라는 것이 존재한다. em.persist(memberA)를 호출 시 1차 캐시에 memberA를 저장함과 동시에 INSERT memberA SQL을 쓰기 지연 SQL 저장소에 동시에 저장한다. 이후 memberB도 같은 방식으로 1차 캐시와 동시에 쓰기 지연 SQL 저장소에 SQL을 저장한다. 쓰기 지연 SQL 저장소에 쌓인 SQL은 DB의 commit이나 flush함수 호출 시 실행된다. SQL이 실행된 이후 DB에 값이 저장된다. ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:3:3","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"변경 감지(Dirty Checking) 영속성 컨텍스트를 통해 변경을 감지할수도 있다. 영속 상태의 엔티티는 값을 변경한 후 update와 같은 작업이 없어도, flush나 commit 시점에 엔티티와 맨 처음 영속 컨텍스트에 들어올 때 생긴 스냅샷의 비교를 통해 영속 상태의 변경이 있을 시 엔티티 값을 변경하는 UPDATE 쿼리를 DB에 날린다. ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:3:4","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"지연 로딩(Lazy Loading) 연관된 엔티티를 실제 사용하는 시점에 데이터베이스에서 조회할 수 있다. ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:3:5","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"참고 https://www.inflearn.com/course/ORM-JPA-Basic https://velog.io/@wogud7587/JPA-%EC%A4%80%EC%98%81%EC%86%8D-%EC%83%81%ED%83%9C%EC%99%80-%EB%B3%80%EA%B2%BD-%EA%B0%90%EC%A7%80 ","date":"2023-07-27","objectID":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/:4:0","tags":["entity-manager","persistence-context"],"title":"영속성 컨텍스트","uri":"/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"categories":["JPA"],"content":"SQL 중심적인 개발의 문제점 SQL에 의존적인 개발을 피하기 어렵다. 패러다임의 불일치 (객체 vs 관계형 데이터베이스) ","date":"2023-07-26","objectID":"/jpa-%EC%86%8C%EA%B0%9C/:1:0","tags":["sql","dbms"],"title":"JPA 소개","uri":"/jpa-%EC%86%8C%EA%B0%9C/"},{"categories":["JPA"],"content":"객체와 관계형 데이터베이스의 차이 상속 객체는 상속과 다형성을 사용 테이블은 상속 관계 안쓴다. 연관관계 객체는 참조를 사용 관계형 데이터베이스는 외래 키를 사용 연관관계 탐색 객체는 자유롭게 객체 그래프를 탐색할 수 있어야 한다. 관계형 데이터베이스는 처음 실행하는 SQL에 따라 탐색 범위 결정 데이터 식별 방법 관계형 데이터베이스는 처음 실행하는 SQL에 따라 탐색 범위 결정되기 때문에, 이는 엔티티 신뢰 문제를 발생시킨다. 상황에 따라 동일한 조회 메서드를 여러벌 생성 진정한 의미의 계층 분할이 어렵다. ","date":"2023-07-26","objectID":"/jpa-%EC%86%8C%EA%B0%9C/:2:0","tags":["sql","dbms"],"title":"JPA 소개","uri":"/jpa-%EC%86%8C%EA%B0%9C/"},{"categories":["JPA"],"content":"JPA를 왜 사용해야 하는가? ","date":"2023-07-26","objectID":"/jpa-%EC%86%8C%EA%B0%9C/:3:0","tags":["sql","dbms"],"title":"JPA 소개","uri":"/jpa-%EC%86%8C%EA%B0%9C/"},{"categories":["JPA"],"content":"생산성 JPA는 기본적인 CRUD 코드가 다 설정되어 있기 때문에 쉽게 자바 컬렉션에서 코드를 사용하듯 사용할 수 있다. ","date":"2023-07-26","objectID":"/jpa-%EC%86%8C%EA%B0%9C/:3:1","tags":["sql","dbms"],"title":"JPA 소개","uri":"/jpa-%EC%86%8C%EA%B0%9C/"},{"categories":["JPA"],"content":"유지보수성 JPA에서는 필드만 추가해주고 SQL은 JPA가 직접 처리해준다. 이러한 특성 때문에 유지보수가 용이해진다. ","date":"2023-07-26","objectID":"/jpa-%EC%86%8C%EA%B0%9C/:3:2","tags":["sql","dbms"],"title":"JPA 소개","uri":"/jpa-%EC%86%8C%EA%B0%9C/"},{"categories":["JPA"],"content":"패러다임의 불일치 해결 JPA를 이용하면 개발자는 한줄로 상속관계를 모두 포함해 저장할 수 있다. 조회도 자바컬렉션처럼 조회를 진행한다면 JPA에서 나머지 SELECT , JOIN을 진행해준다. 연관관계 저장도 객체 컬렉션의 동작처럼 간단한 코드로 진행할 수 있다. 객체를 미리 설정해주고 JPA로 미리 연관관계를 설정해준다면 엔티티, 계층을 신뢰할 수 있고 객체 그래프 탐색이 자유로워진다. SQL주도 개발에서의 객체는 다른 값이지만(new 를 통한 객체 생성 때문) JPA에서는 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장해준다. ","date":"2023-07-26","objectID":"/jpa-%EC%86%8C%EA%B0%9C/:3:3","tags":["sql","dbms"],"title":"JPA 소개","uri":"/jpa-%EC%86%8C%EA%B0%9C/"},{"categories":["JPA"],"content":"성능 1차 캐시와 동일성 보장 같은 트랜잭션 안에서는 같은 엔티티를 반환하므로 약간의 조회 성능을 기대할 수 있다. DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read을 보장한다. 트랜잭션을 지원하는 쓰기 INSERT 트랜잭션을 커밋할 때까지 INSERT SQL을 모음 JDBC BATCH SQL 기능을 사용해서 한번에 SQL을 모아서 전송 UPDATE UPDATE, DELETE로 인한 로우(ROW)락 시간 최소화 트랜잭션 커밋 시 UPDATE, DELETE SQL 실행하고, 바로 커밋 지연 로딩과 즉시 로딩 JPA는 지연 로딩과 즉시 로딩 기능을 설정만으로 간단하게 세팅할 수 있다. ","date":"2023-07-26","objectID":"/jpa-%EC%86%8C%EA%B0%9C/:3:4","tags":["sql","dbms"],"title":"JPA 소개","uri":"/jpa-%EC%86%8C%EA%B0%9C/"},{"categories":["JPA"],"content":"참고 https://www.inflearn.com/course/ORM-JPA-Basic ","date":"2023-07-26","objectID":"/jpa-%EC%86%8C%EA%B0%9C/:4:0","tags":["sql","dbms"],"title":"JPA 소개","uri":"/jpa-%EC%86%8C%EA%B0%9C/"},{"categories":["java"],"content":"NIO의 채널(Channel)과 버퍼(Buffer) 스트림과 채널의 공통점 스트림도 채널도 데이터의 입력 및 출력을 위한 통로가 된다. 스트림과 채널의 차이점 스트림은 한 방향으로만 데이터가 이동하지만 채널은 양방향으로 데이터 이동이 가능하다. 채널에만 존재하는 제약사항 채널은 반드시 버퍼에 연결해서 사용해야 한다. 채널 기반 데이터 입출력 경로 출력 경로: 데이터 ⇨ 버퍼 ⇨ 채널 ⇨ 파일 입력 경로: 데이터 ⇦ 버퍼 ⇦ 채널 ⇦ 파일 채널과 버퍼는 독립적이다. 버퍼와 채널은 일대일 일대다 다대일 다대다 모두 가능하다. ","date":"2023-07-22","objectID":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/:1:0","tags":["nio"],"title":"JAVA NIO 기반의 입출력","uri":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/"},{"categories":["java"],"content":"NIO 기반 파일 복사 예제 public static void main(String[] args) { Path src = 복사할 대상 파일 Path dst = 사본 이름 // 하나의 버퍼 생성 - 인스턴스 생성 ByteBuffer buf = ByteBuffer.allocate(1024); // try에서 두 개의 채널 생성 - 버퍼와 채널은 별개 try(FileChannel ifc = FileChannel.open(src, StandardOpenOption.READ); FileChannel ofc = FileChannel.open(dst, StandardOpenOption.WRITE, StandardOpenOption.CREATE)) { int num; while(true) { num = ifc.read(buf); // 채널 ifc에서 버퍼로 읽어 들임 if(num == -1) // 읽어 들인 데이터가 없다면 break; buf.flip(); // 버퍼 모드 변환! ofc.write(buf); // 버퍼에서 채널 ofc로 데이터 전송 buf.clear(); // 버퍼 비우기 } } catch(IOException e) { e.printStackTrace(); } } ","date":"2023-07-22","objectID":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/:2:0","tags":["nio"],"title":"JAVA NIO 기반의 입출력","uri":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/"},{"categories":["java"],"content":"성능 향상 포인트 효율적인 버퍼링 기본 IO 스트림 기반의 복사 프로그램과 달리 하나의 버퍼만을 사용하였다. 버퍼의 수가 줄은 것이 핵심이 아니라, 이로 인해 버퍼에서 버퍼로의 데이터 이동이 불필요해진 부분이 핵심 ","date":"2023-07-22","objectID":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/:3:0","tags":["nio"],"title":"JAVA NIO 기반의 입출력","uri":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/"},{"categories":["java"],"content":"Non-direct 버퍼를 대신하는 Direct 버퍼의 생성 ByteBuffer buf = ByteBuffer.allocate(1024); ByteBuffer.allocateDirect(1024); Non-direct 버퍼 Direct 버퍼 파일 ⇨ 운영체제 버퍼 ⇨ 가상머신 버퍼 ⇨ 실행 중인 자바 프로그램 파일 ⇨ 운영체제 버퍼 ⇨ 실행 중인 자바 프로그램 I/O스트림의 구조적인 문제 가상머신을 거치는 부분은 해결하지 못했지만 각각의 버퍼에 받아 복사하고 전송하지 않고 한 버퍼에서 받고 보내기 할 수있어 성능향상은 이루어졌다고 볼 수 있다. 가상머신 부분 생략 가능 ","date":"2023-07-22","objectID":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/:3:1","tags":["nio"],"title":"JAVA NIO 기반의 입출력","uri":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/"},{"categories":["java"],"content":"참고 https://zoiworld.tistory.com/620 ","date":"2023-07-22","objectID":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/:4:0","tags":["nio"],"title":"JAVA NIO 기반의 입출력","uri":"/java-nio-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%85%EC%B6%9C%EB%A0%A5/"},{"categories":["system"],"content":"프로세스 프로세스는 실행 중에 있는 프로그램을 의미한다. 여러분이 게임을 즐기기 위해서 게임 실행파일을 더블클릭하면, 그 순간 프로그램 실행을 위해 메모리 할당이 이루어집니다. 그리고 이 메모리 공간으로 바이너리 코드가 올라가게 되며, 이 순간부터 프로그램은 프로세스라고 불리게 된다. 대부분의 사람들은 하나의 프로그램만 사용하기보다는, 여러 프로그램을 동시에 사용하고 싶어한다. 하지만 컴퓨터가 하나의 명령을 수행하기 위해서 CPU를 점유하고 있으면 다른 작업은 실행될 수 없다. 둘 이상의 프로그램이 동시에 실행이 가능했던 이유는 하나의 CPU가 여러 개의 프로세스를 번갈아가며 실행하기 때문이다. CPU는 아주 빠르기 때문에 하나의 CPU가 여러 프로세스를 번갈아 실행해도 사용자는 전혀 눈치를 채지 못한다. 결국 동시에 여러 개의 프로그램이 실행되는 것처럼 보이는 이유는 여러 개의 프로세스들이 CPU 할당 시간을 나누기 때문이다. 이렇게 동시에 여러 프로세스를 처리하는 형태를 멀티프로세스라고 하며, 프로세스의 CPU 할당 순서 및 방법을 결정짓는 일을 가리켜 스케줄링이라고 한다. ","date":"2023-06-08","objectID":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/:1:0","tags":["process","thread"],"title":"프로세스, 스레드","uri":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["system"],"content":"스레드 ","date":"2023-06-08","objectID":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:0","tags":["process","thread"],"title":"프로세스, 스레드","uri":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["system"],"content":"컨텍스트 스위칭 멀티프로세스는 컨텍스트스위칭을 필요로 한다. 컨텍스트 스위칭은 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정이다. 실행중인 프로세스가 변경되면 CPU 내에 존재하는 데이터도 함께 변경되어야 한다. 예를 들어 프로세스 A가 실행중에 있다. 일정 시간이 지나서, 이제 프로세스 B를 실행해야 한다. 따라서 프로세스 B가 실행되기 전에 CPU에 저장된 A프로세스의 데이터를 메모리에 저장해야 한다. 이 데이터들은 프로세스 A가 실행을 이어서 진행할 경우 필요한 데이터들이기 때문이다. 또한 프로세스 B도 새롭게 실행되는 프로세스가 아니라면, 이전에 실행될 때 CPU에 있던 데이터들을 메모리에 저장해놓았을 것이다. 이 데이터들을 다시 CPU에 복원해야 한다. 그래야 프로세스B의 작업이 멈춰진 부분부터 이어질 수 있다. ","date":"2023-06-08","objectID":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:1","tags":["process","thread"],"title":"프로세스, 스레드","uri":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["system"],"content":"컨텍스트 스위칭을 줄이는 새로운 대안, 스레드 많은 수의 프로세스 생성은 빈번한 컨텍스트 스위칭으로 이어진다. 컨텍스트 스위칭이 발생하는 빈도수는 상황과 시스템에 따라서 차이가 있지만, 아무리 못해도 초당 수십 회 이상이다. 따라서 빈번한 컨텍스트 스위칭은 성능 저하의 원인이 됩니다. 멀티프로세스는 사용자에게 편의를 가져다 주지만, 두 가지 이상의 일을 동시에 처리하기 위해서 추가적으로 프로세스를 생성하는 작업은 상당히 부담스럽다. 빈번하게 발생하는 컨텍스트 스위칭에 소요되는 시간을 조금이라도 줄일 수 있다면 성능에 큰 향상을 기대할 수 있다. 이러한 생각에서 스레드가 탄생했다. 프로세스는 완전히 독립된 두 개의 프로그램 실행을 위해 사용된다. 그러나 스레드는 하나의 프로그램 내에서 둘 이상의 프로그램 흐름을 만들어내기 위해서 디자인되었다. 그리고 프로세스와 달리 스레드 간에는 공유하는 상태 정보들이 있다. 이것이 컨텍스트 스위칭을 빠르게 하는 요인이 된다. ","date":"2023-06-08","objectID":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:2","tags":["process","thread"],"title":"프로세스, 스레드","uri":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["system"],"content":"멀티스레드 방식에서 주의할 점 동시에 처리해야 할 일을 스레드로 구현할 경우 메모리 공간과 자원 소모를 줄일 수 있게 된다. 그러나 멀티스레드 방식에서는 주의해야할 점이 있다. 멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 대해 접근하는 일이 없었지만, 멀티 스레딩을 기반으로 프로그래밍할 때는 동일한 자원에 접근하는 일이 발생할 수 있다. 그 결과, 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 따라서 개발자들이 구현한 코드 중에 공유되는 메모리 자원에 대해서 한번에 한 스레드만 실행되도록 보호해주는 장치가 필요하다. 이를 동기화라고 한다. ","date":"2023-06-08","objectID":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:3","tags":["process","thread"],"title":"프로세스, 스레드","uri":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["system"],"content":"참고 개발자가 되기 위해 꼭 알아야 하는 IT 용어, 비제이퍼블릭 ","date":"2023-06-08","objectID":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/:3:0","tags":["process","thread"],"title":"프로세스, 스레드","uri":"/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["spring"],"content":"DelegatingFilterProxy와 FilterChainProxy ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:1:0","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"DelegatingFilterProxy 일반적인 서블릿 필터이며, 서블릿 필터 처리를 스프링에 들어있는 빈으로 위임할 때 사용한다. 타겟 빈 이름을 설정할 수 있다. 스프링 부트 없이 스프링 시큐리티 설정할 때는 AbstractSecurityWebApplicationInitializer를 사용해서 등록해서 사용하며, 스프링 부트를 사용할 때는 자동으로 등록 된다. (SecurityFilterAutoConfiguration) ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:1:1","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"FilterChainProxy 스프링부트에서 “springSecurityFilterChain” 이라는 이름의 빈으로 등록된다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:1:2","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"스프링 시큐리티 Filter 스프링 시큐리티가 제공하는 필터들은 다음과 같다. 이 모든 필터는 FilterChainProxy가 호출한다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:0","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"WebAsyncManagerIntegrationFilter 스프링 MVC의 Async 기능을 사용할 때에도 SecurityContext를 공유하도록 도와주는 필터이다. @Async를 사용한 서비스를 호출하는 경우에는 쓰레드가 다르기 때문에 SecurityContext를 공유받지 못한다. (기본은 MODE_THREADLOCAL 전략) SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL); 위와 같이 SecurityContextHolder 전략을 변경하면 @Async를 처리하는 쓰레드에서도 SecurityContext를 공유받을 수 있다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:1","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"SecurityContextPersistenceFilter SecurityContextRepository를 사용해서 기존의 SecurityContext를 읽어오거나 초기화 하는 필터이다. 기본으로 사용하는 전략은 HTTP Session을 사용한다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:2","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"HeaderWriterFilter 응답 헤더에 시큐리티 관련 헤더를 추가해주는 필터이다. XContentTypeOptionsHeaderWriter: 마임 타입 스니핑 방어 X-Content-Type-Options: nosniff XXssProtectionHeaderWriter: 브라우저에 내장된 XSS 필터 적용 X-XSS-Protection: 1; mode=block CacheControlHeadersWriter: 캐시 히스토리 취약점 방어 Cache-Control: no-cache, no-store, max-age=0, must-revalidate Expires: 0 Pragma: no-cache HstsHeaderWriter: HTTPS로만 소통하도록 강제 Strict-Transport-Security: max-age=31536000 ; includeSubdomains ; preload max-age : 브라우저가 HSTS 정책을 적용할 기간(초)을 설정한다. includeSubdomains : 도메인(example.com)의 서브 도메인(api.example.com 등)에도 HSTS 설정을 적용한다. preload : 해당 도메인이 브라우저의 preload list에 추가되며, 브라우저에서는 HSTS 헤더가 없더라도 HTTP요청을 HTTPS로 강제 변환하여 전송한다. XFrameOptionsHeaderWriter: clickjacking 방어 X-Frame-Options: DENY ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:3","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"CsrfFilter 이 기능은 인증과는 별도로 악의적인 공격자의 침입을 막는 필터이다. 클라이언트가 POST, PUT, DELETE 등의 HTTP METHOD 방식으로 요청할 때 반드시 csrf 토큰을 요구하게 되고 토큰이 없을 경우 서버 접근을 막는다. @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable(); } } 설정 클래스에서 CSRF 기능을 비활성화 하면 CsrfFilter 필터 클래스가 동작하지 않으므로 세션이 생성되지 않는다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:4","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"LogoutFilter 로그아웃을 처리하는 필터이다. LogoutHandler를 사용하여 로그아웃시 필요한 처리를 하며 이후에는 LogoutSuccessHandler를 사용하여 로그아웃 후처리를 한다. LogoutHandler CsrfLogoutHandler : csrfTokenRepository 에서 csrf 토큰을 삭제한다. SecurityContextLogoutHandler : 세션과 SecurityContext 를 삭제한다. LogoutSuccessHandler SimplUrlLogoutSuccessHandler : 로그아웃 페이지로 리다이렉트한다. http.logout() .logoutUrl(\"/logout\") .logoutSuccessUrl(\"/\") .logoutRequestMatcher() .invalidateHttpSession(true) .deleteCookies() .addLogoutHandler() .logoutSuccessHandler(); ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:5","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"UsernamePasswordAuthenticationFilter 폼 로그인을 처리하는 인증 필터이다. 사용자가 폼에 입력한 username과 password로 Authentcation을 만들고 AuthenticationManager를 사용하여 인증을 시도한다. AuthenticationManager (ProviderManager)는 여러 AuthenticationProvider를 사용하여 인증을 시도하는데, 그 중에 DaoAuthenticationProvider는 UserDetailsServivce를 사용하여 UserDetails 정보를 가져와 사용자가 입력한 password와 비교한다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:6","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"DefaultLoginPageGeneratingFilter 기본 로그인 폼 페이지를 생성해주는 필터이다. GET /login 요청을 처리한다. http.formLogin() .usernameParameter(\"my-username\") .passwordParameter(\"my-password\") .loginPage(\"/signin\"); ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:7","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"DefaultLogoutPageGeneratingFilter 기본 로그아웃 페이지를 생성해주는 필터이다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:8","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"BasicAuthenticationFilter Basic 인증을 처리하는 필터이다. Basic 인증 요청 헤더에 username와 password를 Base64 인코딩하여 실어 보내면 브라우저 또는 서버가 그 값을 읽어서 인증하는 방식이다. 예) Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l 브라우저 기반 요청이 클라이언트의 요청을 처리할 때 자주 사용하며, 보안에 취약하기 때문에 반드시 HTTPS를 사용할 것을 권장한다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:9","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"RequestCacheAwareFtiler 현재 요청과 관련 있는 캐시된 요청이 있는지 찾아서 적용하는 필터이다. 캐시된 요청이 없다면 현재 요청을 처리하고 캐시된 요청이 있다면 해당 캐시된 요청을 처리한다. ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:10","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"SecurityContextHolderAwareReqeustFilter 시큐리티 관련 서블릿 API를 구현해주는 필터이다. HttpServletRequest#authenticate(HttpServletResponse) HttpServletRequest#login(String, String) HttpServletRequest#logout() AsyncContext#start(Runnable) ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:11","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"AnonymouseAuthenticationFilter 익명 사용자를 인증하는 필터이다. SecurityContext에 저장된 Authentication이 null이면 익명 Authentication을 만들어 넣어주고, null이 아니면 아무일도 하지 않는다. 기본으로 만들어 사용할 익명 Authentication 객체를 설정할 수 있다. http.anonymous() .principal() .authorities() .key() ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:12","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"SessionManagementFilter 세션을 관리하는 필터이다. 세션 변조 방지 전략 설정: sessionFixation none newSession migrateSession (서블릿 3.0- 컨테이너 사용시 기본값) changeSessionId (서브릿 3.1+ 컨테이너 사용시 기본값) 유효하지 않은 세션을 리다이렉트 시킬 URL 설정 invalidSessionUrl 동시성 제어: maximumSessions 추가 로그인을 막을지 여부 설정 (기본값, false) 세션 생성 전략: sessionCreationPolicy IF_REQUIRED : 스프링 시큐리티가 필요 시 생성(default) NEVER : 스프링 시큐리티가 생성하지 않지만 이미 존재하면 사용 STATELESS : 스프링 시큐리티가 생성하지 않고 존재해도 사용하지 않음 ALWAYS : 스프링 시큐리티가 항상 세션 생성 @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.정책상수); } } ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:13","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"RememberMeAuthenticationFilter 세션이 사라지거나 만료가 되더라도 쿠키 또는 DB를 사용하여 저장된 토큰 기반으로 인증을 지원하는 필터이다. http.rememberMe() .userDetailsService(accountService) .key(\"remember-me-sample\"); ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:14","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"ExeptionTranslationFilter 필터 체인에서 발생하는 AuthenticationException과 AccessDeniedException을 처리하는 필터이다. AuthenticationException AuthenticationManager의 authenticate 메소드 실행 시 발생하는 예외이다. 비활성 계정, 잘못된 비밀번호, 잠긴 계정일 때 발생한다. public interface AuthenticationManager { Authentication authenticate(Authentication authentication) throws AuthenticationException; } AuthenticationEntryPoint를 실행하며, AuthenticationEntryPoint는 인증 예외가 발생했을시 어떻게 할 것인지를 결정한다. AccessDeniedException 익명 사용자라면 AuthenticationEntryPoint를 실행하며, 익명 사용자가 아니면 예외를 AccessDeniedHandler에게 위임한다. http.exceptionHandling() .accessDeniedHandler((request, response, accessDeniedException) -\u003e { UserDetails principal = (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal(); String username = principal.getUsername(); String servletPath = request.getServletPath(); System.out.println(username + \" is denied to access to \" + servletPath); response.sendRedirect(\"/access-denied\"); }); ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:15","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"FilterSecurityInterceptor AccessDecisionManager를 사용하여 Access Control 또는 예외 처리 하는 필터이다. 대부분의 경우 FilterChainProxy에 제일 마지막 필터로 들어있다. http.authorizeRequests() .mvcMatchers(\"/\", \"/info\", \"/account/**\", \"/signup\").permitAll() .mvcMatchers(\"/admin\").hasAuthority(\"ROLE_ADMIN\") .mvcMatchers(\"/user\").hasRole(\"USER\") .anyRequest().authenticated() .expressionHandler(expressionHandler()); AccessDecisionManager AccessDecisionManager는 Access Control 결정을 내리는 인터페이스로, 구현체 3가지를 기본으로 제공한다. AffirmativeBased: 여러 Voter중에 한명이라도 허용하면 허용. 기본 전략. ConsensusBased: 다수결 UnanimousBased: 만장일치 ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:2:16","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"참고 https://www.inflearn.com/course/%EB%B0%B1%EA%B8%B0%EC%84%A0-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0 ","date":"2023-05-05","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/:3:0","tags":["filter"],"title":"스프링 시큐리티 Filter","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-filter/"},{"categories":["spring"],"content":"다음은 스프링 시큐리티에서 사용하는 주요 개념에 대한 설명이다. ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:0:0","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"SecurityContextHolder 지정된 SecurityContext를 현재 실행 스레드와 연결한다. 이 클래스는 SecurityContextHolderStrategy 인스턴스에 위임하는 일련의 정적 메서드를 제공한다. 클래스의 목적은 주어진 JVM에 사용해야 하는 전략을 지정하는 편리한 방법을 제공하는 것이다. 기본적으로 ThreadLocal을 사용한다. ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:1:0","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"SecurityContext 현재 실행 스레드와 관련된 최소 보안 정보를 정의하는 인터페이스이다. 보안 컨텍스트는 SecurityContextHolder에 저장되며, Authentication을 제공한다. public interface SecurityContext extends Serializable { Authentication getAuthentication(); void setAuthentication(Authentication authentication); } ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:2:0","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"AuthenticationManager 스프링 시큐리티에서 인증을 하는 주체이다. 인자로 받은 Authentication이 유효한 인증인지 확인하고 Authentication 객체를 리턴한다. 사용자가 입력한 password가 UserDetailsService를 통해 읽어온 UserDetails 객체에 들어있는 password와 일치하는지, 해당 사용자 계정이 잠겨 있진 않은지, 비활성 계정은 아닌지 등 확인한다. 인증을 확인하는 과정에서 비활성 계정, 잘못된 비번, 잠긴 계정 등의 에러를 던질 수 있다. public interface AuthenticationManager { Authentication authenticate(Authentication authentication) throws AuthenticationException; } ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:3:0","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"Authentication AuthenticationManager.authenticate(Authentication) 메소드에 의해 요청이 처리된 후 인증 요청 또는 인증된 주체에 대한 토큰을 나타낸다. 요청이 인증되면 인증은 일반적으로 사용 중인 인증 메커니즘에 의해 SecurityContextHolder가 관리하는 스레드 로컬 SecurityContext에 저장된다. Principal과 Credentials, GrantAuthority 등을 제공한다. public interface Authentication extends Principal, Serializable { Collection\u003c? extends GrantedAuthority\u003e getAuthorities(); Object getCredentials(); Object getDetails(); Object getPrincipal(); boolean isAuthenticated(); void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException; } ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:4:0","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"Principal 개인, 회사 및 로그인 ID와 같은 모든 엔터티를 나타내는 데 사용할 수 있는 주체의 추상 개념을 나타낸다. UserDetailsService에서 리턴한 객체이며 UserDetails 타입이다. ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:4:1","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"GrantAuthority 인증 개체에 부여된 권한을 나타낸다. “ROLE_USER”, “ROLE_ADMIN” 등으로 나타내며, 인증 이후, 인가 및 권한 확인할 때 이 정보를 참조한다. ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:4:2","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"UserDetails 애플리케이션이 가지고 있는 유저 정보와 스프링 시큐리티가 사용하는 Authentication 객체 사이의 어댑터이며, 핵심 사용자 정보를 제공한다. 구현은 보안 목적으로 Spring Security에서 직접 사용되지 않는다. 나중에 인증 개체에 캡슐화되는 사용자 정보를 저장하기만 하면 된다. 이를 통해 보안과 관련되지 않은 사용자 정보(이메일 주소, 전화번호 등)를 편리한 위치에 저장할 수 있다. public interface UserDetails extends Serializable { Collection\u003c? extends GrantedAuthority\u003e getAuthorities(); String getPassword(); String getUsername(); boolean isAccountNonExpired(); boolean isAccountNonLocked(); boolean isCredentialsNonExpired(); boolean isEnabled(); } ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:5:0","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"UserDetailsService 유저 정보를 UserDetails 타입으로 가져오는 DAO(Data Access Object) 인터페이스이다. public interface UserDetailsService { UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; //사용자 이름을 기준으로 사용자를 찾는다. } 세부 구현은 마음대로 가능하다. 실제 구현에서는 구현 인스턴스가 구성된 방식에 따라 검색이 대소문자를 구분하거나 대소문자를 구분하지 않을 수 있다. ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:6:0","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"참고 https://www.inflearn.com/course/%EB%B0%B1%EA%B8%B0%EC%84%A0-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0 ","date":"2023-05-04","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/:7:0","tags":["SecuuryContext","Authentication"],"title":"스프링 시큐리티 주요 개념","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"categories":["spring"],"content":"Filter Filter(필터)는 요청과 응답을 거른 뒤 정제하는 역할을 한다. 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러 가지 체크를 수행할 수 있다. 또한 자원의 처리가 끝난 후 응답 내용에 대해서도 변경하는 처리를 할 수가 있다. 즉 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS 방어 등의 요청에 대한 처리로 사용된다. ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:1:0","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"필터 흐름 HTTP 요청 -\u003e WAS -\u003e 필터 -\u003e 서블릿 -\u003e 컨트롤러 ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:1:1","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"필터 인터페이스 public interface Filter { public default void init(FilterConfig filterConfig) throws ServletException{} public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public default void destroy() {} } 필터 인터페이스를 구현하고 등록하면 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고, 관리한다. init(): 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다. doFilter(): 고객의 요청이 올 때 마다 해당 메서드가 호출된다. 필터의 로직을 구현하면 된다. destroy(): 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다. ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:1:2","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"Interceptor 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답을 처리한다. 스프링의 모든 빈 객체에 접근할 수 있다. 인터셉터는 여러 개를 사용할 수 있고 로그인 체크, 권한 체크, 프로그램 실행 시간 계산작업 로그 확인 등의 업무처리에 사용한다. ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:2:0","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"스프링 인터셉터 흐름 HTTP 요청 -\u003e WAS -\u003e 필터 -\u003e 서블릿 -\u003e 스프링 인터셉터 -\u003e 컨트롤러 스프링 인터셉터는 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출 된다. 스프링 인터셉터는 스프링 MVC가 제공하는 기능이기 때문에 결국 디스패처 서블릿 이후에 등장하게 된다. 스프링 인터셉터에도 URL 패턴을 적용할 수 있는데, 서블릿 URL 패턴과는 다르고, 매우 정밀하게 설정할 수 있다. ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:2:1","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"스프링 인터셉터 인터페이스 스프링의 인터셉터를 사용하려면 HandlerInterceptor 인터페이스를 구현하면 된다. public interface HandlerInterceptor { default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {} default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {} default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {} } 서블릿 필터의 경우 단순하게 doFilter() 하나만 제공된다. 인터셉터는 컨트롤러 호출 전( preHandle ), 호출 후( postHandle ), 요청 완료 이후( afterCompletion )와 같이 단계적으로 세분화 되어 있다. 서블릿 필터의 경우 단순히 request , response 만 제공하지만, 인터셉터는 어떤 컨트롤러( handler )가 호출되는지 호출 정보도 받을 수 있다. 그리고 어떤 modelAndView 가 반환되는지 응답 정보도 받을 수 있다. ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:2:2","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"스프링 인터셉터 호출 흐름 정상 흐름 preHandle` : 컨트롤러 호출 전에 호출된다. (더 정확히는 핸들러 어댑터 호출 전에 호출된다.) preHandle 의 응답값이 true 이면 다음으로 진행하고, false 이면 더는 진행하지 않는다. false 인 경우 나머지 인터셉터는 물론이고, 핸들러 어댑터도 호출되지 않는다. 그림에서 1번에서 끝이 나버린다. postHandle : 컨트롤러 호출 후에 호출된다. (더 정확히는 핸들러 어댑터 호출 후에 호출된다.) afterCompletion : 뷰가 렌더링 된 이후에 호출된다. 예외 상황 preHandle : 컨트롤러 호출 전에 호출된다. postHandle : 컨트롤러에서 예외가 발생하면 postHandle 은 호출되지 않는다. afterCompletion : afterCompletion 은 항상 호출된다. 이 경우 예외( ex )를 파라미터로 받아서 어떤 예외가 발생했는지 로그로 출력할 수 있다. ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:2:3","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"AOP AOP는 OOP를 보완하기 위해 나온 개념이다. 객체 지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다. 주로 ‘로깅’, ‘트랜잭션’, ‘에러 처리’ 등 비즈니스단의 메소드에서 조금 더 세밀하게 조정할 때 사용한다. Interceptor나 Filter와는 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다. Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야 하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다. @Before: 대상 메소드의 수행 전 @After: 대상 메소드의 수행 후 @After-returning: 대상 메소드의 정상적인 수행 후 @After-throwing: 예외발생 후 @Around: 대상 메소드의 수행 전, 후 ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:3:0","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"참고 https://dejavuhyo.github.io/posts/spring-filter-interceptor-aop-differences/ https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2 ","date":"2023-03-07","objectID":"/filter-vs-interceptor-vs-aop/:4:0","tags":["filter","interceptor","aop"],"title":"Filter vs Interceptor vs AOP","uri":"/filter-vs-interceptor-vs-aop/"},{"categories":["spring"],"content":"Dependency Injection Dependency Injection은 말 그대로 의존성 주입을 말한다. 이는 객체 간의 의존성을 외부에서 주입하여 관리하겠다라는 개념이다. 의존성이 높으면 코드의 재사용성이 떨어지고 변경에 유연하지 못하며 테스트 코드를 작성하기 어려워진다. 외부에서 의존을 주입받으면 의존을 내부에서 정의하지 않기 때문에 객체 간의 의존성을 줄여주고 코드의 재사용성도 증가하며 변화에 민감하지 않을 수 있다. 이때 변화에 민감하다는 말은 객체 자신이 아니라 의존하고 있는 다른 객체의 변경으로부터 민감한 정도를 말한다. 의존의 정도가 작을수록 의존 객체의 변경에 크게 영향을 받지 않는다. 외부에서 의존을 주입받는 방법은 기존에 마치 이전에 내부에서 의존을 관리하는 방법을 뒤바꾼듯한 모양이다. 이를 IoC(Inversion of Control)이라 한다. DI vs IoC IoC는 객체 생명 관리, 흐름 제어를 제 3자에게 위임하는 프로그래밍 모델이다. DI라는 말은 마틴파울러와 그 주변사람들이 객체 주입이라는 의미를 명확히 하기 위해 만들어졌다. 컨테이너차원에서 수많은 객체들에 의존관계를 파악하고 런타임시점에서 다이나믹하게 객체를 주임하여 유연한 프로그래밍을 할 수 있도록 하는 패턴에 더 명확한 이름을 부여하기 위해 토론 끝에 Dependency Injection 이라는 용어를 만들었다. ","date":"2023-03-05","objectID":"/dependency-injection/:1:0","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Dependency Injection의 방법 ","date":"2023-03-05","objectID":"/dependency-injection/:2:0","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Field Injection 가장 흔히 볼 수 있는 Injection 방법으로 사용하기도 간편하고 코드도 읽기 쉽다. @Service public class LineService { @Autowired private LineRepository repository; public LineService() { } } ","date":"2023-03-05","objectID":"/dependency-injection/:2:1","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Setter Injection 이 방식은 Setter/Getter와 같은 접근자 메서드(Accessor)를 최소한으로 해야한다는 원칙과도 어긋나고, 주입받는 객체가 변경될 가능성도 거의 없기에 거의 사용하지 않는다. @Service public class LineService { private LineRepository repository; public LineService() { } @Autowired public void setRepository(LineRepository lineRepository) { this.repository = lineRepository; } } ","date":"2023-03-05","objectID":"/dependency-injection/:2:2","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Constructor Injection private MemberService memberService; @Autowired public xxxController(MemberService memberService){ ... } 필드가 단 하나뿐이라면 @Autowired 애노테이션이 없어도 자동 주입을 해준다. ","date":"2023-03-05","objectID":"/dependency-injection/:2:3","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Constructor Injection을 써야 하는 이유 기존에 가장 흔히 사용하는 Field Injection이 아니라 Constructor Injection을 써야 하는 이유는 다음과 같다. 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다. 생성자 주입을 사용하면 주입 데이터를 누락 했을 때 컴파일 오류가 발생한다. 그리고 IDE에서 바로 어떤 값을 필수로 주입해야 하는지 알 수 있다. 생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다. 정리 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이기도 하다. 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 생성자 주입과 수정자 주입을 동시에 사용할 수 있다. 항상 생성자 주입을 선택해라! 그리고 가끔 옵션이 필요하면 수정자 주입을 선택해라. 필드 주입은 사용하지 않는게 좋다. ","date":"2023-03-05","objectID":"/dependency-injection/:3:0","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-07-18-di-constuctor-injection/ https://jwchung.github.io/DI%EB%8A%94-IoC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%84%EB%8F%84-%EB%90%9C%EB%8B%A4 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8 ","date":"2023-03-05","objectID":"/dependency-injection/:4:0","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["java"],"content":"Java에서 String을 생성하는 방식 String 클래스의 경우 다른 참조 자료형과 달리 불변의 원칙이 적용되며, 참조 클래스 중 유일하게 + 연산을 수행할 수 있다. Java에서 String을 생성하는 방식은 두가지가 있다. 생성자를 이용하는 방법 String str = new String(“Hello”); 리터럴을 이용하는 방법 String str = “Hello”; String a = \"apple\"; String b = new String(\"apple\"); String c = \"apple\"; String d = new String(\"apple\"); System.out.println(a==b); // false System.out.prrintln(a==c); // true 첫 번째 줄에서 String a가 생성될 때, ‘apple’은 리터럴 문자열이므로 Heap영역 중에서 String pool에 위치하게 된다. 두 번째 줄에서 String b는 new연산자를 통해 객체를 생성한다. Heap영역에 위치하지만 String pool이 아닌 다른 주소값을 참조한다. ‘==‘연산자는 같은 메모리를 참조하는가를 비교한다. 때문에 a와 b의 비교(a==b)는 false를 반환하게 된다. 세번째 줄에서 c가 가리키는 ‘apple’을 String pool에 넣으려고 보니 이미 ‘apple’이 존재한다. 그러면 c는 a와 같은 String pool의 ‘apple’을 가리키게 된다. a와 c가 같은 값을 참조하므로 a==c는 true를 반환한다. 이를 그림으로 표현해보면 다음과 같다. ","date":"2023-02-16","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:1:0","tags":["string-pool","intern()"],"title":"Java에서 String을 생성하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"생성자로 초기화하는 방식 String 클래스는 생성자를 통해서 초기화하면 Heap 메모리에 해당 값을 할당한다 생성자를 통해 초기화된 String 변수들은 똑같은 문자열이라고 해도, Heap 메모리에 할당된 영역이 각 변수마다 다르기 때문에 동등비교연산자(==)로 비교했을 때 false가 리턴된다. 즉, 똑같은 문자열이 Heap 메모리에 여러 개 있다는 의미이다. 이는 동등비교연산자가 객체를 비교할 때 객체의 메모리 주소를 비교하기 때문인데, 문자열 자체를 비교하기 위해서는 String 클래스에서 재정의된 equals() 메소드를 호출 해야한다. ","date":"2023-02-16","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:1:1","tags":["string-pool","intern()"],"title":"Java에서 String을 생성하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"리터럴로 초기화하는 방식 String을 리터럴로 선언할 경우 내부적으로 String의 intern()메서드가 호출되게 된다. intern() 메서드는 주어진 문자열이 String pool에 존재하는지 검색하고 있다면 그 주소값을 반환, 없다면 문자열을 String pool에 넣고 그 주소값을 반환한다. Heap 영역은 GC의 대상이기 때문에 String Constant Pool에서 참조를 잃은 문자열 객체들은 다시 메모리로 반환된다. String a = \"apple\"; String b = new String(\"apple\"); String c = b.intern() System.out.println(a==b); // false System.out.prrintln(a==c); // true c의 경우 b의 값인 ‘apple’이 String pool에 이미 존재하는가를 찾고, 이미 존재하므로 해당 문자열을 반환해 c=‘apple’이 된다. a와 c는 결국 같은 주소를 참조하게 되어 a==c는 true가 된다. ","date":"2023-02-16","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:1:2","tags":["string-pool","intern()"],"title":"Java에서 String을 생성하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"참고 https://simple-ing.tistory.com/3 https://tecoble.techcourse.co.kr/post/2020-09-07-dive-into-java-string/ ","date":"2023-02-16","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:2:0","tags":["string-pool","intern()"],"title":"Java에서 String을 생성하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"Java에서 String이 불변인 이유 String은 기본 타입(Primitive Type)이 아닌 참조 타입(Reference Type)이다. 즉, String은 클래스이다. Java에서 String 객체를 리터럴로 선언하면 특별히 스택 메모리에 직접 저장되는 것이 아니라 Heap 영역 중에서 String constant pool이라는 곳에 메모리를 할당받아 거기에 값을 저장한다. 그리고 String 변수는 그 주소 값을 참조하게 된다. 따라서 Java에서 String은 불변성을 띄게 된다. Java에서 String이 불변인 이유는 다음과 같다. String pool을 통해 String을 관리함으로써 Java는 Runtime에서 Heap 영역의 많은 메모리를 절약할 수 있다. 왜냐하면 같은 값을 갖는 String에 대해 같은 메모리를 참조하게 할 수 있기 때문이다. String이 불변이 아니라면 보안상의 문제를 야기할 수 있다. 예를 들어, DB의 username과 password 라던가, 소켓 통신에서 host와 port에 대한 정보가 String으로 다루어지기 때문에 String이 불변이라야 해커의 공격으로부터 값이 변경되는 것을 예방할 수 있다. String이 불변이기 때문에 멀티 쓰레딩 환경에서 안전(thread-safe)한다. 값의 변경 가능성이 없기 때문에 멀티 쓰레딩 환경에서 동기화 문제를 걱정하지 않아도 된다. Java는 String의 hashcode를 생성 단계에서부터 캐싱한다. 따라서 String의 hashcode는 쓰일 때마다 매번 계산되지 않는다. 이 특징은 특히 객체의 hashCode를 Key로 사용하는 HashMap의 경우에 효과를 발휘한다. 다른 객체는 키로 쓰일 때마다 hashCode를 계산하는데 비해 String은 캐싱을 하고 있기 때문에 다른 객체를 Key로 했을 때보다 String을 Key로 했을 때 더 빠른 속도로 사용할 수 있다. ","date":"2023-02-15","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%B4-%EB%B6%88%EB%B3%80%EC%9D%B8-%EC%9D%B4%EC%9C%A0/:1:0","tags":["immutable","string-pool"],"title":"Java에서 String이 불변인 이유","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%B4-%EB%B6%88%EB%B3%80%EC%9D%B8-%EC%9D%B4%EC%9C%A0/"},{"categories":["java"],"content":"참고 https://readystory.tistory.com/139 ","date":"2023-02-15","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%B4-%EB%B6%88%EB%B3%80%EC%9D%B8-%EC%9D%B4%EC%9C%A0/:2:0","tags":["immutable","string-pool"],"title":"Java에서 String이 불변인 이유","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%B4-%EB%B6%88%EB%B3%80%EC%9D%B8-%EC%9D%B4%EC%9C%A0/"},{"categories":["spring"],"content":"PSA란 환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하는 추상화 구조를 말한다. POJO원칙을 철저히 따른 Spring의 기능으로 Spring에서 동작할 수 있는 Library들은 POJO원칙을 지키게끔 PSA형태의 추상화가 되어있음을 의미한다. 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이다. 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다. ","date":"2023-02-15","objectID":"/spring-psa/:0:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"PSA 예시 ","date":"2023-02-15","objectID":"/spring-psa/:1:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"Spring Web MVC 원래 Servlet을 사용하려면 HttpServlet을 상속받은 클래스를 만들고 Get, Post 등에 대한 메소드를 오버라이딩하여 사용해야 한다. @Controller에 대해 생각해보자. 클래스 선언부에 이 어노테이션을 사용하면 클래스 내부에서 메소드에 @GetMapping, @PostMapping등을 사용할 수 있고 클래스 선언부에 @RequestMapping을 사용할 수 있다. 이것이 “잘 만든 인터페이스\"의 예시이다. 이러한 편의성 제공이 서비스 추상화의 목적이다. 우리는 @Controller, @GetMapping같은 기능들의 뒷단의 복잡한 코드에 대해서 깊게 고려하지 않아도 되고 이런 기술들을 기반으로 하여 기존 코드를 거의 변경하지 않아도 된다. 또한, 실행 서버를 Tomcat이 아닌 netty로 변경하고 싶다면 프로젝트 설정에 spring-boot-starter-web 의존성 대신 spring-boot-starter-webflux 의존성을 받도록 하면 된다. 여러가지 복잡하고 잘 만들어진 인터페이스들, 의존성같은 기술들을 기반으로 하여 Spring은 개발자에게 편리한 환경을 제공한다. ","date":"2023-02-15","objectID":"/spring-psa/:1:1","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"Spring Transaction JDBC를 사용해서 DB접근하고 작업, 트랜잭션을 구현할 때는 연결, 작업할 쿼리문, commit, rollback하는 코드를 전부 작성해야 했다. 그러나 Spring에선 메소드에 @Transactional을 통해 트랜잭션 처리를 간단하게 할 수 있다. ","date":"2023-02-15","objectID":"/spring-psa/:1:2","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"참고 https://velog.io/@kimsunfang/Spring%EC%9D%98-3%EB%8C%80-%EC%9A%94%EC%86%8C ","date":"2023-02-15","objectID":"/spring-psa/:2:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"@Bean @Bean은 메소드 레벨에서 선언하며, 반환되는 객체(인스턴스)를 개발자가 수동으로 빈으로 등록하는 애노테이션이다. @Configuration public class AppConfig { @Bean public MemberService memberService() { return new MemberServiceImpl(); } } ","date":"2023-02-01","objectID":"/bean-vs-component/:1:0","tags":["annotation"],"title":"Bean vs Component","uri":"/bean-vs-component/"},{"categories":["spring"],"content":"@Component @Component는 클래스 레벨에서 선언함으로써 스프링이 런타임시에 컴포넌트스캔을 하여 자동으로 빈을 찾고(detect) 등록하는 애노테이션이다. @Component public class Utility { // ... } ","date":"2023-02-01","objectID":"/bean-vs-component/:2:0","tags":["annotation"],"title":"Bean vs Component","uri":"/bean-vs-component/"},{"categories":["spring"],"content":"@Bean vs @Component @Bean의 경우 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우에 사용된다. (예를 들면 ObjectMapper의 경우 ObjectMapper Class에 @Component를 선언할수는 없으니 ObjectMapper의 인스턴스를 생성하는 메소드를 만들고 해당 메소드에 @Bean을 선언하여 Bean으로 등록한다.) 반대로 개발자가 직접 컨트롤이 가능한 Class들의 경우엔 @Component를 사용한다. @Bean과 @Component는 각자 선언할 수 있는 타입이 정해져있어 해당 용도외에는 컴파일 에러를 발생시킨다. ","date":"2023-02-01","objectID":"/bean-vs-component/:3:0","tags":["annotation"],"title":"Bean vs Component","uri":"/bean-vs-component/"},{"categories":["spring"],"content":"참고 https://youngjinmo.github.io/2021/06/bean-component/ https://jojoldu.tistory.com/27 ","date":"2023-02-01","objectID":"/bean-vs-component/:4:0","tags":["annotation"],"title":"Bean vs Component","uri":"/bean-vs-component/"},{"categories":["spring"],"content":"@RequestBody 클라이언트가 body에 JSON 또는 XML 형태로 값(보통 객체)을 담아 전송하면, body의 내용을 다시 Java Object(객체)로 변환해주는 역할을 수행한다. 이 데이터는 Spring에서 관리하는 MessageConverter들 중 하나인 Jackson2HttpMessageConverter를 통해 Java 객체로 변환된다. ","date":"2023-01-20","objectID":"/requestbody-modelattribute-requestparam/:1:0","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam","uri":"/requestbody-modelattribute-requestparam/"},{"categories":["spring"],"content":"DTO에 기본 생성자가 필요한 이유 RestController에서 @RequestBody의 바인딩은 Jackson라이브러리의 ObjectMapper가 해준다. ObjectMapper는 @RequestBody가 Property로 구현되어 있거나 생성을 위임한 경우가 아니라면 기본 생성자로 생성한다. 따라서 두 상황이 아니라면 기본 생성자는 꼭 필요하다. ","date":"2023-01-20","objectID":"/requestbody-modelattribute-requestparam/:1:1","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam","uri":"/requestbody-modelattribute-requestparam/"},{"categories":["spring"],"content":"Setter가 필요없는 이유 ObjectMapper는 Setter 또는 Getter로 DTO의 필드를 가져온다. 그리고 setter를 사용하지 않는 경우에는 reflection을 사용해서 필드 값들을 넣어준다. ","date":"2023-01-20","objectID":"/requestbody-modelattribute-requestparam/:1:2","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam","uri":"/requestbody-modelattribute-requestparam/"},{"categories":["spring"],"content":"@ModelAttribute 클라이언트가 전송하는 HTTP parameter(URL 끝에 추가하는 파라미터), HTTP Body 내용을 1:1로 객체에 데이터를 바인딩한다. HTTP Body 내용은 multipart/form-data 형태이다. 따라서 Form 안에 input 값을 담아 보낼 때 유용하게 사용된다. ","date":"2023-01-20","objectID":"/requestbody-modelattribute-requestparam/:2:0","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam","uri":"/requestbody-modelattribute-requestparam/"},{"categories":["spring"],"content":"Setter가 필요한 이유 객체 바인딩 시 별다른 설정이 없다면 Spring 에서는 WebDataBinder의 기본 값 할당 방법인 Java Bean 방식을 사용한다. 그러므로 Setter가 없으면 작동하지 않는다. ","date":"2023-01-20","objectID":"/requestbody-modelattribute-requestparam/:2:1","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam","uri":"/requestbody-modelattribute-requestparam/"},{"categories":["spring"],"content":"@RequestParam HTTP 요청 parameter를 변수로 1대 1로 Mapping 해준다. default는 required = true 이다. 잘못된 파라미터값이 들어오면 400 BadRequest를 발생시킨다. ","date":"2023-01-20","objectID":"/requestbody-modelattribute-requestparam/:3:0","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam","uri":"/requestbody-modelattribute-requestparam/"},{"categories":["spring"],"content":"참고 https://parkadd.tistory.com/70 ","date":"2023-01-20","objectID":"/requestbody-modelattribute-requestparam/:4:0","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam","uri":"/requestbody-modelattribute-requestparam/"},{"categories":["java"],"content":"Resizable ","date":"2023-01-15","objectID":"/array-vs-arraylist/:1:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Array Array는 static하다(길이 고정). Array 객체를 생성한 후에는 Array의 길이를 마음대로 변경할 수 없다. 따라서, 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어주어야 한다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:1:1","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"ArrayList ArrayList는 사이즈가 dynamic하다. 하지만 내부적으론 배열로 구성되어 있다. ArrayList는 Default로 10개의 공간을 가진 배열로 시작한다. 하지만 최적화(지연 초기화)로 인해 막 생성하면 0개의 사이즈로 시작된다. 각각의 ArrayList Object는 ArrayList의 size를 나타내는 capacity 인스턴스 변수를 가지고 있다. ArrayList에 요소들이 더해지면 ArrayList의 capacity 또한 자동적으로 늘어난다. 만약 설정한 capacity를 넘어서 더 많은 객체가 들어오면, 배열 크기를 1.5배 증가시킨다. 즉 element를 add하려고 할때, capacity가 배열의 길이와 같아지면 일반적으로 기존의 용량 + 기존 용량/2 만큼 크기가 늘어난 배열에 기존의 배열을 copy해준다. /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); //기존 용량 + 기존 용량 /2 (우측 shift 연산) if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } ","date":"2023-01-15","objectID":"/array-vs-arraylist/:1:2","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Performance ArrayList의 자동 크기 조정은 임시 배열을 사용하여 이전 배열의 요소를 새 배열로 복사하기 때문에 성능이 저하된다. ArrayList의 자동 resize는 성능을 낮출 것이다(old array에서 new array로 요소들을 옮길 때 임시 array를 사용하기 때문에). ArrayList는 resizing하는 동안 내부적으로 Array의 지원을 받는다.(내부적으로 native method인 System.arrayCopy(…)를 사용하기 때문에) Array나 ArrayList로 부터 요소를 얻거나 추가할 때는 거의 비슷한 성능을 보인다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:2:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Data types ","date":"2023-01-15","objectID":"/array-vs-arraylist/:3:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Array primitive type, Object ","date":"2023-01-15","objectID":"/array-vs-arraylist/:3:1","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"ArrayList ArrayList는 primitive data types(int, float, double etc)을 가질 수 없다. 오직 Object만을 가질 수 있다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:3:2","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Iterating the values ","date":"2023-01-15","objectID":"/array-vs-arraylist/:4:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Array for loop 아니면 for each loop를 통해 array를 순회할 수 있다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:4:1","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"ArrayList iterator를 사용해 ArrayList를 순회할 수 있다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:4:2","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Type-Safety ","date":"2023-01-15","objectID":"/array-vs-arraylist/:5:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Array Array는 동종(homogeneous) data structure이다. 따라서 Array는 특정 데이터 타입의 primitives나 특정 클래스의 objects만을 저장할 수 있다. 만약 명시된 타입이 아닌 다른 데이터 유형을 Array에 저장할 경우 ArrayStoreException이 발생한다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:5:1","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"ArrayList Generics(제네릭스)를 통해 Type-Safety를 보장한다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:5:2","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Length ","date":"2023-01-15","objectID":"/array-vs-arraylist/:6:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Array Array의 길이를 반환하는 length 변수 ","date":"2023-01-15","objectID":"/array-vs-arraylist/:6:1","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"ArrayList size() 메소드 ","date":"2023-01-15","objectID":"/array-vs-arraylist/:6:2","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Adding elements ","date":"2023-01-15","objectID":"/array-vs-arraylist/:7:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Array Assign operator(=)를 사용하여 요소를 추가한다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:7:1","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"ArrayList add() 메소드를 사용하여 요소를 추가한다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:7:2","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Multi-dimensional ","date":"2023-01-15","objectID":"/array-vs-arraylist/:8:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"Array 다차원이 가능하다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:8:1","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"ArrayList 항상 단일 차원이다. ","date":"2023-01-15","objectID":"/array-vs-arraylist/:8:2","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["java"],"content":"참고 https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array-vs-ArrayList ","date":"2023-01-15","objectID":"/array-vs-arraylist/:9:0","tags":["array","arraylist"],"title":"Array vs ArrayList","uri":"/array-vs-arraylist/"},{"categories":["spring"],"content":"Bean은 스프링에서 사용하는 POJO 기반 객체다. 상황과 필요에 따라 Bean을 사용할 때 하나만 만들어야 할 수도 있고, 여러개가 필요할 때도 있고, 어떤 한 시점에서만 사용해야할 때가 있을 수 있다. 이를 위해 Scope를 설정해서 Bean의 사용 범위를 개발자가 설정할 수 있다. 우선 따로 설정을 해주지 않으면, Spring에서 Bean은 Singleton으로 생성된다. 특정 타입의 Bean을 딱 하나만 만들고 모두 공유해서 사용하기 위함이다. 보통은 Bean을 이렇게 하나만 만들어 사용하는 경우가 대부분이지만, 요구사항이나 구현에 따라 아닐 수도 있을 것이다. 따라서 Bean Scope는 싱글톤 말고도 여러가지를 지원해준다. ","date":"2023-01-04","objectID":"/bean-scope/:0:0","tags":["bean"],"title":"Bean Scope","uri":"/bean-scope/"},{"categories":["spring"],"content":"Scope 종류 singleton 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다. prototype 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다. 웹 관련 스코프 request 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다. session 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다. application 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다. ","date":"2023-01-04","objectID":"/bean-scope/:1:0","tags":["bean"],"title":"Bean Scope","uri":"/bean-scope/"},{"categories":["spring"],"content":"Scope 설정 Scope들은 Bean으로 등록하는 클래스에 어노테이션으로 설정해줄 수 있다. import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Service; @Scope(\"prototype\") @Component public class UserController { } ","date":"2023-01-04","objectID":"/bean-scope/:2:0","tags":["bean"],"title":"Bean Scope","uri":"/bean-scope/"},{"categories":["spring"],"content":"프로토타입 스코프 프로토타입 빈의 특징을 정리하면 다음과 같다. 스프링 컨테이너에 요청할 때 마다 새로 생성된다. 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다. 종료 메서드가 호출되지 않는다. 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다. ","date":"2023-01-04","objectID":"/bean-scope/:3:0","tags":["bean"],"title":"Bean Scope","uri":"/bean-scope/"},{"categories":["spring"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8 ","date":"2023-01-04","objectID":"/bean-scope/:4:0","tags":["bean"],"title":"Bean Scope","uri":"/bean-scope/"},{"categories":["spring"],"content":"싱글톤 패턴 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다. 싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 하지만 싱글톤 패턴은 다음과 같은 문제점들을 가지고 있다. ","date":"2023-01-03","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/:1:0","tags":["singleton"],"title":"스프링의 싱글톤 설정","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"싱글톤 패턴 문제점 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다. 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다. 테스트하기 어렵다. 내부 속성을 변경하거나 초기화 하기 어렵다. 결론적으로 유연성이 떨어진다. 안티패턴으로 불리기도 한다. ","date":"2023-01-03","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/:1:1","tags":["singleton"],"title":"스프링의 싱글톤 설정","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"싱글톤 컨테이너 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다. 스프링 빈이 싱글톤으로 관리되는 빈이다. 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다. 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다. 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다. DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다. 스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 재사용할 수 있다. ","date":"2023-01-03","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/:2:0","tags":["singleton"],"title":"스프링의 싱글톤 설정","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"싱글톤 방식의 주의점 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 무상태(stateless)로 설계해야 한다. 특정 클라이언트에 의존적인 필드가 있으면 안된다. 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다! 가급적 읽기만 가능해야 한다. 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다. ","date":"2023-01-03","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/:2:1","tags":["singleton"],"title":"스프링의 싱글톤 설정","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"@Configuration과 바이트코드 조작 스프링 컨테이너는 싱글톤 레지스트리이므로, 스프링 빈이 싱글톤이 되도록 보장해주어야 한다. 그러나 자바 코드 자체를 조작할 수는 없므로 클래스의 바이트코드 조작 라이브러리인 “CGLIB\"를 사용한다. 스프링은 CGLIB를 사용하여 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들어 스프링 빈으로 등록함으로써 싱글톤을 보장한다. ","date":"2023-01-03","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/:3:0","tags":["singleton"],"title":"스프링의 싱글톤 설정","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"AppConfig@CGLIB 예상 코드 @Bean public MemberRepository memberRepository() { if(memoryMemberRepository가 이미 스프링 컨테이너에 등록되어 있음) { return 스프링 컨테이너에서 찾아서 반환; } else { //스프링 컨테이너에 없으면 기존 로직을 호출하여 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록 return 반환; } } @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다. @Configuration을 적용하지 않고 @Bean만 적용하는 경우 @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다. ","date":"2023-01-03","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/:3:1","tags":["singleton"],"title":"스프링의 싱글톤 설정","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8 ","date":"2023-01-03","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/:4:0","tags":["singleton"],"title":"스프링의 싱글톤 설정","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%84%A4%EC%A0%95/"},{"categories":["spring"],"content":"스프링(Spring)이란? 자바 플랫폼을 위한 자바 언어 기반의 오픈 소스 애플리케이션 프레임워크 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크 ","date":"2023-01-02","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/:1:0","tags":["IoC","DI","AOP"],"title":"스프링이란?","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/"},{"categories":["spring"],"content":"스프링 생태계 ","date":"2023-01-02","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/:2:0","tags":["IoC","DI","AOP"],"title":"스프링이란?","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/"},{"categories":["spring"],"content":"스프링 프레임워크 필수 항목 내용 코어 기술 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술 스프링 MVC, 스프링 WebFlux 데이터 접근 기술 트랜잭션, JDBC, ORM 지원, XML 지원 통합 기술 캐시, 이메일, 원격 접근, 스케줄링 선택 스프링 데이터 스프링 세션 스프링 시큐리티 스프링 Rest Docs 스프링 배치 스프링 클라우드 스프링의 특징 경량 컨테이너 \u0026 자바 객체 직접 관리 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리한다. 스프링으로부터 필요한 객체를 얻어올 수 있다 POJO 방식의 프레임워크 일반적인 J2EE 프레임워크에 비해 구현을 위한 특정 인터페이스 구현 및 상속 필요 x → 기존의 라이브러리 등 지원 용이 \u0026 객체가 가벼움 제어 반전(IoC : Inversion of Control) 컨트롤의 제어권 : 사용자(x), 프레임워크(o) → 필요에 따라 스프링에서 사용자의 코드 호출 의존성 주입(DI : Dependency Injection) 각각의 계층이나 서비스들 간 의존성이 존재할 경우 → 프레임워크가 서로 연결시켜줌 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming) 여러 모듈에서 공통적으로 사용하는 기능 → 해당 기능을 분리하여 관리 가능 영속성 관련 서비스 지원 이미 완성도가 높은 데이터베이스 처리 라이브러리(iBATIS, 하이버네이트 등)와 연결 가능한 인터페이스 제공 높은 확장성 스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용 가능 → 수많은 라이브러리 지원 및 라이브러리 별도 분리 용이 ","date":"2023-01-02","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/:2:1","tags":["IoC","DI","AOP"],"title":"스프링이란?","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/"},{"categories":["spring"],"content":"스프링 부트 스프링의 편리한 사용을 위해 지원, 최근에는 기본으로 사용 특징 및 장점 단독 실행 가능한 스프링 애플리케이션 생성 용이 Tomcat 같은 웹 서버 내장 → 별도의 웹 서버 설치 x Starter 종속성 제공 → 빌드 구성 용이 스프링과 3rd party(외부) 라이브러리 자동 구성 프로덕션 준비 기능 제공 ex) 매트릭, 상태 확인, 외부 구성 등 관례에 의한 간결한 설정 ","date":"2023-01-02","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/:2:2","tags":["IoC","DI","AOP"],"title":"스프링이란?","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/"},{"categories":["spring"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8 ","date":"2023-01-02","objectID":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/:3:0","tags":["IoC","DI","AOP"],"title":"스프링이란?","uri":"/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80/"},{"categories":["spring"],"content":"EJB(Enterprise Java Beans)와 POJO(Plain Old Java Object) ","date":"2023-01-01","objectID":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/:1:0","tags":["EJB","POJO"],"title":"Spring의 등장 배경","uri":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/"},{"categories":["spring"],"content":"EJB(Enterprise Java Beans) 개념 기업환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델 애플리케이션의 업무 로직을 가지고 있는 서버 애플리케이션 Java EE의 자바 API 중 하나 특징 동시 접속자 수가 많은 가운데 안정적인 트랜잭션이 필요한 사이트 구축시 사용하는 컴포넌트 기술 ex) 공공기관, 기상청, 병무청, 금융, 보험, 포털사이트, 게임사이트, 기업 등.. JSP, Beans를 사용한 시스템보다 속도는 느리지만, 개발시 개발자에게 많은 자동화된 기능을 제공하여 안정적인 분산 시스템 구축 및 제공을 용이하게 함 기초 기술(JSP, BEANS, RMI, Servlet, Serialization, Transaction, Connection Pooling)을 알면 학습 및 사용이 쉬움 EJB 규약을 집중적으로 습득하면 쉽게 EJB 컴포넌트 개발 가능 장단점 장점 단점 많은 동시접속자에 대한 안정성 지원 객체지향적이지 않음 처리 메소드를 컨테이너가 트랜잭션 자동 처리 복잡한 프로그래밍 모델 빈즈의 상태를 메모리에서 사용 여부에 따라 자동으로 활성화/비활성화 실행하여 관리 특정 환경·기술에 종속적인 코드 다층 구조 시스템 구축 가능 컨테이너 안에서만 동작할 수 있는 객체 구조 라이프 사이클, 보안, Threading 등의 서비스 제공 부족한 개발생산성 및 이동성 ","date":"2023-01-01","objectID":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/:1:1","tags":["EJB","POJO"],"title":"Spring의 등장 배경","uri":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/"},{"categories":["spring"],"content":"POJO(Plain Old Java Object) 특정 자바 모델이나 기능, 프레임워크 등에 종속되지 않고, 클래스 패스(class path)를 필요로 하지 않는 일반적인 Java Object 중량 프레임워크들(Java EE 등…)을 사용하게 되면서 해당 프레임워크에 종속된 “무거운” 객체를 만들게 된 것에 반발해서 사용하게 됨 2000년 9월 마틴 파울러, 레베카 파슨, 조쉬 맥킨지 등에 의해 사용되기 시작함 ","date":"2023-01-01","objectID":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/:1:2","tags":["EJB","POJO"],"title":"Spring의 등장 배경","uri":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/"},{"categories":["spring"],"content":"Spring과 Hibernate의 등장 EJB의 단점들로 인해 대표적으로 2가지의 Open Source가 등장하게 되었다. ","date":"2023-01-01","objectID":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/:2:0","tags":["EJB","POJO"],"title":"Spring의 등장 배경","uri":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/"},{"categories":["spring"],"content":"Spring 2002년 출간된 로드 존슨의 『expert one-on-one J2EE Design and Development』이 Spring의 근간이 됨 EJB 컨테이너를 대체하게 됨 사실상 현재의 표준 기술 ","date":"2023-01-01","objectID":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/:2:1","tags":["EJB","POJO"],"title":"Spring의 등장 배경","uri":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/"},{"categories":["spring"],"content":"Hibernate 자바 언어를 위한 객체 관계 매핑 프레임워크 객체 지향 도메인 모델을 관계형 데이터베이스로 매핑하기 위한 프레임워크 제공 2001년 Gavin King과 시러스 테크놀로지스 출신 동료들이 EJB2 스타일의 엔티티 빈즈 이용을 대체할 목적으로 출발 기술력이 낮았던 EJB Entitiy Bean 기술을 대체 JPA(Java Persistence API)의 새로운 표준 정의 ","date":"2023-01-01","objectID":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/:2:2","tags":["EJB","POJO"],"title":"Spring의 등장 배경","uri":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/"},{"categories":["spring"],"content":"스프링의 역사 년도 버전 설명 2003년 스프링 프레임워크 1.0 XML 기반 2006년 스프링 프레임워크 2.0 XML 편의 기능 지원 2009년 스프링 프레임워크 3.0 자바 코드로 설정 2013년 스프링 프레임워크 4.0 자바8 2014년 스프링 부트 1.0 스프링 프레임워크의 설정 및 배포에 대한 어려움 해결하기 위해 등장 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 리액티브 프로그래밍(비동기) 지원 2022년 스프링 프레임워크 6.0, 스프링 부트 3.0 Java17과 Java19 지원, GraalVM 지원 ","date":"2023-01-01","objectID":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/:3:0","tags":["EJB","POJO"],"title":"Spring의 등장 배경","uri":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/"},{"categories":["spring"],"content":"참고 https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8 https://velog.io/@yu-jin-song/Spring-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81 ","date":"2023-01-01","objectID":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/:4:0","tags":["EJB","POJO"],"title":"Spring의 등장 배경","uri":"/spring%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD/"},{"categories":["system"],"content":"RAID (Redundant Array of Inexpensive/Independent Disk)는 저장장치(디스크) 여러 개를 묶어 고용량,고성능 저장 장치 한 개와 같은 효과를 얻기 위해 개발된 기법이다. RAID는 여러개의 하드디스크를 함께 사용하는 방식을 말한다. 속도를 위해 함께 사용 할 수도 있고 안정성을 위해 함께 사용 할 수도 있고 둘다를 추구할 수도 있다. ","date":"2022-12-13","objectID":"/raid/:0:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-0 속도 추구만을 위한 레이드 구성이다. 단순히 하드 여러개에 데이터를 분산시켜서 한꺼번에 입출력을 수행하는 것이다. 이를 스트라이핑(Disk striping) 기술이라고 한다. 예를 들면 1~10까지의 숫자를 저장하는데, 하드1에는 1 3 5 7 9, 하드2에는 2 4 6 8 10을 저장한다. 1~10까지의 숫자를 읽고자 한다면 두개의 하드에서 동시에 읽게 되므로 이론적으론 하드가 한개 있는 것 보다 두배의 속도로 읽을 수 있는 것이다. 하지만 데이터가 분산되어 저장되기 때문에 하나의 하드에만 문제가 생기더라도 나머지 하드들까지 사용 불능해 진다. ","date":"2022-12-13","objectID":"/raid/:1:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-1 안전성 추구만을 위한 레이드 구성이다. 2개의 하드가 있다면 2개의 하드에 완전 같은 데이터를 저장하는 것이다. 미러링이라고도 부른다. 이렇게 해 두면 속도는 하드 한개만 사용하는 것과 같고 용량은 두배나 들게 되지만, 하나의 하드에 문제가 생기면 나머지 하드를 엎어치면 되므로 안심하고 사용할 수 있다. ","date":"2022-12-13","objectID":"/raid/:2:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-2 디스크들은 스트라이핑 기술을 사용하여 구성하고, 오류정정을 위한 Hamming code ECC(Error Check \u0026 Correction) 정보를 사용한다. 최근 디스크드라이브들은 기본적으로 오류정정 기능을 가지고 있으므로 요즘은 거의 쓰이지 않는다. ","date":"2022-12-13","objectID":"/raid/:3:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-3 스트라이핑 기술을 사용하여 디스크들을 구성하고, 별도의 디스크에 패리티 정보를 저장한다. 입출력작업이 동시에 모든 디스크에 대해 이루어지므로, 입출력을 겹치게 할 수 없다. 대형 레코드가 많은 시스템에 이용된다. RAID-0과 거의 동일한데 패리티 디스크가 하나 더 달린 형태로 이해하면 된다. 읽기 속도는 동일하지만 쓰기는 패리티를 같이 처리하므로 속도가 좀 더 느리다. ","date":"2022-12-13","objectID":"/raid/:4:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-4 RAID-3보다 좀 더 개선된 형태라고 생각하면 된다. 블록 형태의 스트라이핑 기술을 사용하여 디스크를 구성한다. Note RAID-2, RAID-3, RAID-4는 모두 ECC를 사용한다는 특징이 있다. RAID-2는 비트 단위, RAID-3은 바이트 단위, RAID-4는 워드 단위로 패리티를 관리한다. 그러나 ECC를 위한 패리티를 특정 디스크에 저장 하는 것은 속도 문제 때문에 병목현상이 생기므로 2,3,4 모두 현재는 거의 쓰이지 않는다. ","date":"2022-12-13","objectID":"/raid/:5:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-5 안전성과 속도 모두 추가한, 가장 무난하여 가장 많이 사용되는 방식이다. 최소한 3개 이상의 하드가 있어야 구현이 가능하다. 패리티를 사용하지만 RAID-2,3,4와 다르게 여러 하드에 분산저장하여 병목 현상을 해결한다. 만약 하드가 4개가 있다면, 하드 하나를 4개로 나눈 뒤 하나를 패리티 디스크로 할당하고 자신을 제외한 나머지 3개 하드 중 한 하드의 페리티 정보를 저장한다. 이렇게 교차로 구성을 할 경우 하나의 하드에 장애가 생기더라도 나머지 3개 하드의 패리티 정보를 모아 복구할 수 있다. 3개이상이기만 하면 RAID-5를 구성할수 있다. 하드 사용량은 N개일 경우 N-1개의 용량을 사용할 수 있다. 안전성과 효율이 뛰어나다. 3개 구성 시에는 33.3%, 4개 구성하면 25%, 5개 구성하면 20%가 패리티 공간으로 사용된다. ","date":"2022-12-13","objectID":"/raid/:6:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-6 전체적인 구성은 RAID-5와 비슷하지만 디스크에 2차 패리티 구성을 포함함으로써 매우 높은 안전성을 자랑한다. RAID-5는 1개의 디스크 오류에만 대처가 가능하지만 RAID-6는 2개의 디스크 오류까지 대처가 가능하다. 2개의 패리티를 사용하므로 최소 4개의 디스크를 구성해야 한다. 공간 효율성이나 처리속도는 떨어지지만 안전성은 크게 증가된다. 4개 구성시에는 50%, 5개 구성하면 40%, 6개 구성하면 33.3%를 패리티 공간으로 사용한다. ","date":"2022-12-13","objectID":"/raid/:7:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-0+1 RAID0의 스트라이핑으로 구성된 하드들을 묶어 RAID-1미러링으로 구성하는 방법이다. ","date":"2022-12-13","objectID":"/raid/:8:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"RAID-1+0 RAID-0+1의 반대 개념이다. RAID-1로 구성된 하드들을 묶어 RAID-0으로 구성하는 방법이다. RAID-0+1보단 RAID-1+0이 더 많이 쓰인다. ","date":"2022-12-13","objectID":"/raid/:9:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["system"],"content":"참고 https://raisonde.tistory.com/entry/RAID0%EB%B6%80%ED%84%B0-RAID7%EA%B9%8C%EC%A7%80-%EB%AA%A8%EB%93%A0-RAID%EA%B5%AC%EC%84%B1%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90 ","date":"2022-12-13","objectID":"/raid/:10:0","tags":["RAID"],"title":"RAID","uri":"/raid/"},{"categories":["설계방법론"],"content":"객체지향 설계는 긴 세월과 수많은 시행착오를 거치며 5가지 원칙이 정리되었다. 이것은 객체지향 설계의 5원칙이라고 하며, 앞글자를 따서 SOLID라고 한다. ","date":"2022-12-10","objectID":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/:0:0","tags":["SOLID"],"title":"객체지향 설계 5원칙 SOLID","uri":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/"},{"categories":["설계방법론"],"content":"SRP (Single Responsibility Principle) - 단일 책임 원칙 SRP 원칙은 클래스가 하나의 기능만을 가지며, 어떤 변화에 의해 클래스를 변경해야하는 이유는 오직 하나 뿐이어야 한다는 원칙이다. SRP에서는 책임자체가 분명해지기 때문에, 변경에 의한 연쇄 작용에서 자유로워 질 수가 있다. ","date":"2022-12-10","objectID":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/:1:0","tags":["SOLID"],"title":"객체지향 설계 5원칙 SOLID","uri":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/"},{"categories":["설계방법론"],"content":"OCP (Open-Closed Principle) - 개방-폐쇄 원칙 OCP 원칙은 요구사항의 변경이나 추가사항이 발생해도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성요소를 쉽게 확장하여 재사용가능하도록 만들어야 한다는 원칙이다. 이 원칙을 지키기 위해서는 객체지향의 추상화와 다형성을 활용해야한다. ","date":"2022-12-10","objectID":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/:2:0","tags":["SOLID"],"title":"객체지향 설계 5원칙 SOLID","uri":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/"},{"categories":["설계방법론"],"content":"LSP(Liskov Substitution Principle) - 리스코프 치환 원칙 리스코프 치환 원칙은 서브타입은 기반 타입이 약속한 규약(접근제한자나 예외를 포함) 을 지켜야 한다는 원칙이다. 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다. 다형성과 확장성을 극대화 하기위해 인터페이스를 사용하는 방법도 있고, Composition을 이용할 수도 있다. ","date":"2022-12-10","objectID":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/:3:0","tags":["SOLID"],"title":"객체지향 설계 5원칙 SOLID","uri":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/"},{"categories":["설계방법론"],"content":"ISP(Interface Sergregation Principle) - 인터페이스 분리 원칙 인터페이스 분리 원칙을 적용하기 위해서는 가능한 최소한의 인터페이스만을 구현해야한다. 만약에 어떤 클래스를 이용하는 클라이언트가 여러 개고, 이들이 클래스의 특정 부분만 이용하면, 여러 인터페이스로 분리해주고 클라이언트가 필요한 기능만 전달하게 코드를 짜야한다. SRP 가 클래스의 단일 책임 원칙이라면, ISP는 인터페이스의 단일 책임 원칙이다. ","date":"2022-12-10","objectID":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/:4:0","tags":["SOLID"],"title":"객체지향 설계 5원칙 SOLID","uri":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/"},{"categories":["설계방법론"],"content":"DIP(Dependency Inversion Principle) - 의존성 역전 원칙 DIP는 의존을 할 때 구체 클래스에 의존하지 않고 인터페이스를 의존하여 영향을 받지 않게 하는 원칙이다. 의존성 역전 원칙은 하위 모델의 변경이 상위 모델의 변경을 요구하는 위계관계를 끊으면서 적용된다. 실제 사용관계는 그대로 이지만 추상화를 매개로 하여 메시지를 주고 받으면서 관계를 느슨하게 해준다. 스프링에서는 DI를 이용하여 클라이언트 코드 변경 없이 기능을 확장할 수 있다. ","date":"2022-12-10","objectID":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/:5:0","tags":["SOLID"],"title":"객체지향 설계 5원칙 SOLID","uri":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/"},{"categories":["설계방법론"],"content":"참고 https://sjh836.tistory.com/159 ","date":"2022-12-10","objectID":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/:6:0","tags":["SOLID"],"title":"객체지향 설계 5원칙 SOLID","uri":"/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-solid/"},{"categories":["java"],"content":"RuntimeException : Unchecked Exception 프로그램 실행 도중 발생하는 예외로, 프로그래머의 잘못으로 발생한다고 볼 수 있다. 배열의 범위를 넘어선 접근, Null 객채에 대한 접근, 잘못된 형 변환 등을 예로 들 수가 있다, 이러한 예외는 처리에 있어서 강제성을 띄지 않는다. ","date":"2022-10-17","objectID":"/runtimeexception-ioexception/:1:0","tags":["RuntimeException","IOException"],"title":"RuntimeException \u0026 IOException","uri":"/runtimeexception-ioexception/"},{"categories":["java"],"content":"IOException : Checked Exception 런타임 예외는 언제 에러가 발생하는지 알 수 없기 때문에 처리를 하지 않아도 되지만, IOException은 예외가 발생할 시점과 종류를 알 수 있기 때문에 반드시 처리를 해주어야 하는 강제성을 띄게 된다. ","date":"2022-10-17","objectID":"/runtimeexception-ioexception/:2:0","tags":["RuntimeException","IOException"],"title":"RuntimeException \u0026 IOException","uri":"/runtimeexception-ioexception/"},{"categories":["java"],"content":"참고 https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true\u0026blogId=bestheroz\u0026logNo=95526984 ","date":"2022-10-17","objectID":"/runtimeexception-ioexception/:3:0","tags":["RuntimeException","IOException"],"title":"RuntimeException \u0026 IOException","uri":"/runtimeexception-ioexception/"},{"categories":["java"],"content":"NestedRuntimeException RuntimeException의 root cause를 다루기 쉽게 래핑한 예외 클래스 내부적으로는 NestedExceptionUtils 라는 유틸리티 클래스를 이용한다. ","date":"2022-10-15","objectID":"/restclientexception/:1:0","tags":["NestedRuntimeException","RestClientException"],"title":"RestClientException","uri":"/restclientexception/"},{"categories":["java"],"content":"RestClientException 클라이언트 사이드의 HTTP 에러를 만났을 때 던져지는 기본 예외 클래스 RestClientResponseException 실제 HTTP 응답 데이터를 포함하고 있는 예외클래스들의 공통 기반 클래스 int 타입의 rawStatusCode를 가지고 있다. int rawStatusCode String statusText byte[] responseBody: getResponseBodyAsString() 메서드로 읽어올 수 있다. HttpHeaders responseHeaders String responseCharset HttpStatusCodeException HttpStatus (enum)를 기반으로 하여 만든 추상 클래스 getStatusCode() 메서드를 통해 HttpStatus를 읽어올 수 있다. 직접쓰기 보다는 상속받은 아래 두 클래스를 사용한다. HttpClientErrorException : 4xx 대 응답을 받았을 때 던져지는 예외 HttpServerErrorException: 5xx 대 응답을 받았을 때 던져지는 예외 UnknownHttpStatusCodeException HTTP 응답 코드가 허용 범위를 넘어섰을 경우 던져진다. 499 (Nginx) … ResourceAccessException I/O를 하는 도중 에러가 발생했을 때 던져진다. ","date":"2022-10-15","objectID":"/restclientexception/:1:1","tags":["NestedRuntimeException","RestClientException"],"title":"RestClientException","uri":"/restclientexception/"},{"categories":["java"],"content":"참고 https://namocom.tistory.com/712 ","date":"2022-10-15","objectID":"/restclientexception/:2:0","tags":["NestedRuntimeException","RestClientException"],"title":"RestClientException","uri":"/restclientexception/"},{"categories":["java"],"content":"생성자 자동 생성 Lombok을 사용하면 생성자를 자동으로 생성할 수 있다. @NoArgsConstructor 어노테이션 : 파라미터가 없는 기본 생성자를 생성해준다. @AllArgsConstructor 어노테이션 : 모든 필드 값을 파라미터로 받는 생성자를 만들어준다. @RequiredArgsConstructor 어노테이션 : final이나 @NonNull인 필드 값만 파라미터로 받는 생성자를 만들어준다. 주로 의존성 주입(Dependency Injection) 편의성을 위해서 사용된다. @RequiredArgsConstructor 어노테이션 @RequiredArgsConstructor 어노테이션은 스프링 의존성 주입의 특징 중 한가지를 이용하는데 이는 다음과 같다. 어떠한 빈(Bean)에 생성자가 오직 하나만 있고, 생성자의 파라미터 타입이 빈으로 등록 가능한 존재라면 이 빈은 @Autowired 어노테이션 없이도 의존성 주입이 가능하다. ","date":"2022-10-10","objectID":"/lombok-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/:1:0","tags":["constructor"],"title":"Lombok 어노테이션","uri":"/lombok-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/"},{"categories":["java"],"content":"참고 https://www.daleseo.com/lombok-popular-annotations/ https://medium.com/webeveloper/requiredargsconstructor-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-dependency-injection-4f1b0ac33561 ","date":"2022-10-10","objectID":"/lombok-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/:2:0","tags":["constructor"],"title":"Lombok 어노테이션","uri":"/lombok-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/"},{"categories":["etc"],"content":"API (Application Programming Interface), 라이브러리 (Library), 프레임워크 (Framework)는 모두 소프트웨어 개발에서 사용되는 용어이다. ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:0:0","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"API API는 두 개 이상의 소프트웨어 컴포넌트 사이에서 상호 작용할 수 있도록 정의된 인터페이스를 말한다. 이를 사용하여 다른 소프트웨어 개발자들이 특정 서비스 또는 기능을 사용할 수 있다. ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:1:0","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"특징 다른 프로그램이나 서비스와 연결해 주는 다리 역할 API를 조합해서 원하는 프로그램을 만들 수도 있다. ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:1:1","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"예시 Twitter API: 트위터에서 제공하는 API Google Maps API: 구글에서 제공하는 지도 API YouTube API: 유튜브에서 제공하는 API OpenWeather API: 날씨 정보 API GitHub API: 깃허브에서 제공하는 API Kakao API: 카카오에서 제공하는 API Stripe API: 결제 API Twilio API: SMS 및 음성 API AWS API Gateway: 아마존 웹 서비스에서 제공하는 API 관리 서비스 Google Cloud Vision API: 구글에서 제공하는 이미지 분석 API ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:1:2","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"라이브러리 라이브러리는 개발자들이 자주 사용하는 코드 집합이다. 라이브러리는 여러 기능을 제공하며, 이를 사용하여 개발자들은 복잡한 기능을 더 쉽게 구현할 수 있다. ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:2:0","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"특징 개발하는데 필요한 것들을 모아 둔 일종의 저장소 필요할 때 호출해서 사용한다. ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:2:1","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"예시 Lodash: 자바스크립트 유틸리티 라이브러리 jQuery: 자바스크립트 DOM 조작 라이브러리 React Transition Group: React 애니메이션 라이브러리 Moment.js: 자바스크립트 날짜 라이브러리 Chart.js: 자바스크립트 차트 라이브러리 Axios: 자바스크립트 HTTP 클라이언트 라이브러리 NumPy: 파이썬 수치 계산 라이브러리 Pandas: 파이썬 데이터 분석 라이브러리 Matplotlib: 파이썬 시각화 라이브러리 BeautifulSoup: 파이썬 웹 스크래핑 라이브러리 ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:2:2","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"프레임워크 프레임워크는 개발할 때에 빈번히 쓰여지는 범용 기능을 한꺼번에 제공해 개발 효율의 향상을 목표하는 소프트웨어 환경이다. 프레임워크는 일련의 규칙과 구조를 정의하고, 개발자가 애플리케이션을 작성할 때 이러한 규칙과 구조를 따르도록 한다. 프레임워크는 보통 여러 컴포넌트와 라이브러리를 포함하며, 개발자가 특정 기능을 구현하기 위해 이를 조합하여 사용한다. ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:3:0","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"특징 공통적인 개발환경을 제공한다. 개발할 수 있는 범위가 정해져 있다. ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:3:1","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"예시 React: 자바스크립트 UI 프레임워크 (공식사이트에서는 라이브러리 라고 말함) Angular: 자바스크립트 프레임워크 Vue.js: 자바스크립트 프론트엔드 프레임워크 Django: 파이썬 백엔드 웹 프레임워크 Ruby on Rails: 루비 웹 프레임워크 Spring: 자바 백엔드 프레임워크 Express.js: Node.js 웹 프레임워크 Flask: 파이썬 백엔드 웹 프레임워크 Laravel: PHP 웹 프레임워크 ASP.NET: 마이크로소프트 웹 프레임워크 ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:3:2","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"참고 https://www.youtube.com/watch?v=_j4u4ftWwhQ https://velog.io/@bcl0206/API-vs-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%92%80%EB%A6%AC%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%AF%B8%EC%8A%A4%ED%84%B0%EB%A6%AC%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC ","date":"2022-10-01","objectID":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/:4:0","tags":["프레임워크","라이브러리","API"],"title":"프레임워크, 라이브러리,  API","uri":"/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-api/"},{"categories":["etc"],"content":"암호는 중요한 정보를읽기 어려운 값으로 변환하여 제 3자가 볼수 있도록 하는 기술이다. ","date":"2022-09-01","objectID":"/%EC%95%94%ED%98%B8/:0:0","tags":["보안"],"title":"암호","uri":"/%EC%95%94%ED%98%B8/"},{"categories":["etc"],"content":"암호의 특성 기밀성 : 허가되지 않은 사용자는 암호화된 데이터의 원본을 볼 수 없는 성질 무결성 : 허락되지 않은 사용자가 암호화 데이터를 함부로 변조를 불가능하게 하거나 변조가 된 후에 데이터를 검증할 수 있는 성질 인증 : 정상적인 암호화 복호화 과정에서 정체성을 식별 부인 방지 : 정보를 보낸 사람이 정보를 보냈다는 사실을 부인하지 못하게 하는 성질 ","date":"2022-09-01","objectID":"/%EC%95%94%ED%98%B8/:1:0","tags":["보안"],"title":"암호","uri":"/%EC%95%94%ED%98%B8/"},{"categories":["etc"],"content":"암호 알고리즘 RSA (Ron Rivest, Adi Shamir, Leonard Adleman) 공개키 암호시스템의 하나로, 암호화뿐만 아니라 전자서명이 가능한 최초의 알고리즘 공개키(Public key), 개인키(Private key)가 존재 대칭키 알고리즘에 비해 느림 AES (Advenced Encryption Standard) 암호화와 복호화 과정에서 동일한 키를 사용하는 대칭키 알고리즘 2001년 미국 표준 기술 연구소(NIST)에 의해 제정된 암호화 방식 AES 표준은 여러 Rijindael 알고리즘 중 블록 크기가 128비트인 알고리즘 ECB (Electronic Code Block) 가장 기본적인 타입 항상 같은 결과가 나오기 때문에 암호화 키 역추적 가능 CBC (Ciper Block Chaining) ECB의 단점을 보완 암호화 키에 IV(Initial Vector)를 추가해서 항상 같은 결과가 나오는 문제를 해결 암호화 병렬처리 불가 GCM (Galois/counter mode) CBC의 취약점을 보완 데이터 값의 Hash가 암호문에 포함 -\u003e 데이터 복호화 시 변조 확인 가능 암호화 병렬처리 가능 ","date":"2022-09-01","objectID":"/%EC%95%94%ED%98%B8/:2:0","tags":["보안"],"title":"암호","uri":"/%EC%95%94%ED%98%B8/"},{"categories":["etc"],"content":"참고 https://www.youtube.com/watch?v=itehKMMBVjc https://velog.io/@excellent/AES-GCM-%EC%95%94%ED%98%B8%ED%99%94 ","date":"2022-09-01","objectID":"/%EC%95%94%ED%98%B8/:3:0","tags":["보안"],"title":"암호","uri":"/%EC%95%94%ED%98%B8/"},{"categories":["etc"],"content":"해시(hash)란 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑(mapping)한 값이다. 복호화를 위해 사용하지 않으며, 암호화보다 연산이 빠르다는 특징이 있다. ","date":"2022-08-31","objectID":"/%ED%95%B4%EC%8B%9C/:0:0","tags":["hash"],"title":"해시","uri":"/%ED%95%B4%EC%8B%9C/"},{"categories":["etc"],"content":"해시 알고리즘 MD5 (Message Digest) 128비트 암호화 해시함수 원본 그대로인지를 확인하는 무결성 검사 등에 사용 해킹에 취약하므로 SHA를 권장 임의의 길이를 입력받아 128비트 고정길이 값을 출력 SHA (Secure Hash Algorithm) 서로 관련된 암호학적 해시 함수들의 모음 SHA-0, SHA-1, SHA-2(224, 256, 384, 512) 존재 SHA-0, SHA-1에 대한 공격 발견 SHA-256은 256비트로 구성되며 64자리 문자열을 반환 ","date":"2022-08-31","objectID":"/%ED%95%B4%EC%8B%9C/:1:0","tags":["hash"],"title":"해시","uri":"/%ED%95%B4%EC%8B%9C/"},{"categories":["etc"],"content":"참고 https://velog.io/@excellent/AES-GCM-%EC%95%94%ED%98%B8%ED%99%94 ","date":"2022-08-31","objectID":"/%ED%95%B4%EC%8B%9C/:2:0","tags":["hash"],"title":"해시","uri":"/%ED%95%B4%EC%8B%9C/"},{"categories":["system"],"content":"프로세스는 독립적으로 실행된다. 즉, 독립 되어있다는 것은 다른 프로세스에게 영향을 받지 않는다고 말할 수 있다. (스레드는 프로세스 안에서 자원을 공유하므로 영향을 받는다) 이런 독립적 구조를 가진 프로세스 간의 통신을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 IPC 통신이다. 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다. 커널 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다. ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:0:0","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["system"],"content":"IPC 종류 ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:1:0","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["system"],"content":"익명 PIPE 파이프는 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다. 한쪽 방향으로만 통신이 가능한 반이중 통신이라고도 부른다. 따라서 양쪽으로 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야 한다. 매우 간단하게 사용할 수 있는 장점이 있고, 단순한 데이터 흐름을 가질 땐 파이프를 사용하는 것이 효율적이다. 단점으로는 전이중 통신을 위해 2개를 만들어야 할 때는 구현이 복잡해지게 된다. ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:1:1","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["system"],"content":"Named PIPE(FIFO) 익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용한다. (부모-자식 프로세스 간 통신처럼) Named 파이프는 전혀 모르는 상태의 프로세스들 사이 통신에 사용한다. 즉, 익명 파이프의 확장된 상태로 부모 프로세스와 무관한 다른 프로세스도 통신이 가능한 것 (통신을 위해 이름있는 파일을 사용) 하지만, Named 파이프 역시 읽기/쓰기 동시에 불가능함. 따라서 전이중 통신을 위해서는 익명 파이프처럼 2개를 만들어야 가능 ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:1:2","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["system"],"content":"Message Queue 입출력 방식은 Named 파이프와 동일하다. 다른 점은 메시지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간이라는 것이다. 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다. ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:1:3","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["system"],"content":"공유 메모리 파이프, 메시지 큐가 통신을 이용한 설비라면, 공유 메모리는 데이터 자체를 공유하도록 지원하는 설비이다. 프로세스의 메모리 영역은 독립적으로 가지며 다른 프로세스가 접근하지 못하도록 반드시 보호되야한다. 하지만 다른 프로세스가 데이터를 사용하도록 해야하는 상황도 필요할 것이다. 파이프를 이용해 통신을 통해 데이터 전달도 가능하지만, 스레드처럼 메모리를 공유하도록 해준다면 더욱 편할 것이다. 공유 메모리는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용해준다. 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다. 따라서 중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동한다. ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:1:4","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["system"],"content":"메모리 맵 공유 메모리처럼 메모리를 공유해준다. 메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식이다. (즉 공유 매개체가 파일+메모리) 주로 파일로 대용량 데이터를 공유해야 할 때 사용한다. ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:1:5","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["system"],"content":"소켓 네트워크 소켓 통신을 통해 데이터를 공유한다. 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다. ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:1:6","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["system"],"content":"참고 https://gyoogle.dev/blog/computer-science/operating-system/IPC.html ","date":"2022-06-07","objectID":"/ipcinter-process-communication/:2:0","tags":["IPC"],"title":"IPC(Inter Process Communication)","uri":"/ipcinter-process-communication/"},{"categories":["web"],"content":"CSRF (Cross Site Request Forgery) 웹 어플리케이션 취약점 중 하나로, 인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위 (modify, delete, register 등)를 특정한 웹사이트에 request하도록 만드는 공격을 말한다. 주로 해커들이 많이 이용하는 것으로, 유저의 권한을 도용해 중요한 기능을 실행하도록 한다. 우리가 실생활에서 CSRF 공격을 볼 수 있는 건, 해커가 사용자의 SNS 계정으로 광고성 글을 올리는 것이다. 정확히 말하면, CSRF는 해커가 사용자 컴퓨터를 감염시거나 서버를 해킹해서 공격하는 것이 아니다. CSRF 공격은 아래와 같은 조건이 만족할 때 실행된다. 사용자가 해커가 만든 피싱 사이트에 접속한 경우 위조 요청을 전송하는 서비스에 사용자가 로그인을 한 상황 보통 자동 로그인을 해둔 경우에 이런 피싱 사이트에 접속하게 되면서 피해를 입는 경우가 많다. 또한, 해커가 XSS 공격을 성공시킨 사이트라면, 피싱 사이트가 아니더라도 CSRF 공격이 이루어질 수 있다. ","date":"2022-05-28","objectID":"/csrf-xss/:1:0","tags":["CSRF","XSS"],"title":"CSRF, XSS","uri":"/csrf-xss/"},{"categories":["web"],"content":"대응 기법 리퍼러(Refferer) 검증 백엔드 단에서 Refferer 검증을 통해 승인된 도메인으로 요청시에만 처리하도록 한다. Security Token 사용 사용자의 세션에 임의의 난수 값을 저장하고, 사용자의 요청시 해당 값을 포함하여 전송시킨다. 백엔드 단에서는 요청을 받을 때 세션에 저장된 토큰값과 요청 파라미터로 전달받는 토큰 값이 일치하는 지 검증 과정을 거치는 방법이다. 하지만, XSS에 취약점이 있다면 공격을 받을 수도 있다. ","date":"2022-05-28","objectID":"/csrf-xss/:1:1","tags":["CSRF","XSS"],"title":"CSRF, XSS","uri":"/csrf-xss/"},{"categories":["web"],"content":"XSS (Cross Site Scription) CSRF와 같이 웹 어플리케이션 취약점 중 하나로, 관리자가 아닌 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입하는 공격 기법을 말한다. 악의적으로 스크립트를 삽입하여 이를 열람한 사용자의 쿠키가 해커에게 전송시키며, 이 탈취한 쿠키를 통해 세션 하이재킹 공격을 한다. 해커는 세션ID를 가진 쿠키로 사용자의 계정에 로그인이 가능해지는 것이다. 공격 종류로는 지속성, 반사형, DOM 기반 XSS 등이 있다. 지속성 : 말 그대로 지속적으로 피해를 입히는 유형으로, XSS 취약점이 존재하는 웹 어플리케이션에 악성 스크립트를 삽입하여 열람한 사용자의 쿠키를 탈취하거나 리다이렉션 시키는 공격을 한다. 이때 삽입된 스크립트를 데이터베이스에 저장시켜 지속적으로 공격을 하기 때문에 Persistent XSS라고 불린다. 반사형 : 사용자에게 입력 받은 값을 서버에서 되돌려 주는 곳에서 발생한다. 공격자는 악의 스크립트와 함께 URL을 사용자에게 누르도록 유도하고, 누른 사용자는 이 스크립트가 실행되어 공격을 당하게 되는 유형이다. DOM 기반 : 악성 스크립트가 포함된 URL을 사용자가 요청하게 되면서 브라우저를 해석하는 단계에서 발생하는 공격이다. 이 스크립트로 인해 클라이언트 측 코드가 원래 의도와 다르게 실행된다. 이는 다른 XSS 공격과는 달리 서버 측에서 탐지가 어렵다. ","date":"2022-05-28","objectID":"/csrf-xss/:2:0","tags":["CSRF","XSS"],"title":"CSRF, XSS","uri":"/csrf-xss/"},{"categories":["web"],"content":"대응 기법 입출력 값 검증 XSS Cheat Sheet에 대한 필터 목록을 만들어 모든 Cheat Sheet에 대한 대응을 가능하도록 사전에 대비한다. XSS 필터링을 적용 후 스크립트가 실행되는지 직접 테스트 과정을 거쳐볼 수도 있다, XSS 방어 라이브러리, 확장앱 Anti XSS 라이브러리를 제공해주는 회사들이 많다. 이 라이브러리는 서버단에서 추가하며, 사용자들은 각자 브라우저에서 악성 스크립트가 실행되지 않도록 확장앱을 설치하여 방어할 수 있다. 웹 방화벽 웹 방화벽은 웹 공격에 특화된 것으로, 다양한 Injection을 한꺼번에 방어할 수 있는 장점이 있다. CORS, SOP 설정 CORS(Cross-Origin Resource Sharing), SOP(Same-Origin-Policy)를 통해 리소스의 Source를 제한 하는것이 효과적인 방어 방법이 될 수 있다. 웹 서비스상 취약한 벡터에 공격 스크립트를 삽입 할 경우, 치명적인 공격을 하기 위해 스크립트를 작성하면 입력값 제한이나 기타 요인 때문에 공격 성공이 어렵다. 그러나 공격자의 서버에 위치한 스크립트를 불러 올 수 있다면 이는 상대적으로 쉬워진다. 그렇기 떄문에 CORS, SOP를 활용 하여 사전에 지정된 도메인이나 범위가 아니라면 리소스를 가져올 수 없게 제한해야 한다. ","date":"2022-05-28","objectID":"/csrf-xss/:2:1","tags":["CSRF","XSS"],"title":"CSRF, XSS","uri":"/csrf-xss/"},{"categories":["web"],"content":"참고 https://gyoogle.dev/blog/web-knowledge/CSRF%20\u0026%20XSS.html ","date":"2022-05-28","objectID":"/csrf-xss/:3:0","tags":["CSRF","XSS"],"title":"CSRF, XSS","uri":"/csrf-xss/"},{"categories":["web"],"content":"쿠키 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다. 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다. 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다. 클라이언트에 300개까지 쿠키저장 가능하며, 하나의 도메인당 20개의 값만 가질 수 있다. 하나의 쿠키값은 4KB까지 저장한다. Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다. ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:1:0","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"쿠키와 보안 문제 쿠키를 사용해서 로그인Id를 전달해서 로그인을 유지할 수 있다. 그런데 여기에는 심각한 보안 문제가 있다. 보안 문제 쿠키 값은 임의로 변경할 수 있다. 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다. 쿠키에 보관된 정보는 훔쳐갈 수 있다. 쿠키 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다. 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다. 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다. 대안 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식한다. 그리고 서버에서 토큰을 관리한다. 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다. 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분) 유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거한다. ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:1:1","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"세션 세션은 쿠키에 기반하고 있지만, 사용자 정보를 서버 측에서 관리한다. 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다. 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능 하다. 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다. 즉 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 된다. 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션ID이다. 동작 방식은 다음과 같다. 사용자가 loginId, password 정보를 전달하면 서버에서 해당 사용자가 맞는지 확인한다. 생성된 세션 ID와 세션에 보관할 값을 서버의 세션 저장소에 보관한다. 서버는 클라이언트에 세션ID 만 쿠키에 담아서 전달한다. 클라이언트는 쿠키 저장소에 쿠키를 보관한다. 클라이언트는 요청시 쿠키를 전달한다. 서버에서는 클라이언트가 전달한 쿠키 정보로 세션 저장소를 조회해서 로그인시 보관한 세션 정보를 사용한다. ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:2:0","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"세션과 보안 문제 세션을 사용해서 서버에서 중요한 정보를 관리하게 되었다. 덕분에 다음과 같은 보안 문제들을 해결할 수 있다. 쿠키는 값을 변조 가능하지만, 세션은 예상 불가능한 복잡한 세션Id를 사용한다. 쿠키에 보관하는 정보는 클라이언트 해킹시 털릴 가능성이 있다. 세션Id가 털려도 여기에는 중요한 정보가 없다. 쿠키 탈취 후 사용 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 세션의 만료시간을 짧게(예: 30분) 유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 세션을 강제로 제거하면 된다. ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:2:1","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"쿠키 vs 세션 Cookie Session 저장위치 Client Server 저장형식 Text Object 만료시점 쿠키 저장시 설정 (설정 없으면 브라우저 종료 시) 정확한 시점 모름 리소스 클라이언트의 리소스 서버의 리소스 용량제한 한 도메인 당 20개, 한 쿠키당 4KB 제한없음 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:0","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"저장 위치 쿠키 : 클라이언트의 웹 브라우저가 지정하는 메모리 or 하드디스크 세션 : 서버의 메모리에 저장 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:1","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"만료 시점 쿠키 : 저장할 때 expires 속성을 정의해 무효화시키면 삭제될 날짜 정할 수 있음 세션 : 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화 되기 때문에 정확한 시점 알 수 없음 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:2","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"리소스 쿠키 : 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원 사용하지 않음 세션 : 세션은 서버에 저장되고, 서버 메모리로 로딩 되기 때문에 세션이 생길 때마다 리소스를 차지함 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:3","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"용량 제한 쿠키 : 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 걸 막고자 한 도메인당 20개, 하나의 쿠키 당 4KB로 제한해 둠 세션 : 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한 없음 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:4","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"참고 https://interconnection.tistory.com/74 https://gyoogle.dev/blog/web-knowledge/Cookie%20\u0026%20Session.html https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:4:0","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["etc"],"content":"1. JPG - Joint Photographic Experts Group(JPEG) JPG와 JPEG에 대해서 간단히 설명하겠다. JPG와 JPEG의 관계를 알기 위해서는 지금은 거의 사용되지 않은 도스(DOS)를 조금 살펴보아야 한다. 도스는 윈도우가 보편화되기 전에 주로 사용되던 프로그램으로 일종의 운영체제이다. 도스에서는 파일명을 최대 8자, 확장자를 최대 3자까지 밖에 사용할 수 없어 기존의 4자리로 된 JPEG를 줄여 JPG로 사용한 게 시초가 되었다. 하지만, 윈도우 macOS 등 다양한 운영체제가 개발되면서 파일명과 확장자를 포함하여 최대 255자까지 사용할 수 있게 되면서, JPEG를 굳이 JPG로 표기할 필요가 없게 되었다. JPG 파일에 대해서 알아보겠다. JPG 파일은 기본적으로 raster-based 이미지(웹, 인쇄 용도로 사용되는 이미지)이다. JPG 형식은 디지털 카메라 파일의 기본 형식인데, 압축과 대부분의 브라우저를 지원하는 이유로 웹에서 널리 사용되고 있는 형식이다. 이런 파일 형식은 파일의 크기가 작고, 품질 손실이 거의 없는 사진 파일을 저장하는데 가장 적합하다. JPG는 손실 압축을 사용하므로 다시 저장할 때마다 품질이 저하된다. JPG 파일을 올바르게 사용하기 위해서는 올바른 크기와 해상도로 저장해야 한다. 그렇지 않으면 흔히 ‘깨져 보이는’ 픽셀화 또는 이미지가 늘어져 보이기 때문이다. 이런 이유로 소셜 미디어 플랫폼 등에서는 이미지의 크기를 사용하여 해상도를 제어한다. 손실 압축 손실 압축이란, 이미지를 저장할 때 데이터를 없애 더 작은 사이즈로 압축하는 방식을 이른다. 그 결과 더 낮은 해상도를 갖게 되지만, 파일 크기와 다운로드 속도가 필수적인 온라인에서는 이상적이다. ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:1:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"2. PNG - Portable Network Graphic PNG는 웹 사용 표준이다. 픽셀 기반이며, 이미지의 크기를 키울 경우, 픽셀화가 일어난다. JPG와 비슷하게, 최종 사용에 적합한 크기로 내보내야한다. 하지만 JPG와 다르게, PNG 파일은 투명한 배경을 지원하며 손실없는 압축으로 그래픽(사진 아님)용 JPG보다 전반적으로 고품질의 이미지를 유지할 수 있다. 즉, 파일을 저장해도 품질이 저하되지 않는다. PNG는 로고, 아이콘, 간단한 일러스트처럼 선명하게 유지해야 하는 색상 간 전환과 색상이 적은 그래픽에 사용하는 것이 더 좋다. 또한, 웹 사이트와 소셜 미디어에서 PNG를 사용하여 디지털 및 모바일 디스플레이에서 더 선명한 이미지를 만들 수 있다. 이런 이유로 고품질을 유지하면서 파일 크기를 최대한 낮게 설정하여 PNG 파일을 사용하는 것은 웹 최적화에 유리하다. 참고로 PNG-24는 PNG-8보다 선명하지만 더 많은 색상으로 이미지를 저장하기 때문에 파일 크기가 훨씬 커질 수 있으므로 사용에 주의가 필요하다. ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:2:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"3. GIF - Graphics Interchange Format GIF는 모든 주요 웹 브라우저와 대부분의 이미지 편집기에서 지원되는 유일한 애니메이션 이미지 형식이다. GIF는 투명도와 애니메이션을 지원하고 파일을 줄이기 위해서 높은 압축률로 압축될 수 있다. GIF는 색상이 거의 필요없는 애니메이션 그래픽에서 자주 사용되는 무손실 raster 형식이다. GIF는 오직 256가지 색만 지원하기 때문에, 사진을 저장하는 경우는 권장하지 않는다. 다른 애니메이션 이미지 파일 형식으로 APNG(Animated Portable Network Graphics), WebP, MNG(Multiple-Image Network Graphics), FLIF(Free Lossless Image Format) 등이 있지만, 널리 사용되지는 않는다. ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:3:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"4. SVG - Scalable Vector Graphic SVG는 World Wide Web Consortium(W3C)에서 개발한 2차원 그래픽을 설명하기 위한 백터 기반의 확장 가능한 마크업 언어(XML)이다. SVG 파일 형식의 가장 큰 특징은 다른 파일 형식과 다르게 픽셀 형식을 사용하지 않는다는 것이다. 픽셀 형식을 사용하지 않아서, 이미지의 크기를 키우는 경우 이미지가 꺠져 흐릿하게 보이는 픽셀화가 일어나지 않는다. SVG 파일은 PNG 및 JPG에 비해 가장 선명한 품질의 그래픽을 제공하기 때문에 로고, 아이콘 및 간단한 일러스트레이션에 적합하다. ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:4:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-08-17-various-image-types/ ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:5:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"메시지 큐(Message Queue)는 프로세스 또는 프로그램 간에 데이터를 교환할 때 사용하는 통신 방법 중에 하나로, 메시지 지향 미들웨어(Message Oriented Middleware:MOM)를 구현한 시스템을 의미한다. 메시지 지향 미들웨어란 비동기 메시지를 사용하는 응용 프로그램들 사이에서 데이터를 송수신하는 것을 의미한다. 여기서 메시지란 요청, 응답, 오류 메시지 혹은 단순한 정보 등의 작은 데이터가 될 수 있다. 메시지 큐는 메시지를 임시로 저장하는 간단한 버퍼라고 생각하면 된다. 메시지를 전송 및 수신하기 위해 중간에 메시지 큐를 두는 것이다. 메시지 전송 시 생산자(Producer)로 취급되는 컴포넌트가 메시지를 메시지 큐에 추가한다. 해당 메시지는 소비자(Consumer)로 취급되는 또 다른 컴포넌트가 메시지를 검색하고 이를 사용해 어떤 작업을 수행할 때까지 메시지 큐에 저장된다. 각 메시지는 하나의 소비자에 의해 한 번만 처리될 수 있는데, 이러한 이유로 메시지 큐를 이용하는 방식을 일대일 통신이라고 부른다. 메시지 큐는 소비자(Consumer)가 실제로 메시지를 어느 시점에 가져가서 처리하는 지는 보장하지 않는다. 언젠가는 큐에 넣어둔 메시지가 소비되어 처리될 것이라고 믿는 것이다. 이러한 비동기적 특성 때문에 메시지 큐는 실패하면 치명적인 핵심 작업보다는 어플리케이션의 부가적인 기능에 사용하는 것이 적합하다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:0:0","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"메시지 큐를 사용하는 경우 ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:1:0","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"이메일 전송 어떤 웹 사이트의 비밀번호를 잊어버려서 이메일을 통해 임시 비밀번호를 받거나, 새로운 회원가입을 위한 인증 코드를 받아본 경험이 있을 것이다. 우리는 이러한 상황들에서 이메일이 즉각적으로 수신되기를 기대하지는 않는다. 아무리 성격이 급한 사람이라도 몇 분 안에 오겠거니 생각할 것이다. 어느 정도의 응답 지연이 허용되며, 어플리케이션의 핵심 기능은 아닌 경우이므로 메시지 큐는 이런 경우 도움이 될 수 있다. 비밀번호 재설정을 위해 이메일을 발급하는 서비스, 회원가입을 위해 이메일을 발급하는 서비스 등은 메시지(이메일)를 큐에 넣을 수 있다. 이메일 전송 전용 서비스는 이메일이 어느 서비스로부터 생산되었는지와는 관계없이, 메시지 큐의 메시지를 하나씩 소비하고, 그저 이메일이 전송되어야 할 곳으로 이메일을 전송한다. 이와 같은 접근 방식은 메시지 큐에 들어오는 메시지 수가 너무 많아지는 경우 이메일 전송 전용 서비스 인스턴스를 더 둠으로써 확장할 수 있으므로 확장성이 뛰어나다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:1:1","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"블로그 포스팅 모든 블로그 사용자가 웹에 최적화되어 있거나, 용량이 작은 이미지만 업로드하진 않을 것이다. 블로그 사용자가 게시글에 업로드한 이미지의 용량이 매우 큰 경우를 생각해보자. 블로그 서비스의 응답 시간을 저해하지 않으면서 사용자들에게 유연성을 제공하는 방법으로, 사용자가 업로드한 모든 이미지를 게시 과정에서 즉각 처리하는 것이 아닌, 사후처리하며 최적화하는 방법이 있다. 사용자 경험에 약간의 영향을 미칠 수는 있지만, 최적화는 응용 프로그램에서 가장 중요한 것은 아니며 작업을 즉시 수행할 필요도 없다. 메시지 큐는 이러한 상황에서도 사용될 수 있다. 사용자가 고용량의 이미지가 포함된 블로그 포스팅을 한다. 이미지는 저장소에 전송된다. 업로드된 이미지에 대한 정보가 포함된 메시지를 이미지 최적화 서비스의 메시지 큐에 담는다. 이미지 최적화 서비스는 저장소에서 이미지를 가져와 최적화하고, 2번에서 저장해놨던 이미지를 대체한다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:1:2","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"메시지 큐의 이점 ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:0","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"비동기(Asynchronous) 동기화 방식은 많은 메시지(데이터)가 전송될 경우 병목이 생길 수 있고, 뒤에 들어오는 요청에 대한 응답이 지연된다. 메시지 큐는 생산된 메시지의 저장, 전송에 대해 동기화 처리를 진행하지 않고, 큐에 넣어 두기 때문에 나중에 처리할 수 있다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:1","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"낮은 결합도(Decoupling) 생산자 서비스와 소비자 서비스가 독립적으로 행동하게 됨으로써 서비스 간 결합도가 낮아진다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:2","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"확장성(Scalable) 생산자 서비스 혹은 소비자 서비스를 원하는 대로 확장할 수 있기 때문에 확장성이 좋다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:3","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"탄력성(Resilience) 소비자 서비스가 다운되더라도 어플리케이션이 중단되는 것은 아니다. 메시지는 메시지 큐에 남아 있다. 소비자 서비스가 다시 시작될 때마다 추가 설정이나 작업을 수행하지 않고도 메시지 처리를 시작할 수 있다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:4","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"보장성(Guarantees) 메시지 큐는 큐에 보관되는 모든 메시지가 결국 소비자 서비스에게 전달된다는 일반적인 보장을 제공한다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:5","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["etc"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-09-19-message-queue/ ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:3:0","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["java"],"content":"해싱 해싱은 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 찾아가는 검색 방식이다. 키값을 원소 위치로 변환하는 함수를 해시 함수(Hash Function)라 한다. 해시 함수에 의해 계산된 주소에 저장할 값을 저장한 표를 해시 테이블(Hash Table)이라 한다. 해시 테이블은 빠른 검색 속도를 제공하는데 이유는 내부적으로 버킷(배열)을 사용하여 데이터를 저장하기 때문이다. 해시 테이블은 각각의 key 값에 해시 함수를 적용해 배열의 고유한 인덱스를 생성한 후 인덱스를 이용해 값을 저장한다. 실제 값이 저장되는 장소를 버킷이라 한다. 어떤 수업을 듣는 10명의 학생에게 자리를 배정한다고 생각해보자. 이때 자리가 딱 10자리가 있고 10명의 학생은 각각 다른 이름을 가지고 있다. 그리고 좌석 번호를 생성하는 번호 생성기에 이름을 입력하면 좌석 번호가 나오게 된다. 이때 번호 생성기가 해시 함수의 역할을 한다. 그리고 좌석 번호와 학생 정보를 기록한 테이블은 해시 테이블이 된다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:1:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"해시 충돌 앞서 번호 생성기를 통하여 10명의 학생을 각각 자리에 앉혔다. 10명의 학생을 각각의 자리에 안내할 수 있었던 것은 사실 번호 생성기의 성능이 좋아 겹치지 않았다. 하지만 수업의 퀄리티가 좋아져 학생의 수가 갑자기 엄청나게 늘어났다. 기존의 번호 생성기는 0~20까지의 번호밖에 만들지 못했는데 학생의 수가 어느덧 30명이 되었다. 이제 필연적으로 겹치는 번호가 생성될 수밖에 없다. 그럼 이미 좌석 배정이 받은 학생이 있는 자리에 새로운 학생을 배정하게 되는데 이러한 경우가 해시 충돌 상황이다. 이러한 해시 충돌을 해결하는 방법에는 크게 두 가지 방법이 있다. Open Addressing Separate Chaining Open Addressing은 이미 자리에 누군가가 있으면 다른 곳으로 배정하는 방식이다. 다른 곳에 배정하는 방식에 따라 Linear Probing과 Quadratic Probing 등의 방법이 있다. Separate Chaining은 해시 테이블의 구조를 변경하여 하나 이상의 키값을 저장할 수 있도록 하는 방법이다. 이때 주로 사용하는 자료구조로 연결 리스트를 사용한다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:2:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"HashMap 에서의 Separate Chaining HashMap에서 사용하는 충돌기법 방식은 Separate Chaining이다. Java 8 이전에의 HashMap에서는 단순히 연결 리스트를 사용하였다. 하지만 Java 8 이후부터는 데이터의 개수가 많아지면 연결 리스트가 아닌 트리 자료구조를 사용한다. 정확히 말하자면 레드 블랙 트리 자료구조이다. 그렇다면 데이터의 개수가 많아진다는 기준점은 무엇일까? 하나의 해시 버킷에 8개의 키-값 쌍이 모이면 연결 리스트를 트리로 변경하게 된다. 또한 버킷의 데이터를 삭제하여 개수가 6개에 이르면 다시 연결 리스트로 변경한다. 그럼 왜 6과 7 또는 7과 8이 아닌 6과 8이 기준이겠냐는 의문이 생길 수 있다. 이유는 차이가 1일 경우 삽입/삭제가 반복되어 일어나면 불필요하게 트리와 연결 리스트로 변경하는 일이 발생하기 때문이다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:3:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"해시 버킷의 확장 버킷은 결국 배열로 구성되어 있다. 우리가 HashMap을 구현할 때 따로 버킷의 개수를 지정 해주지 않았다면 기본값인 16으로 버킷의 개수가 지정된다. 해시 버킷의 개수가 일정 개수 이상이 되면 버킷의 개수를 2배로 늘리게 된다. 버킷을 늘리면 해시 충돌의 가능성도 낮아져 해시 충돌로 인한 문제를 해결할 수도 있다. 하지만 두 배로 증가할 때마다 새로운 Separate Chaining을 구성해야 하는 문제가 있다. 가장 좋은 것은 버킷의 개수를 예측할 수 있다면 지정하여 HashMap을 생성하는 것이다. 따라서 데이터의 개수가 예측 가능하다면 지정하여 생성자의 인자로 넣어주면 불필요한 Separate Chaining을 줄일 수 있다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:4:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"Load Factor 버킷의 수를 두 배로 늘릴 때 해시 버킷의 개수는 어떻게 정할까? HashMap 클래스에 들어가 load factor 부분을 살펴보면 0.75f이라고 설정된 것을 볼 수 있다. 이 의미는 데이터의 개수가 현재 버킷 개수의 0.75 즉 3/4 이 되었을 때 두 배로 확장한다는 뜻이다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:4:1","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-05-hash-hashmap/ ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:5:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["etc"],"content":"로드 밸런싱이란 서버가 처리해야 할 업무 혹은 요청(Load)을 여러 대의 서버로 나누어(Balancing) 처리하는 것을 의미한다. 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 하는 것이 목적이다. 서비스의 규모가 커지고, 이용자 수가 늘어나게 되면 기존의 서버만으로는 원활한 서비스 동작이 불가능하게 되고, 이에 대처할 수 있는 방법은 크게 두 가지로 나뉜다. 기존의 서버 성능을 확장하는 Scale-up 방식 기존의 서버와 동일하거나 낮은 성능의 서버를 증설하는 Scale-out 방식 이때 Scale-out 방식을 통해 증가한 트래픽에 대처하기로 했다면, 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드 밸런싱이 반드시 필요하다. ","date":"2022-05-12","objectID":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/:0:0","tags":["load-balancing"],"title":"로드밸런싱","uri":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/"},{"categories":["etc"],"content":"로드 밸런싱 기법 로드 밸런싱 기법은 여러 가지가 있다. 서버의 능력을 고려하여 분배해야 하기 때문에 서버의 상황에 맞춰 적절한 방법을 선택해야 한다. 라운드로빈 방식(Round Robin Method) 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식이다. 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있고, 서버와의 연결(세션)이 오래 지속되지 않는 경우에 활용하기 적합하다. 가중 라운드로빈 방식(Weighted Round Robin Method) 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분한다. 주로 서버의 트래픽 처리 능력이 상이한 경우 사용되는 부하 분산 방식이다. 예를 들어 A라는 서버가 5라는 가중치를 갖고 B라는 서버가 2라는 가중치를 갖는다면, 로드 밸런서는 라운드로빈 방식으로 A 서버에 5개 B 서버에 2개의 요청을 전달한다. IP 해시 방식(IP Hash Method) 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식이다. 사용자의 IP를 해싱해(Hashing, 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 매핑하는 것, 또는 그러한 함수) 로드를 분배하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장한다. 최소 연결 방식(Least Connection Method) 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분한다. 자주 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합한 방식이다. 최소 응답 시간 방식(Least Response Time Method) 서버의 현재 연결 상태와 응답 시간(Response Time, 서버에 요청을 보내고 최초 응답을 받을 때까지 소요되는 시간)을 모두 고려하여 트래픽을 배분한다. 가장 적은 연결 상태와 가장 짧은 응답 시간을 보이는 서버에 우선적으로 로드를 배분하는 방식이다. ","date":"2022-05-12","objectID":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/:1:0","tags":["load-balancing"],"title":"로드밸런싱","uri":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/"},{"categories":["etc"],"content":"L4 로드 밸런싱과 L7 로드 밸런싱 로드 밸런싱에는 L4 로드 밸런싱과 L7 로드 밸런싱이 가장 많이 활용된다. L4, L7은 각각 Layer 4(전송 계층) 프로토콜과 Layer 7(응용 계층) 프로토콜의 헤더를 부하 분산에 이용하기 때문에 붙은 접두사이다. 모든 요청을 L4 혹은 L7 로드 밸런서가 받아 서버들에게 적절히 나누어 준다. L4 로드 밸런서는 네트워크 계층(IP, IPX)이나 전송 계층(TCP, UDP)의 정보(IP주소, 포트번호, MAC주소, 전송 프로토콜)를 바탕으로 로드를 분산한다. L7 로드 밸런서는 애플리케이션 계층(HTTP, FTP, SMTP)에서 로드를 분산하기 때문에 HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능하다. 쉽게 말해 패킷의 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배하는 것이 가능한 것이다. URL에 따라 부하를 분산시키거나, HTTP 헤더의 쿠키 값에 따라 부하를 분산하는 등 클라이언트의 요청을 보다 세분화해 서버에 전달할 수 있다. L7 로드 밸런서의 경우 특정한 패턴을 지닌 바이러스를 감지해 네트워크를 보호할 수 있으며, DoS/DDoS와 같은 비정상적인 트래픽을 필터링할 수 있어 네트워크 보안 분야에서도 활용되고 있다. ","date":"2022-05-12","objectID":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/:2:0","tags":["load-balancing"],"title":"로드밸런싱","uri":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/"},{"categories":["etc"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-07-load-balancing/ ","date":"2022-05-12","objectID":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/:3:0","tags":["load-balancing"],"title":"로드밸런싱","uri":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/"},{"categories":["system"],"content":"비관적 락 비관적 락은 대부분의 경우 트랜젝션에서 충돌이 발생할 것이라 가정하고, 일단 락을 걸고 보는 기법이다. 락을 걸게 되면 다른 트랜잭션에서는 락이 해제되기 전에 데이터를 가져갈 수 없다. 비관적 락은 데이터베이스의 락 알고리즘을 통해 구현되며, 데이터를 수정하는 즉시 트랜잭션 충돌을 감지한다. ","date":"2022-05-08","objectID":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/:1:0","tags":["pessimistic-lock","optimistic-lock"],"title":"비관적락, 낙관적 락","uri":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/"},{"categories":["system"],"content":"JPA에서 비관적 락 구현 public interface HomeRepository extends JpaRepository\u003cHome, Long\u003e { @Lock(LockModeType.PESSIMISTIC_WRITE) @Query(\"select h from Home h where h.name = :name\") Home findWithNameForUpdate(@Param(\"name\") String name); } @Service @RequiredArgsConstructor @Slf4j public class HomeService { private final HomeRepository homeRepository; @Transactional public int decreasePrice(String name, int price) { Home home = homeRepository.findWithNameForUpdate(name); home.decreasePrice(price); return home.getPrice(); } } Hibernate:selecthome0_.idxasidx1_0_,home0_.addressasaddress2_0_,home0_.nameasname3_0_,home0_.priceasprice4_0_fromhomehome0_wherehome0_.name=?forupdate ","date":"2022-05-08","objectID":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/:1:1","tags":["pessimistic-lock","optimistic-lock"],"title":"비관적락, 낙관적 락","uri":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/"},{"categories":["system"],"content":"비관적 락의 LockModeType PESSIMISTIC_READ shared lock을 얻을 수 있다. 데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용하며, 일반적으로 잘 사용하지 않는다. 데이터베이스 대부분은 방언에 의해 PESSIMISTIC_WRITE로 동작한다. PESSIMISTIC_WRITE exclusive lock을 얻을 수 있다. 데이터베이스에 쓰기 락을 걸 때 사용한다. ","date":"2022-05-08","objectID":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/:1:2","tags":["pessimistic-lock","optimistic-lock"],"title":"비관적락, 낙관적 락","uri":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/"},{"categories":["system"],"content":"낙관적 락 낙관적 락은 대부분의 경우 트랜젝션의 충돌이 일어나지 않는다는 낙관적 가정을 하는 기법이다. 낙관적 락은 실제로 Lock을 이용하지 않고 버전을 이용함으로써 정합성을 맞추는 방법이다. 낙관적 락은 데이터베이스 자체에서 제공하는 것이 아니라 어플리케이션에서 제공하는 기능이다. 먼저 데이터를 읽은 후에 update를 수행할 때 현재 내가 읽은 버전이 맞는지 확인하여 업데이트한다. 내가 읽은 버전에서 수정사항이 생겼을 때에는 application에서 다시 읽은 후에 작업을 수행한다. ","date":"2022-05-08","objectID":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/:2:0","tags":["pessimistic-lock","optimistic-lock"],"title":"비관적락, 낙관적 락","uri":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/"},{"categories":["system"],"content":"JPA에서 낙관적 락 구현 JPA에서 낙관적 락을 사용하기 위해서는 엔티티 클래스에 @Version 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다. @Entity public class Home { @Id private Long id; private String name; private int price; @Version private Integer version; } public interface HomeRepository extends JpaRepository\u003cHome, Long\u003e { @Lock(LockModeType.OPTIMISTIC) @Query(\"select h from Home h where h.name = :name\") Home findWithNameForUpdate(@Param(\"name\") String name); } @Service @RequiredArgsConstructor @Slf4j public class HomeService { private final HomeRepository homeRepository; @Transactional public int decreasePrice(String name, int price) { Home home = homeRepository.findWithNameForUpdate(name); home.decreasePrice(price); return home.getPrice(); } } @Version을 명시할때는 다음과 같은 주의사항이 있다. 각 엔티티 클래스에는 하나의 버전 속성 만 있어야 한다. 여러 테이블에 매핑 된 엔티티의 경우 기본 테이블에 배치되어야 한다. 버전에 명시할 타입은 int, Integer, long, Long, short, Short, java.sql.Timestamp 중 하나여야 한다. JPA는 Select시에 트랜잭션 내부에 버전 속성의 값을 보유하고 트랜젝션이 업데이트를 하기 전에 버전 속성을 다시 확인한다. 그 동안에 버전 정보가 변경이 되면 OptimisticLockException이 발생하고 변경되지 않으면 트랜잭션은 버전속성을 증가하는 업데이트 하게 된다. ","date":"2022-05-08","objectID":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/:2:1","tags":["pessimistic-lock","optimistic-lock"],"title":"비관적락, 낙관적 락","uri":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/"},{"categories":["system"],"content":"낙관적 락의 LockModeType NONE 별도의 옵션을 사용하지 않아도 Entity에 @Version이 적용된 필드만 있으면 낙관적 락이 적용된다. Entity 수정시에 낙관적 락이 발생한다. OPTIMISTIC Entity 수정시에만 발생하는 낙관적 락이 읽기 시에도 발생하도록 설정한다. 읽기시에도 버전을 체크하고 트랜잭션이 종료될 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다. 이를 통해 dirty read와 non-repeatable read를 방지한다. OPTIMISTIC_FORCE_INCREMENT 엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가시킨다. 이때 데이터베이스의 버전이 엔티티의 버전과 다르면 예외가 발생한다. 추가로 엔티티를 수정하면 수정시 버전 UPDATE 가 발생하여 총 2번의 버전 증가가 나타날 수 있다. 논리적인 단위의 엔티티 묶음을 관리할 수 있다. 예를 들어 게시물과 첨부파일이 일대다, 다대일의 양방향 연관관계이고 첨부파일이 연관관계의 주인일 때, 첨부파일 추가 시 게시물의 버전도 강제로 증가해야 할 때 사용할 수 있다. ","date":"2022-05-08","objectID":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/:2:2","tags":["pessimistic-lock","optimistic-lock"],"title":"비관적락, 낙관적 락","uri":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/"},{"categories":["system"],"content":"비관적 락 vs 낙관적 락 비관적 락 낙관적 락 장점 - 업데이트가 실패했을 때 재시도 로직을 작성하지 않아도 된다. - 실제 Lock을 이용하지 않으므로 비관적 락보다 성능상 이점이 있다. 단점 - 낙관적 락보다 성능이 좋지 않다. - 데드락이 걸릴 수 있다. - 업데이트가 실패했을 때 재시도 로직을 개발자가 직접 작성해야 한다. 결론적으로, 충돌이 빈번하게 일어난다면 비관적 락, 빈번하지 않다면 낙관적 락을 사용하는 것이 좋다. ","date":"2022-05-08","objectID":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/:3:0","tags":["pessimistic-lock","optimistic-lock"],"title":"비관적락, 낙관적 락","uri":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/"},{"categories":["system"],"content":"참고 https://www.inflearn.com/course/%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4%EC%8A%88-%EC%9E%AC%EA%B3%A0%EC%8B%9C%EC%8A%A4%ED%85%9C https://devjem.tistory.com/28 https://sup2is.github.io/2020/10/22/jpa-optimistic-lock-and-pessimistic-lock.html https://effectivesquid.tistory.com/entry/Optimistic-Lock%EA%B3%BC-Pessimistic-Lock ","date":"2022-05-08","objectID":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/:4:0","tags":["pessimistic-lock","optimistic-lock"],"title":"비관적락, 낙관적 락","uri":"/%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD/"},{"categories":["web"],"content":"TCP Keep-Alive 두 종단 간의 연결을 유지하는 것이 목적이다. 연결된 TCP 소켓을 체크할 수 있고 TCP 연결이 여전히 진행중인지 혹은 끊어졌는지를 결정한다. TCP Keepalive는 연결된 세션의 재활용 측면에서만 아니라 좀비 커넥션의 삭제에도 도움을 준다. TCP 연결을 끊으려면 FIN 패킷이 필요하다. 하지만 다양한 이유로 FIN 패킷을 받을 수 없는 상황이 된다면 FIN을 전달할 수 없어 계속 연결된 것처럼 남아있게 된다. TCP Keepalive 옵션을 사용한다면 일정시간이 확인 패킷을 보내는 로직을 통해 일정시간 동안 응답이 없다면 연결을 종료하기 때문에 좀비 커넥션을 방지할 수 있다. ","date":"2022-05-06","objectID":"/keep-alive/:1:0","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"TCP Keep-Alive 파라미터 net.ipv4.tcp_keepalive_time keepalive 소켓의 유지시간 net.ipv4.tcp_keepalive_probes 패킷을 보낼 최대 전송 횟수 네트워크 패킷은 여러 사유로 인해 유실될 수 있으므로 재전송 매커니즘을 넣는다. net.ipv4.tcp_keepalive_intvl 재전송 패킷을 보내는 주기 ","date":"2022-05-06","objectID":"/keep-alive/:1:1","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"TCP Keep-Alive 동작 과정 최초로 세션이 연결된 다음 tcp_keepalive_time초 동안 기다린다. 그리고 확인 패킷을 보내게 된다. 확인 패킷에 대한 응답이 오지 않으면 tcp_keepalive_intvl 간격으로 tcp_keepalive_probes 만큼 패킷을 더 보낸다. tcp_keepalive_probes의 마지막 패킷에 대해서 응답이 오지 않으면 연결을 끊는다. ","date":"2022-05-06","objectID":"/keep-alive/:1:2","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"HTTP Keep-Alive 최대 얼마동안 연결을 유지하도록 하는게 목적이다. HTTP 응답 Header의 예는 다음과 같다. 아래 응답을 받고 10초가 되기 전에 또 요청 했다면 Keep-Alive: timeout=10, max=19가 포함된 응답을 받을 것이다. HTTP/1.1 200 OK Connection: Keep-Alive Content-Type: text/html; charset=UTF-8 Date: Thu, 15 Jan 2015 16:45:29 GMT Content-Length: 1845 Keep-Alive: timeout=10, max=20 ","date":"2022-05-06","objectID":"/keep-alive/:2:0","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"HTTP Keep-Alive 파라미터 2개의 Keep-Alive 파라미터는 콤파(,)분리되어 응답된다. timeout 연결의 유지를 위한 최소한의 시간(초). max 연결을 종료하기 전까지 보낼 수 있는 최대 요청 수. ","date":"2022-05-06","objectID":"/keep-alive/:2:1","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"HTTP Keep-Alive 장점 HTTP/1.1에서 Keep-Alive로 인한 장점은 다음과 같다. 3-way handshake로 인한 지연시간을 줄일 수 있다. CPU 사용량을 줄여준다 : 새로운 TCP 연결을 만들기 위해서는 CPU, 메모리 사용과 같은 많은 리소스가 필요하다. 연결된 커넥션을 재사용하기 때문에 리소스 사용을 줄여준다. ","date":"2022-05-06","objectID":"/keep-alive/:2:2","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"TCP Keep-Alive vs HTTP Keep-Alive HTTP Keep-Alive는 HTTP 프로토콜의 기능이다. Keep-Alive 기능을 구현하는 웹 서버는 마지막 HTTP 응답(해당 HTTP 요청이 있는 경우)을 보낸 이후 시간 범위에 대해 주기적으로(수신 HTTP 요청에 대해) 연결/소켓을 확인해야 한다. 구성된 연결 유지 시간(초)까지 HTTP 요청이 수신되지 않으면 웹 서버는 연결을 닫는다. 웹 서버에서 ‘닫기’를 수행한 후에는 더 이상의 HTTP 요청이 불가능하다. 반면 TCP Keep-Alive는 TCP 계층에서 OS에 의해 관리된다. 작은 패킷을 보내 TCP 연결을 열린 상태로 유지한다. 또한 패킷이 전송될 때 연결이 끊어지는 즉시 발신자에게 알림이 전송되도록 확인하는 역할을 한다. ","date":"2022-05-06","objectID":"/keep-alive/:3:0","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"참고 https://devidea.tistory.com/60 https://eminentstar.tistory.com/50?category=578513 https://stackoverflow.com/questions/9334401/http-keep-alive-and-tcp-keep-alive ","date":"2022-05-06","objectID":"/keep-alive/:4:0","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"서버는 로그인하는 시점에 보통 내부적으로 사용자 세션을 생성하고 이를 식별할 수 있는 식별자(세션 키 - 자바 웹 애플리케이션에서는 jsessionid라는 이름을 가진다)를 사용자에 보내는 응답에 포함시킨다. 브라우저는 이를 쿠키 형태로 가지고 있게 되며, 이 세션 키가 서버 입장에서 사용자의 identity를 식별할 수 있는 식별자가 된다. 이 때 누군가가 이 세션 키를 가로채서 알게 되면 마치 그 사람인 척 하고 서버에 요청을 보내도 서버에서는 이게 진짜 사용자가 보냈는지 아닌지를 판단할 수 없다. 이것을 세션 하이재킹이라고 한다. ","date":"2022-05-02","objectID":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/:0:0","tags":["session-hijacking"],"title":"세션 하이재킹","uri":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/"},{"categories":["web"],"content":"세션 하이재킹 방법 세션 하이재킹을 하는 방법에는 크게 4가지가 있다. 보안이 취약한 네트워크를 통해 전송되는 쿠키를 패킷 스니퍼를 사용하여 알아낸다. 예를 들어 해커가 악의적인 목적으로 Wi-Fi AP를 공개하고, 여기에 접속한 사람들이 보내는 패킷을 스니핑할 수 있다. 세션 키를 데이터베이스 등의 저장소를 이용하여 저장하는 경우, 데이터베이스에 몰래 접속하여 정보를 빼낼 수 있다. XSS를 사용한다. 사용자의 PC에 물리적으로 접속한다. ","date":"2022-05-02","objectID":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/:1:0","tags":["session-hijacking"],"title":"세션 하이재킹","uri":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/"},{"categories":["web"],"content":"세션 하이재킹 대응 여기에 대해 아래와 같이 대응할 수 있다. 패킷 스니핑 : 보통 HTTPS를 씌우면 쉽게 해결된다. 데이터베이스 탈취 : 세션 키를 단방향 암호화하여 저장한다. 그러면 데이터베이스가 털리더라도, 원래 세션 키를 알아낼 수는 없다. XSS : 모든 컨텐츠를 escaping 해준다. 사용자 PC 접속 : 한 방에 해결해 주는 방법은 없다. 대신 사용자가 로그아웃할 때 혹은 주기적으로 세션 키를 바꿔주어 위험을 최소화시킬 수 있다. ","date":"2022-05-02","objectID":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/:2:0","tags":["session-hijacking"],"title":"세션 하이재킹","uri":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/"},{"categories":["web"],"content":"참고 https://m.blog.naver.com/PostView.nhn?blogId=muchine98\u0026logNo=220354628727\u0026proxyReferer=https:%2F%2Fwww.google.co.kr%2F ","date":"2022-05-02","objectID":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/:3:0","tags":["session-hijacking"],"title":"세션 하이재킹","uri":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/"},{"categories":["web"],"content":"JWT 는 유저를 인증하고 식별하기 위한 토큰(Token)기반 인증이다. RFC 7519 에 자세한 명세가 나와있다. 토큰은 세션과는 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다. JWT 가 가지는 핵심적인 특징이 있다면, 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보가 포함(Self-contained)된다는 것이다. 데이터가 많아지면 토큰이 커질 수 있으며 토큰이 한 번 발급된 이후 사용자의 정보를 바꾸더라도 토큰을 재발급하지 않는 이상 반영되지 않는다. JWT 를 사용하면 RESTful 과 같은 무상태(Stateless)인 환경에서 사용자 데이터를 주고 받을 수 있게된다. 세션(Session)을 사용하게 될 경우에는 쿠키 등을 통해 식별하고 서버에 세션을 저장했지만 JWT 와 같은 토큰을 클라이언트에 저장하고 요청시 단순히 HTTP 헤더에 토큰을 첨부하는 것만으로도 단순하게 데이터를 요청하고 응답을 받아올 수 있다. ","date":"2022-04-30","objectID":"/jwt/:0:0","tags":["jwt"],"title":"JWT","uri":"/jwt/"},{"categories":["web"],"content":"JWT 동작순서 일반적으로 JWT를 사용하면 아래와 같은 순서로 진행된다. 클라이언트 사용자가 아이디, 패스워드를 통해 웹서비스 인증. 서버에서 서명된(Signed) JWT 를 생성하여 클라이언트에 응답으로 돌려주기. 클라이언트가 서버에 데이터를 추가적으로 요구할 때 JWT 를 HTTP Header 에 첨부. 서버에서 클라이언트로부터 온 JWT 를 검증. JWT는 JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화한 것이 포함되며 토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명도 있다. 따라서 사용자가 JWT 를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치게 되며 검증이 완료되면 요청한 응답을 돌려준다. Base64 URL-safe Encode Base64 URL-safe Encode는 일반적인 Base64 Encode 에서 URL 에서 오류없이 사용하도록 ‘+’, ‘/’ 를 각각 ‘-’, ‘_’ 로 표현한 것이다. ","date":"2022-04-30","objectID":"/jwt/:1:0","tags":["jwt"],"title":"JWT","uri":"/jwt/"},{"categories":["web"],"content":"구조 JWT 의 구조를 살펴보자. JWT는 Header, Payload, Signature 로 구성된다. 또한 각 요소는 . 으로 구분된다. Header에는 JWT 에서 사용할 타입과 해시 알고리즘의 종류가 담겨있으며 Payload에는 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨있다. 마지막으로 Signature 에는 Header, Payload 를 Base64 URL-safe Encode를 한 이후 Header에 명시된 해시함수를 적용하고, 개인키(Private Key)로 서명한 전자서명이 담겨있다. 전자서명 알고리즘으로 타원 곡선 암호화(ECDSA)를 사용한다고 가정하면, Sig = ECDSA(SHA256(B64(Header).B64(Payload)), PrivateKey) 전자서명도 Base64 URL-safe Encode로 처리해서 합쳐줄 필요가 있다. 여기서 만든 전자서명은 Header, Payload 가 변조되었는지 확인하기 위해 사용되는 중요 정보이며 JWT 를 신뢰할 수 있는 토큰으로 사용할 수 있는 근거가 된다. 전자서명에는 비대칭 암호화 알고리즘을 사용하므로 암호화를 위한 키와 복호화를 위한 키가 다르다. 암호화(전자서명)에는 개인키를, 복호화(검증)에는 공개키를 사용한다. 이를 JWT 로 표현하려면, 다음과 같다. JWT = B64(Header).B64(Payload).B64(Sig) ","date":"2022-04-30","objectID":"/jwt/:2:0","tags":["jwt"],"title":"JWT","uri":"/jwt/"},{"categories":["web"],"content":"참고 https://pronist.dev/143 ","date":"2022-04-30","objectID":"/jwt/:3:0","tags":["jwt"],"title":"JWT","uri":"/jwt/"},{"categories":["java"],"content":"스레드풀 ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:0","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"스레드풀 생성 스레드가 기하급수적으로 늘어난다면 스레드 생성과 스케줄링으로 인해 CPU의 메모리 사용량이 늘어나고 어플리케이션의 성능의 저하가 일어난다. 병렬작업의 급증을 막기 위해서는 특정 스레드 개수만큼 작업 컨베이어 벨트 (작업 큐)를 만들어 놓고 작업을 컨베이어 벨트에 올려놓아 작업이 끝난 스레드가 컨베이어에서 작업을 꺼내 기능을 수행하는 방식으로 작업을 구성할 수 있다. 아무리 작업 처리 요청이 폭주하여도 스레드의 전체 개수가 늘어나지 않기 때문에 어플리케이션의 성능이 급격하게 저하되지 않는다. 자바는 스레드 풀을 생성하고 사용할 수 있도록 java.util.concurrent.ExecutorService 인터페이스와 Executors 클래스 메소드 중 newCachedThreadPool과 newFixedThreadPool 메소드를 제공하고 있다. // 스레드 풀 생성 //1. 자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newCachedThreadPool(); //2. 원하는 개수만큼 생성 ExecutorService executorServiceWithNum = Executors.newFixedThreadPool(2); //3. 최대치로 생성 ExecutorService executorServiceWithMax = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); //4. 완전 수동 // ThreadPoolExecutor( 코어 스레드 수, 최대 스레드 개수, 놀고 있는 시간, 놀고있는 시간 단위, 작업 큐 ) ExecutorService executorServiceWithCustom = new ThreadPoolExecutor(3, 100, 120L, TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e()); Note Executors.newFixedThreadPool(10) 최대 쓰레드를 10개까지 만드는 풀. 동시에 일어나는 업무의 량이 비교적 일정할때 사용한다. Executors.newCachedThreadPool() 쓰레드 수의 제한을 두지 않은 방식의 쓰레드풀 방식으로, 새로운 쓰레드 시작 요청이 들어올때마다 하나씩 쓰레드를 생성한다. 업무가 종료된 쓰레드들은 바로 사라지지 않고 1분동안 살아있다가 다른 작업 요청이 없으면 사라진다. 짧고 반복되는 스타일의 작업요청이 들어올 경우 유용하다. ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:1","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"스레드풀 종료 스레드풀의 스레드는 데몬스레드가 아니므로 main이 종료되더라도 작업을 처리하기 위해 계속 실행상태로 남아있다. 때문에 어플리케이션을 종료할 때는 해당 스레드풀을 종료시켜 스레드풀 안의 스레드를 종료상태가 되도록 처리해야 한다. // 1. 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료한다. executorServiceWithCached.shutdown(); // 2. 당장 중지한다. 리턴값은 작업큐에 남아있는 작업의 목록이다. List\u003cRunnable\u003e runable = executorServiceWithCached.shutdownNow(); // 3. 작업은 대기 하지만 모든 작업처리를 특정 시간안에 하지 못하면 작업중인 스레드를 중지하고 false를 리턴한다. 아래는 100초 설정 try { boolean isFinish = executorServiceWithCached.awaitTermination(100, TimeUnit.SECONDS); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:2","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"작업의 생성 Runable 또는 Callable 구현 클래스로 작업을 생성한다. 둘의 차이는 작업이 끝난 후 리턴 값이 있냐 없느냐다. // Runable 구현 객체 (익명객체 사용) Runnable task1 = ()-\u003e { for (int index = 0; index \u003c 10; index++) { System.out.println(\"작업 중입니다.\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } }; // Callable 구현 Callable\u003cBoolean\u003e task2 = () -\u003e{ Boolean isFinish = true; for (int index = 0; index \u003c 10; index++) { System.out.println(\"작업 중입니다. Call\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } return isFinish; }; ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:3","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"작업처리 요청 task를 컨베이어 벨트에 올리는 작업이다. 즉 작업큐에 위 task객체를 넣는 것이다. // 1. 리턴 값이 없는 단순 Runnable를 처리 executorServiceWithCached.execute(task1); // 2. 리턴 가능한 Callable도 넣을 수 있는 메서드 Future\u003cBoolean\u003e returnBoolean = executorServiceWithCached.submit(task2); try { System.out.println(\"종료 : \" + returnBoolean.get()); //작업 반환을 기다려 얻어온다. } catch (Exception e) { } execute와 submit의 차이는 return을 받느냐 못 받느냐의 차이이다. 추가로 execute()는 작업 도중 오류 발생 시 오류가 난 스레드를 스레드풀에서 제거하지만 submit()은 오류가 발생하여도 해당 스레드를 재사용한다. ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:4","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"작업완료 통보 submit()은 task 작업을 작업큐에 넣고 바로 Futrue객체를 리턴한다. 해당 객체의 get()메서드를 호출하면 호출한 순간부터 스레드가 작업을 완료할 때까지 대기하고 있다가 완료된 후 결과를 받아온다. public static void main(String args[]){ // 스레드 풀 생성 //자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newCachedThreadPool(); // Runable 구현 객체 ( 익명구현객체 사용 ) Runnable task1 = ()-\u003e { for (int index = 0; index \u003c 100; index++) { System.out.println(\"작업 중입니다.\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } }; // Callable 구현 Callable\u003cBoolean\u003e task2 = () -\u003e{ Boolean isFinish = true; for (int index = 0; index \u003c 100; index++) { System.out.println(\"작업 중입니다. Call\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } return isFinish; }; // 1. 리턴 값이 없는 단순 Runnable를 처리 executorServiceWithCached.execute(task1); // 2. 리턴 가능한 Callable도 넣을 수 있는 메서드. Future\u003cBoolean\u003e returnBoolean = executorServiceWithCached.submit(task2); // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성 executorServiceWithCached.execute(()-\u003e{ try { if( returnBoolean.get() ) { System.out.println(\"작업이 완벽히 끝났습니다. \"); } else { System.out.println(\"작업이 끝나지 못했습니다.\"); } } catch (Exception e) { } }); // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성 executorServiceWithCached.execute(()-\u003e{ try { // 만약 특정 시간 내에 끝났는지 확인하려는 경우 if( returnBoolean.get(1,TimeUnit.SECONDS) ) { System.out.println(\"작업이 완벽히 끝났습니다. \"); } } catch (Exception e) { System.out.println(\"작업이 시간내에 끝나지 못했습니다.\"); } }); // 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료 executorServiceWithCached.shutdown(); } ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:5","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"작업처리 결과를 외부 객체에 저장 public class FirstThread implements Runnable { ResultShare resultShare; //공유객체 외부에서 주입 public FirstThread ( ResultShare resultShare ) { this.resultShare = resultShare; } @Override public void run() { int result = 0; for (int index = 1; index \u003c= 100; index++) { result += index; try { Thread.sleep(10); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } System.out.println(\"1~100까지의 합은 \" + result +\"입니다.\"); resultShare.sum(result); resultShare.showSum(); } } public class SecondThread implements Runnable { ResultShare resultShare; //공유객체 외부에서 주입 public SecondThread ( ResultShare resultShare ) { this.resultShare = resultShare; } @Override public void run() { int result = 0; for (int index = 101; index \u003c= 200; index++) { result += index; } System.out.println(\"101~200까지의 합은 \" + result +\"입니다.\"); resultShare.sum(result); resultShare.showSum(); } } public class ResultShare { private int result; public int sum( int number ) { return result+=number; } public void showSum() { System.out.println(\" 지금 저장된 값은 : \" + result + \"입니다.\"); } public int getResult() { return result; } } public static void main(String args[]){ // 스레드 풀 생성 //자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newCachedThreadPool(); ResultShare resultShare = new ResultShare(); Runnable task1 = new FirstThread(resultShare); Runnable task2 = new SecondThread(resultShare); // Runable이라도 작업이 끝난 후 Future\u003c리턴 객체\u003e로 무엇을 받을 지 임의로 정할 수 있다. run()의 리턴값으로 아무 값이 없더라도 종료 후에 아무 원하는 객체를 이런 식으로 리턴할 수 있다. Future\u003cResultShare\u003e future1 = executorServiceWithCached.submit( task1, resultShare ); Future\u003cResultShare\u003e future2 = executorServiceWithCached.submit( task2, resultShare ); // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성 executorServiceWithCached.execute(()-\u003e{ try { ResultShare temp = future1.get(); temp = future2.get(); System.out.println(\"쓰레드 합산이 끝났습니다. 최종 결과는 : \" + resultShare.getResult()); } catch (Exception e) { } }); // 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료한다. executorServiceWithCached.shutdown(); } // 실행 결과 101~200까지의 합은 15050입니다. 지금 저장된 값은 : 15050입니다. 1~100까지의 합은 5050입니다. 지금 저장된 값은 : 20100입니다. 쓰레드 합산이 끝났습니다. 최종 결과는 : 20100 ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:6","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"작업 완료 순으로 통보 일반적으로 작업 순서대로 처리가 완료되는 것이 아니기 때문에 끝나는 것은 랜덤이다. 여러 개의 작업이 차례대로 처리될 필요가 없고 처리 결과도 차례대로 이용할 필요가 없다면 CompletionService 인터페이스를 구현한 ExecutorCompletionService 클래스를 사용하면 된다. public static void main(String args[]){ // 스레드 풀 생성 //자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); ResultShare resultShare = new ResultShare(); Runnable task1 = new FirstThread(resultShare); Runnable task2 = new SecondThread(resultShare); Future\u003cResultShare\u003e future1 = executorServiceWithCached.submit( task1, resultShare ); Future\u003cResultShare\u003e future2 = executorServiceWithCached.submit( task2, resultShare ); // 각각의 테스트들의 리턴 결과의 객체를 \u003cResultShare\u003e 안에 입력 CompletionService\u003cResultShare\u003e compliCompletionService = new ExecutorCompletionService\u003cResultShare\u003e(executorServiceWithCached); executorServiceWithCached.submit(()-\u003e{ // 작업 최종 통보가 올때까지 while 문을 통해 대기 while(true) { try { // 작업이 끝난 결과를 받아온다. Future\u003cResultShare\u003e take = compliCompletionService.take(); ResultShare result = take.get(); System.out.println(\"지금 까지의 합산은 \" + result.getResult() + \"입니다.\"); } catch ( Exception e) { break; } } }); // 3초 뒤 스레드 강제 중지 try { Thread.sleep(3000); executorServiceWithCached.shutdownNow(); } catch (InterruptedException e) { } } // 결과 101~200까지의 합은 15050입니다. 지금 저장된 값은 : 15050입니다. 1~100까지의 합은 5050입니다. 지금 저장된 값은 : 20100입니다. ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:7","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"콜백 방식의 통보 public class ResultShare { private int result; //\u003c결과 타입, 첨부타입\u003e private static CompletionHandler\u003cResultShare, String\u003e completionHandler = new CompletionHandler\u003cResultShare, String\u003e() { //실패 시 할 일 @Override public void failed(Throwable exc, String attachment) { System.out.println(\"실패하였습니다.\"); } //성공 시 할 일 @Override public void completed(ResultShare result, String attachment) { System.out.println(\"지금까지의 저장된 합은 \" + result.getResult() + \"입니다.\"); } }; public int sum( int number ) { return result+=number; } public void showSum() { System.out.println(\" 지금 저장된 값은 : \" + result + \"입니다.\"); } public int getResult() { return result; } public static CompletionHandler\u003cResultShare, String\u003e getCompletionHandler() { return completionHandler; } } public class FirstThread implements Runnable { ResultShare resultShare; //공유객체 외부에서 주입. public FirstThread ( ResultShare resultShare ) { this.resultShare = resultShare; } @Override public void run() { int result = 0; for (int index = 1; index \u003c= 100; index++) { result += index; } System.out.println(\"1~100까지의 합은 \" + result +\"입니다.\"); resultShare.sum(result); // 끝난 후 성공 콜백 실행 resultShare.getCompletionHandler().completed(resultShare, null); } } public class SecondThread implements Runnable { ResultShare resultShare; //공유객체 외부에서 주입. public SecondThread ( ResultShare resultShare ) { this.resultShare = resultShare; } @Override public void run() { int result = 0; for (int index = 101; index \u003c= 200; index++) { result += index; } System.out.println(\"101~200까지의 합은 \" + result +\"입니다.\"); resultShare.sum(result); // 끝난 후 콜백 실행 resultShare.getCompletionHandler().completed(resultShare, null); } } public static void main(String args[]){ // 스레드 풀 생성 //자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); ResultShare resultShare = new ResultShare(); Runnable task1 = new FirstThread(resultShare); Runnable task2 = new SecondThread(resultShare); Future\u003cResultShare\u003e future1 = executorServiceWithCached.submit( task1, resultShare ); Future\u003cResultShare\u003e future2 = executorServiceWithCached.submit( task2, resultShare ); executorServiceWithCached.shutdown(); } ","date":"2022-04-23","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/:1:8","tags":["thread-pool"],"title":"Java 스레드풀","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"},{"categories":["java"],"content":"스레드 모든 자바 어플리케이션은 Main Thread가 main() 메소드를 실행하면서 시작된다. Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 만들어 병렬로 코드를 실행할 수 있다. 싱글 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만, 멀티 스레드는 메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. 프로세스 내부에서의 멀티 스레드는 공유되는 자원이 있어 하나의 스레드에서 예외가 발생한다면 프로세스 자체가 종료될 수 있다. ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:1:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"Thread 생성 ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"Thread 클래스로부터 직접 생성 new를 통해 Thread 클래스 객체를 생성 후 start 메서드를 통해 다른 스레드에서 할 작업을 할당하는 방법이다. Thread객체를 생성할 때는 Runnable 인터페이스를 구현한 클래스 객체를 매개변수로 받는다. public class Task implements Runnable { @Override public void run() { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); } } public static void main(String args[]){ Runnable task = new Task(); Thread subTread1 = new Thread(task); Thread subTread2 = new Thread(task); subTread1.start(); subTread2.start(); } // 결과 (스레드가 끝나는 순서는 랜덥) 0 1 3 6 10 15 21 28 36 45 0 1 3 Thread[Thread-0,5,main]최종 합 : 45 6 10 15 21 28 36 45 Thread[Thread-1,5,main]최종 합 : 45 ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:1","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"익명 객체 생성 public static void main(String args[]){ Runnable task = new Runnable() { public void run() { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); } }; Thread subTread1 = new Thread(task); Thread subTread2 = new Thread(task); subTread1.start(); subTread2.start(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:2","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"람다식을 통해 익명 객체를 구현 public static void main(String args[]){ Runnable task = ()-\u003e { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); }; Thread subTread1 = new Thread(task); Thread subTread2 = new Thread(task); subTread1.start(); subTread2.start(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:3","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"Thread 하위 클래스로부터 생성 스레드가 실행할 작업을 Runable 구현클래스 대신 Thread를 상속한 새로운 클래스를 정의하여 run 메소드를 Overriding 하는 방법이다. 혹은 코드를 단순히 하기 위해 Thead 익명 객체로 작업 스레드 객체를 생성할 수 있다. // Thread클래스를 상속한 클래스 public class CustomThread extends Thread { @Override public void run() { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); } } public static void main(String args[]){ Thread subTread1 = new CustomThread(); // 익명 객체 생성 Thread subTread2 = new Thread() { public void run() { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); } }; subTread1.start(); subTread2.start(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:4","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"동기화 메소드 또는 동기화 블록 멀티스레드 환경에서의 문제는 스레드들이 객체를 공유하며 작업하는 경우가 생기기 때문에 A스레드와 B스레드가 공유하는 객체가 서로의 작업에 영향을 미치면 안 된다. 동기화 메소드와 동기화 블록 방법은 스레드가 사용 중인 객체를 Lock을 걸어 해당 작업을 진행하는 Thread가 작업을 마칠 때까지 다른 쓰레드가 작업을 하지 못하게 하는 방법이다. // 동기화 메소드 public synchronized void setValue( int value ) { this.value = value; try { Thread.sleep(2000); } catch (Exception e) { } System.out.println(Thread.currentThread().getName() + \"의 Value 값은 \" + this.value +\"입니다.\"); } // 동기화 블록 public void setValue( int value ) { synchronized ( this ) { this.value = value; try { Thread.sleep(2000); } catch (Exception e) { } System.out.println(Thread.currentThread().getName() + \"의 Value 값은 \" + this.value +\"입니다.\"); } } 하지만 Synchronized 키워드를 너무 남발하면 오히려 프로그램 성능저하를 일으킬 수 있기 때문에 적재적소에 잘 사용해야 한다. ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:3:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"참고 https://honbabzone.com/java/java-thread/ ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["web"],"content":"3-Way Handshake 3-Way Handshake는 TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정이다. 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다. 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다. ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:1:0","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"작동 방식 Step 1 (SYN) 클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다. (seq : x) 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다. PORT 상태 Client : CLOSED- SYN_SENT 로 변함 Server : LISTEN Step 2 (SYN + ACK) 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (seq : y, ACK : x + 1) 접속요청을 받은 Q가 요청을 수락했으며, 접속 요청 프로세스인 P도 포트를 열어달라는 메세지를 전송 (SYN-ACK signal bits set) ACK Number필드를 Sequence Number + 1 로 지정하고 SYN과 ACK 플래그 비트를 1로 설정한 새그먼트 전송 (Seq=y, Ack=x+1, SYN, ACK) PORT 상태 Client : CLOSED Server : SYN_RCV Step 3 (ACK) 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보낸다. 마지막으로 접속 요청 프로세스 P가 수락 확인을 보내 연결을 맺는다. (ACK) 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다. PORT 상태 Client : ESTABLISED Server : SYN_RCV ⇒ ACK ⇒ ESTABLISED ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:1:1","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"4-Way Handshake 4-Way Handshake은 연결을 해제(Connecntion Termination)하는 과정이다. ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:2:0","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"작동방식 (Abrupt) RST(TCP reset) 세그먼트가 전송되면 갑작스러운 연결 해제가 수행되는데, RST 세그먼트는 다음과 같은 경우에 전송된다. 존재하지 않는 TCP 연결에 대해 비SYN 세그먼트가 수신된 경우 열린 커넥션에서 일부 TCP 구현은 잘못된 헤더가 있는 세그먼트가 수신된 경우 RST 세그먼트를 보내, 해당 커넥션을 닫아 공격을 방지한다. 일부 구현에서 기존 TCP 연결을 종료해야 하는 경우 연결을 지원하는 리소스 부족할때 원격 호스트에 연결할 수 없고 응답이 중지되었을때 ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:2:1","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"작동방식 (Graceful) Half-Close 기법 위 그림에서 처음 보내는 종료 요청인 (1) FIN 패킷에 실질적으로 ACK가 포함되어 있는 것을 알 수 있는데, 이는 Half-Close 기법을 사용하기 때문이다. 즉, 연결을 종료하려고 할 때 완전히 종료하지 않고 반만 종료한다. Half-Close 기법을 사용하면 종료 요청자가 처음 보내는 FIN 패킷에 승인 번호를 함께 담아서 보내게 되는데, 이때 승인 번호의 의미는 “일단 연결은 종료할건데 귀는 열어둘게. 이 승인 번호까지 처리했으니까 더 보낼 거 있으면 보내\"가 된다. 이후 수신자가 남은 데이터를 모두 보내고 나면 다시 요청자에게 FIN 패킷을 보냄으로써 모든 데이터가 처리되었다는 신호 FIN를 보낸다. 그럼 요청자는 그때 나머지 반을 닫으면서 좀 더 안전하게 연결을 종료할 수 있다. STEP1 (Client → Server : FIN(+ACK) 서버와 클라이언트가 연결된 상태에서 클라이언트가 close()를 호출하여 접속을 끊는다(끊으려한다). 이때, 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다. 이때 FIN 패킷에는 실질적으로 ACK도 포함되어있다. STEP2 (Server → Client : ACK) 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보내고 자신의 통신이 끝날때까지 기다린다. (이상태가 TIME_WAIT 상태) Server(수신자)는 ACK Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다. 서버는 클라이언트에게 응답을 보내고 CLOSE_WAIT 상태에 들어갑니다. 그리고아직 남은 데이터가 있다면 마저 전송을 마친 후에 close( )를 호출 클라이언트에서는 서버에서 ACK를 받은 후에 서버가 남은 데이터 처리를 끝내고 FIN 패킷을 보낼 때까지 기다린다. (FIN_WAIT_2) STEP3 (Server → Client : FIN) 데이터를 모두 보냈다면, 서버는 연결이 종료에 합의 한다는 의미로 FIN 패킷을 클라이언트에게 보낸 후에, 승인 번호를 보내줄 때까지 기다니는 LAST_ACK 상태로 들어간다. STEP4 (Client → Server : ACK) 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다. (실질적인 종료과정 CLOSED에 들어간다.) 이때 TIME_WAIT 상태는 의도치 않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지 만약 에러로 인해 종료가 지연되다가 타임이 초과되면 CLOSED로 들어간다. ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:2:2","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"참고 https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3-Way-Handshake4-Way-Handshake ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:3:0","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["etc"],"content":"Base64를 글자 그대로 직역하면 64진법이라는 뜻이다. 컴퓨터 분야에서 쓰이는 Base 64(베이스 육십사)란 8비트 이진 데이터(예를 들어 실행 파일이나, ZIP 파일 등)를 문자 코드에 영향을 받지 않는 공통 ASCII 영역의 문자들로만 이루어진 일련의 문자열로 바꾸는 인코딩 방식을 가리키는 개념이다. 인코딩(encoding)은 파일에 저장된 정보의 형태나 형식을 데이터 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해서 다른 형태로 변환하는 처리 혹은 그 처리 방식을 말한다. 이메일 등의 전송, 동영상이나 이미지 영역에서 많이 사용되며, 반대말은 디코딩(decoding)이다. 기존 ASCII 코드는 시스템간 데이터를 전달하기에 안전하지 않다. 모든 binary 데이터가 ASCII 코드에 포함되지 않으므로 제대로 읽지 못한다. 반면 Base64는 ASCII 중 제어문자와 일부 특수문자를 제외한 안전한 출력 문자만 이용하므로 데이터 전달에 더 적합하다. Base64는 어떤 문자와 기호를 쓰느냐에 따라 다양한 변종이 있지만, 대부분 처음 62개는 알파벳 A-Z, a-z와 0-9를 사용하며 마지막 두 개를 어떤 기호를 쓰느냐의 차이만 있다. Base64 표준에서는 마지막 62, 63번 글자가 +, / 이다. 이 문자들을 전송하게 되면 정상적으로 전송되지 않는 문제가 발생한다. 따라서 이러한 원문의 오류를 막기 위해서 등장한것이 RFC 4648의 base64url이다. base64url에서는 62번, 63번 글자가 각각 -, _이다. ","date":"2022-04-17","objectID":"/base64-encoding/:0:0","tags":["base64","ascii"],"title":"Base64 Encoding","uri":"/base64-encoding/"},{"categories":["etc"],"content":"Base64 변환과정 base64 인코딩 과정은 먼저 24bit의 buffer를 생성하여 위쪽(MSB)부터 바이트 데이터를 넣은 뒤, 버퍼의 오른쪽부터 6bit 단위로 잘라 Base64 테이블의 ASCII 문자로 변환한다. 다시 말해, 원본 문자열\u003e ASCII binary\u003e 6bit로 cut\u003e base64 encodeing 순서가 된다. 예를 들어, Man이라는 세 글자 단어를 Base64로 인코딩한다면 Man \u003e 77 97 110 \u003e 01001101 01100001 01101110 \u003e TWFu로 변환이 된다. ","date":"2022-04-17","objectID":"/base64-encoding/:1:0","tags":["base64","ascii"],"title":"Base64 Encoding","uri":"/base64-encoding/"},{"categories":["etc"],"content":"Base64 사용 이유 Base64는 HTML 또는 Email과 같이 문자를 위한 Media에 Binary Data를 포함해야 될 필요가 있을 때, 포함된 Binary Data가 시스템 독립적으로 동일하게 전송 또는 저장되는 것을 보장하기 위해 사용한다. Base64로 인코딩을 하게 되면 6bit당 2bit의 Overhead가 발생하여 전송해야 될 데이터의 크기가 약 33% 정도 늘어난다. 33%나 데이터의 크기가 증가하고, 인코딩과 디코딩의 추가 연산까지 필요한데 Base64 인코딩을 사용하는 이유는 통신과정에서 바이너리 데이터의 손실을 막기 위함이다. 플랫폼 독립적으로 Binary Data(이미지나 오디오)를 전송할 필요가 있을 때, ASCII로 Encoding 하여 전송하게 되면 여러 가지 문제가 발생할 수 있다. 대표적인 문제는 다음과 같다. ASCII는 7 bits Encoding인데 나머지 1bit를 처리하는 방식이 시스템 별로 상이하다. 일부 제어 문자 (e.g. Line ending)의 경우 시스템 별로 다른 코드값을 가진다. 위와 같은 문제로 ASCII는 시스템 간 데이터를 전달하기에 안전하지 않다. Base64는 ASCII 중 제어 문자와 일부 특수문자를 제외한 64개의 안전한 출력 문자만 사용한다. 안전한 출력 문자란 문자 코드에 영향을 받지 않는 공통 ASCII를 의미한다. ","date":"2022-04-17","objectID":"/base64-encoding/:2:0","tags":["base64","ascii"],"title":"Base64 Encoding","uri":"/base64-encoding/"},{"categories":["etc"],"content":"참고 https://devuna.tistory.com/41 ","date":"2022-04-17","objectID":"/base64-encoding/:3:0","tags":["base64","ascii"],"title":"Base64 Encoding","uri":"/base64-encoding/"},{"categories":["web"],"content":"HTTP와 HTTPS의 가장 큰 차이점은 SSL 인증서이다. SSL인증서는 클라이언트와 서버간의 통신을 공인된 제 3차 업체(CA)가 보증해주는 전자화된 문서이다. SSL 인증서는 사용자가 사이트에서 제공하는 정보를 암호화한다. 암호화되어 전송되는 데이터는 중간에 누가 훔치거나 조작하려해도 암호화 되어있어서 해독할 수 없다. HTTPS 방식은 공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 함께 사용한다. 데이터를 대칭키 방식으로 암복호화하고, 공개키 방식으로 대칭키를 전달한다. ","date":"2022-04-15","objectID":"/https/:0:0","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"HTTPS의 동작과정 ","date":"2022-04-15","objectID":"/https/:1:0","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색 Client Hello : 클라이언트가 서버에게 전송할 데이터 클라이언트 측에서 생성한 랜덤 데이터 클라이언트가 사용할 수 있는 암호화 방식 이전에 이미 Handshaking 기록이 있다면 자원 절약을 위해 기존 세션을 재활용하기 위한 세션 아이디 Server Hello : Client Hello에 대한 응답으로 전송할 데이터 서버 측에서 생성한 랜덤 데이터 서버가 선택한 클라이언트의 암호화 방식 SSL 인증서 Client 인증 확인 서버로부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인하고, 목록에 있다면 CA 공개키로 인증서 복호화 클라이언트, 서버 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭키 암호화에 사용할 키) pre master secret 값을 공개키 방식으로 서버 전달(공개키는 서버로부터 받은 인증서에 포함) Server 인증 확인 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료) Handshaking 종료 ","date":"2022-04-15","objectID":"/https/:1:1","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"데이터 전송 서버와 클라이언트는 session key를 활용해 데이터를 암복호화하여 데이터 송수신 ","date":"2022-04-15","objectID":"/https/:1:2","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"연결 종료 및 session key 폐기 ","date":"2022-04-15","objectID":"/https/:1:3","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"참고 https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP%EC%99%80-HTTPS-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95 ","date":"2022-04-15","objectID":"/https/:2:0","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["docker/kubernetes"],"content":"Dockerfile 포맷 하나의 Dockerfile은 기본적으로 다음과 같은 구조를 가진 여러 개의 명령문으로 구성되어 있다. # 주석(Comment) 명령어(INSTRUCTION) 인자(arguments) 각 명령문은 명령어로 시작하고 여러 개의 인자가 따라올 수 있으며, 해당 명령문에 대한 주석도 달 수 있다. 인자와 구분이 쉽도록 명령어는 모두 영문 대문자로 써주는 것이 관례이다. ","date":"2022-04-12","objectID":"/dockerfile-%EB%AA%85%EB%A0%B9%EC%96%B4/:1:0","tags":["docker"],"title":"Dockerfile 명령어","uri":"/dockerfile-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"Dockerfile 명령문 FROM 명령문 FROM \u003c이미지\u003e FROM \u003c이미지\u003e:\u003c태그\u003e 하나의 Docker 이미지는 base 이미지부터 시작해서 기존 이미지위에 새로운 이미지를 중첩해서 여러 단계의 이미지 층(layer)을 쌓아가며 만들어진다. FROM 명령문은 이 base 이미지를 지정해주기 위해서 사용하는데, 보통 Dockerfile 내에서 최상단에 위치한다. base 이미지는 일반적으로 Docker Hub와 같은 Docker repository에 올려놓은 잘 알려진 공개 이미지인 경우가 많다. WORKDIR 명령문 WORKDIR \u003c이동할 경로\u003e WORKDIR 명령문은 쉘(shell)의 cd 명령문처럼 컨테이너 상에서 작업 디텍토리로 전환을 위해서 사용한다. WORKDIR 명령문으로 작업 디렉터리를 전환하면 그 이후에 등장하는 모든 RUN, CMD, ENTRYPOINT, COPY, ADD 명령문은 해당 디렉터리를 기준으로 실행된다. ENTRYPOINT 명령문 ENTRYPOINT [\"\u003c커맨드\u003e\", \"\u003c파라미터1\u003e\", \"\u003c파라미터2\u003e\"] ENTRYPOINT \u003c전체 커맨드\u003e ENTRYPOINT 명령문은 이미지를 컨테이너로 띄울 때 항상 실행되야 하는 커맨드를 지정할 때 사용한다. ENTRYPOINT 명령문은 Docker 이미지를 마치 하나의 실행 파일처럼 사용할 때 유용한다. 왜냐하면 컨테이너가 뜰 때 ENTRYPOINT 명령문으로 지정된 커맨드가 실행되고, 이 커맨드로 실행된 프로세스가 죽을 때, 컨테이너도 따라서 종료되기 때문이다. RUN 명령문 RUN [\"\u003c커맨드\u003e\", \"\u003c파라미터1\u003e\", \"\u003c파라미터2\u003e\"] RUN \u003c전체 커맨드\u003e RUN 명령문은 마치 쉘(shell)에서 커맨드를 실행하는 것 처럼 이미지 빌드 과정에서 필요한 커맨드를 실행하기 위해서 사용한다. 쉘(shell)을 통해 거의 못하는 작업이 없는 것 처럼 RUN 명령문으로 할 수 있는 작업은 무궁무진하지만 보통 이미지 안에 특정 소트트웨어를 설치하기 위해서 많이 사용된다. CMD 명령문 CMD [\"\u003c커맨드\u003e\",\"\u003c파라미터1\u003e\",\"\u003c파라미터2\u003e\"] CMD [\"\u003c파라미터1\u003e\",\"\u003c파라미터2\u003e\"] CMD \u003c전체 커맨드\u003e CMD 명령문은 해당 이미지를 컨테이너로 띄울 때 디폴트로 실행할 커맨드나, ENTRYPOINT 명령문으로 지정된 커맨드에 디폴트로 넘길 파라미터를 지정할 때 사용한다. CMD 명령문은 많은 경우, ENTRYPOINT 명령문과 함께 사용하게 되는데, ENTRYPOINT 명령문으로는 커맨드를 지정하고, CMD 명령문으로 디폴트 파리미터를 지정해주면 매우 유연하게 이미지를 실행할 수 있게 된다. CMD 명령문과 RUN 명령문이 햇갈릴 수가 있는데, RUN 명령문은 이미지 빌드 시 항상 실행되며, 한 Dockerfile에 여러 개의 RUN 명령문을 선언할 수 있다. 반면에, CMD 명령문은 이미지를 continaer로 띄울 때 딱 한 번 실행 기회를 가지게 되며, 이 기회마저도 docker run 커맨드에 인자를 넘길 경우 상실하게 된다. EXPOSE 명령문 EXPOSE \u003c포트\u003e EXPOSE \u003c포트\u003e/\u003c프로토콜\u003e EXPOSE 명령문은 네트워크 상에서 컨테이너로 들어오는 트래픽(traffic)을 리스닝(listening)하는 포트와 프로토콜를 지정하기 위해서 사용한다. 프로토콜은 TCP와 UDP 중 선택할 수 있는데 지정하지 않으면 TCP가 기본값으로 사용된다. 여기서 주의할 점은 EXPOSE 명령문으로 지정된 포트는 해당 컨테이너의 내부에서만 유효하며, 호스트(host) 컴퓨터에서는 이 포트를 바로 접근을 할 수 있는 것은 아니라는 것이다. 호스트 컴퓨터로부터 해당 포트로의 접근을 허용하려면, docker run 커맨드를 -p 옵션을 통해 호스트 컴퓨터의 특정 포트를 포워딩(forwarding)시켜줘야 한다. COPY 명령문 COPY \u003csrc\u003e... \u003cdest\u003e COPY [\"\u003csrc\u003e\",... \"\u003cdest\u003e\"] COPY 명령문은 호스트 컴퓨터에 있는 디렉터리나 파일을 Docker 이미지의 파일 시스템으로 복사하기 위해서 사용한다. 절대 경로와 상대 경로를 모두 지원하며, 상대 경로를 사용할 때는 이 전에 등장하는 WORKDIR 명령문으로 작업 디렉터리를 어디로 전환을 했는지 고려해야 한다. ENV 명령문 ENV \u003c키\u003e \u003c값\u003e ENV \u003c키\u003e=\u003c값\u003e ENV 명령문은 환경 변수를 설정하기 위해서 사용한다. ENV 명령문으로 설정된 환경 변수는 이미지 빌드 시에도 사용됨은 물론이고, 해당 컨테이너에서 돌아가는 애플리케이션도 접근할 수 있다. ARG 명령문 ARG \u003c이름\u003e ARG \u003c이름\u003e=\u003c기본값\u003e ARG 명령문은 docker build 커맨드로 이미지를 빌드 시, –build-arg 옵션을 통해 넘길 수 있는 인자를 정의하기 위해 사용한다. ","date":"2022-04-12","objectID":"/dockerfile-%EB%AA%85%EB%A0%B9%EC%96%B4/:2:0","tags":["docker"],"title":"Dockerfile 명령어","uri":"/dockerfile-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"참고 https://www.youtube.com/watch?v=qexw7wbwkFM\u0026list=PL93mKxaRDidGMzIllhYKx1d6aMg6_5wW3\u0026index=15\u0026pp=iAQB https://www.daleseo.com/dockerfile/ ","date":"2022-04-12","objectID":"/dockerfile-%EB%AA%85%EB%A0%B9%EC%96%B4/:3:0","tags":["docker"],"title":"Dockerfile 명령어","uri":"/dockerfile-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"Docker build 명령어 docker build -t 이미지명[:태그명] . -t 또는 –tag 옵션은 새로 생성할 이미지의 이름을 지정할 때 사용하는 옵션이다. -t 옵션 뒤에 이미지명:태그를 적는다. 마지막에 있는 구둣점(.)은 도커파일(Dockerfile)이 현재 디렉토리에 있다는 뜻이다. ","date":"2022-04-11","objectID":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/:1:0","tags":["docker"],"title":"도커 명령어","uri":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"Docker run 명령어 ","date":"2022-04-11","objectID":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/:2:0","tags":["docker"],"title":"도커 명령어","uri":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"이미지가 OS일 경우 이미지를 백그라운드 인터렉션 모드로 실행 docker run -dit 이미지명 bash 컨테이너에 접속 docker attach 컨테이너아이디 ","date":"2022-04-11","objectID":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/:2:1","tags":["docker"],"title":"도커 명령어","uri":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"이미지가 Program일 경우 이미지를 백그라운드로 실행 docker run -d 이미지명 컨테이너에 인터렉션 모드로 접속 docker exec -it 컨테이너아이디 bash ","date":"2022-04-11","objectID":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/:2:2","tags":["docker"],"title":"도커 명령어","uri":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"Docker run 옵션 종류 옵션 설명 -i, –interactive - 표준 입력(stdin)을 활성화하며, 컨테이너와 연결(attach)되어 있지 않더라도 표준 입력을 유지한다. - 보통 이 옵션을 사용하여 Bash 에 명령을 입력한다. -t, –tty - TTY 모드(pseudo-TTY)를 사용한다. - Bash를 사용하려면 이 옵션을 설정해야 한다. - 이 옵션을 설정하지 않으면 명령을 입력할 수는 있지만, 셸이 표시되지 않는다. –name - 컨테이너 이름을 설정한다. -d, –detach - Detached 모드이다. - 보통 데몬 모드라고 부르며, 컨테이너가 백그라운드로 실행된다. -p, –publish - 호스트와 컨테이너의 포트를 연결한다. (포트포워딩) - \u003c호스트 포트\u003e:\u003c컨테이너 포트\u003e - -p 80:80 –privileged - 컨테이너 안에서 호스트의 리눅스 커널 기능(Capability)을 모두 사용한다. - 호스트의 주요 자원에 접근할 수 있다. –rm - 프로세스 종료시 컨테이너 자동 제거 –restart - 컨테이너 종료 시, 재시작 정책을 설정한다. - –restart=“always” -v, –volume - 데이터 볼륨을 설정한다. - 호스트와 컨테이너의 디렉토리를 연결하여, 파일을 컨테이너에 저장하지 않고 호스트에 바로 저장한다. (마운트) -u, –user - 컨테이너가 실행될 리눅스 사용자 계정 이름 또는 UID를 설정한다. - –user root -e, –env - 컨테이너 내에서 사용할 환경 변수를 설정한다. - 보통 설정 값이나 비밀번호를 전달할 때 사용한다. - -e GRANT_SUDO=yes –link - 컨테이너끼리 연결한다. - [컨테이너명 : 별칭] - –link=“db:db” -h, –hostname - 컨테이너의 호스트 이름을 설정한다. -w, –workdir - 컨테이너 안의 프로세스가 실행될 디렉터리를 설정한다. -a, –attach - 컨테이너에 표준 입력(stdin), 표준 출력(stdout), 표준 에러(stderr) 를 연결한다. -c, –cpu-shares - CPU 자원 분배 설정이다. - 기본 값은 1024이며, 각 값은 상대적으로 적용된다. -m, –memory - 메모리 한계를 설정한다. - \u003c숫자\u003e\u003c단위\u003e 형식이며 단위는 b, k, m, g 를 사용할 수 있다. - –memory=“100000b” –gpus - 컨테이너에서 호스트의 NVIDIA GPU 를 사용할 수 있도록 설정한다. - 호스트는 NVIDIA GPU 가 장착 된 Linux 서버여야하며, NVIDIA driver 가 설치되어 있어야하고, docker 19.03.5 버전 이상이어야한다. –security-opt - SELinux, AppArmor 옵션을 설정한다. - –security-opt=“label:level:TopSecret” ","date":"2022-04-11","objectID":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/:2:3","tags":["docker"],"title":"도커 명령어","uri":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"Docker push 명령어 docker image push \u003cDocker Hub 사용자\u003e/이미지명[:태그명] ","date":"2022-04-11","objectID":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/:3:0","tags":["docker"],"title":"도커 명령어","uri":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"참고 https://www.youtube.com/watch?v=3VM_-VMk9Ec\u0026list=PL93mKxaRDidGMzIllhYKx1d6aMg6_5wW3\u0026index=10\u0026pp=iAQB https://velog.io/@anjinwoong/Docker-Dockerfile-%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EA%B5%AC%EC%84%B1-%EA%B4%80%EB%A6%AC-1 ","date":"2022-04-11","objectID":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/:4:0","tags":["docker"],"title":"도커 명령어","uri":"/%EB%8F%84%EC%BB%A4-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"categories":["docker/kubernetes"],"content":"VM vs 컨테이너 ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:1:0","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["docker/kubernetes"],"content":"VM 하드웨어 인프라스트러처 위에 VMWare나 VirtualBox와 같은 HyperVisor 소프트웨어를 이용해서 각각의 가상의 머신을 만들 수 있다. 한 운영체제 위에서 동일한 어플리케이션을 각각의 고립된 다른 환경에서 구동하기 위해서는 가상 머신을 이용해서 어플리케이션을 구동해야 했다. 이 가상 머신은 각각의운영체제를 포함하고 있기 때문에 맥이라는 OS 위에서 가상머신을 이용하면 윈도와 리눅스를 동시에 구동할 수 있다. 고립된 환경에서 애플리케이션을 구동하기 위해서 VM을 사용하면 운영 체제를 포함하고 있기 때문에 굉장히 무겁고 그리고 시작하는 데도 오래 걸리고 또 컴퓨터 운영체제 인프라스트럭처 리소스를 많이 잡아먹는 범인이 될 수도 있다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:1:1","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["docker/kubernetes"],"content":"컨테이너 VM에서 조금 경량화된 컨셉이 컨테이너이다. 하드웨어에 설치된 운영체제 즉 호스트 OS에서 컨테이너 엔진이라는 소프트웨어를 설치만 하면 개별적인 컨테이너를 만들어서 이 각각의 어플리케이션을 고립된 환경에서 구동할 수 있게 해준다. 가상 머신은 운영체제를 포함했다면 이 컨테이너는 운영체제를 포함하지 않고 이 컨테이너 엔진의 설치된 호스트 OS를 공유한다. 컨테이너가 구동되기 위해서는 이 컨테이너 엔진이 필요하고 이 컨테이너 엔진이 호스트 OS에 접근해서 필요한 것들을 처리해 준다고 볼 수 있다. 그리고 이 컨테이너 엔진 중에 가장 많이 사랑받고 이용되는 것이 바로 도커이다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:1:2","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["docker/kubernetes"],"content":"도커의 구성요소 ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:2:0","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["docker/kubernetes"],"content":"도커파일 컨테이너를 만들기 위해서는 먼저 도커 파일을 만들어야 하고 이걸 이용해서 이미지를 만들어서 컨테이너를 구동할 수 있다. 도커 파일은 컨테이너를 어떻게 만들어야 하는지 설명서 또는 요리로 치면 레시피와 같다. 우리 어플리케이션을 구동하기 위해서 꼭 필요한 일들은 무엇이 있는지 어떤 프레임워크나 라이브러리를 설치해야 되는지 외부 의존성에 대해서 명시할 수 있다. 그리고 필요한 환경 변수에 대해서 설정할 수도 있고 어떻게 구동해야하는지 스크립트도 포함 할 수 있다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:2:1","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["docker/kubernetes"],"content":"도커이미지 도커 파일을 이용해서 이미지를 만들 수 있다. 이 이미지 안에는 우리 어플리케이션을 실행하는 데 필요한 코드 런타임 환경 시스템, 툴 시스템, 라이브러리 모든 세팅들이 포함되어 있다. 한마디로 얘기하면 실행되고 있는 우리 어플리케이션의 상태를 캡쳐해서 이미지로 만들어 둔다 라고 생각할 수 있다. 이렇게 만들어진 이미지는 변경이 불가능하다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:2:2","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["docker/kubernetes"],"content":"컨테이너 컨테이너는 샌드박스 처럼 우리가 잘 캡쳐해 둔 어플리케이션의 이미지를 고립된 환경에서 개별적인 그 파일 시스템 안에서 실행할 수 있는 것을 말한다. 각각의 컨테이너는 만들어진 인스턴스 라고 볼 수 있다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:2:3","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["docker/kubernetes"],"content":"참고 https://youtu.be/LXJhA3VWXFA ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:3:0","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["etc"],"content":"랜카드 랜카드는 네트워크를 구성하기 위한 가장 기본적인 장비이다. 랜카드는 유저의 데이터를 케이블에 실어서 허브나 스위치, 혹은 라우터 등으로 전달해주고 자신에게 온 데이터를 CPU에게 전달해주는 역할을 한다. 랜카드라고 하면 ‘랜에 접속하기 위한 카드처럼 생긴 것이다’라고 생각하면 딱 맞다. 랜카드는 데스크톱, 노트북, 프린터 등 네트워크 연결이 필요한 장비에 꽂아서 사용한다. 요즘은 랜카드를 직접 보기 힘든데, 왜냐하면 랜카드는 대부분 컴퓨터 안에 설치되어 제작되기 때문이다. ","date":"2022-04-08","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/:1:0","tags":["lan-card","hub","switch","router"],"title":"네트워크 장비","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/"},{"categories":["etc"],"content":"허브 허브(Hub)는 직사각형의 상자에 구멍이 뚫려 있는 모양으로 되어 있다. 랜카드가 설치된 각각의 PC들은 케이블을 타고 허브로 연결된다. 그리고 같은 허브에 연결된 PC 끼리는 서로 통신이 가능하다. 허브는 아무런 세팅이 없어도 통신에 지장이 없다. ","date":"2022-04-08","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/:2:0","tags":["lan-card","hub","switch","router"],"title":"네트워크 장비","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/"},{"categories":["etc"],"content":"허브에서의 데이터 전송 예시 1번 PC가 데이터를 허브를 통해 전송하면, 허브는 데이터가 들어온 1번 포트를 제외하고 나머지 포트로 그 데이터를 보내준다. 3~5번 PC들의 랜카드는 들어온 프레임의 목적지 맥 어드레스를 자신의 맥 어드레스와 비교한 후 자신의 것이 아니라면 무시한다. 2번 PC의 랜카드는 들어온 프레임의 목적지 맥 어드레스가 자신의 것과 동일하기 때문에 받아들이고, CPU에게 이 데이터를 처리해 줄 것을 요청한다. ","date":"2022-04-08","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/:2:1","tags":["lan-card","hub","switch","router"],"title":"네트워크 장비","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/"},{"categories":["etc"],"content":"스위치 PC들이 데이터를 동시에 보내려다 부딪히는 경우를 충돌(콜리전, Collision)이 발생했다고 한다. 허브에 연결된 PC들은 하나의 콜리전 도메인(Collision Domain)안에 있기 때문에 어느 한 순간에는 한 PC만 데이터를 보낼 수 있다. 콜리전 도메인이 너무 커지게 되면 콜리전에 의해 영향을 받는 PC가 너무 많아지면서 통신의 속도가 점점 떨어지게 된다. 스위치(Switch)는 콜리전 도메인을 작게 분할하여 데이터 전송 시 충돌 가능성을 낮춰주는 장비이다. 스위치는 예를 들어 1번 포트에 연결된 PC가 2번 포트에 연결된 PC와 데이터를 주고 받는 동안에도 3번 포트에 연결된 PC와 4번 포트에 연결된 PC가 서로 데이터를 주고받을 수 있게 한다. 이렇게 포트별로 콜리전 도메인을 나누기때문에, 통신이 일어나면 나머지 모든 PC들은 기다려야 하는 허브와 달리 다른 PC들도 동시 통신이 가능하며, 이것이 스위치와 허브의 가장 큰 차이이다. ","date":"2022-04-08","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/:3:0","tags":["lan-card","hub","switch","router"],"title":"네트워크 장비","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/"},{"categories":["etc"],"content":"라우터 허브와 스위치로 장비가 연결되면, 소규모 네트워크 영역에서 통신할 수 있다. 그러면 대규모 네트워크에서 통신할 때는 라우터를 사용할 수 있다. 라우터는 서로 다른 네트워크를 연결해주고 데이터가 가장 빠르고 효율적인 길을 스스로 찾아 안내해주는 장비이다. 가정이나 소형오피스에서 사용하는 공유기도 소형 라우터이다. 인터넷은 여러 네트워크의 연결로 구성되어 있어서 목적지까지 가는 경로가 여럿 있을 수 있다. 라우터는 데이터 패킷이 목적지까지 갈 수 있는 여러 경로를 검사하고 어떤 길로 가는 것이 가장 적합한지를 결정하며, 이러한 행위를 라우팅이라고 한다. 라우터는 경로설정을 할 수 있도록 표 형태로 정보를 관리하는데, 이를 라우팅테이블이라고 한다. 이 테이블에는 목적지 IP주소에 대한 최적의 경로가 나와 있다. ","date":"2022-04-08","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/:4:0","tags":["lan-card","hub","switch","router"],"title":"네트워크 장비","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/"},{"categories":["etc"],"content":"참고 개발자가 되기 위해 꼭 알아야 하는 IT 용어, 비제이리퍼블릭 ","date":"2022-04-08","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/:5:0","tags":["lan-card","hub","switch","router"],"title":"네트워크 장비","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/"},{"categories":["etc"],"content":"Static Linking (정적 링킹) 정적 링킹이란 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하는 방식을 말한다. 5개의 프로그램에서 A라는 외부 함수를 이용하는데 이때 정적 링킹 방식을 사용하면 5개의 프로그램의 실행 가능한 목적파일 각각에 A의 정보가 담긴다. 즉, 중복이 발생한다. 따라서 정적 링킹으로 만들어진 프로그램은 크기가 크고 메모리 효율이 좋지 않다. 정적 링킹을 이용하면, 동적 링킹 라이브러리를 사용하는 프로그램보다 빠르다. 또한 정적 링킹 프로그램에서 모든 코드는 하나의 실행 모듈에 담기기 때문에 compatibility issues 즉, 불일치에 대한 걱정을 하지 않아도 된다. 그러나 함수에 변화가 생길 경우 그 변화를 적용하기 위해서 다시 컴파일하여 다시 링킹을 해야만 한다. ","date":"2022-04-08","objectID":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/:1:0","tags":["linking"],"title":"정적 링킹, 동적 링킹","uri":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/"},{"categories":["etc"],"content":"Dynamic Linking (동적 링킹) 동적 링킹이란 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하지 않고 해당 모듈의 주소만을 가지고 있다가, 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것을 들고 오는 방식이다. 런타임에 운영체제에 의하여 이루어진다. 동적 링킹 방식을 이용하면 5개의 프로그램에서 A라는 외부 함수를 이용한다고 해도 함수의 정보는 하나만 있으면 된다. 즉, 메모리와 디스크 공간을 더 아낄 수 있다. 동적 링킹을 이용하면, A라는 함수에 변화가 생겨도 그 변화를 적용하기 위해 다시 컴파일하여 다시 링킹할 필요가 없다. 실행 가능한 목적파일을 만들 때 A에 관한 정보를 그냥 복사해온 것이 아니라 A가 있는 곳의 주소를 담았기 때문이다. 그저 가리키는 곳을 따라가면 변화된 A가 있다. 정적 링킹이 사용된 프로그램이 실행을 위해 메모리에 로드되는 데 일정한 시간이 걸리는 반면, 동적 링킹 방식이 사용된 프로그램은, 동적 라이브러리가 메모리에 이미 존재하는 경우 로드되는 시간을 단축시킬 수 있다. 하지만 동적 링킹 방식은 정적 링킹 방식보다 느리다. 매번 주소를 따라가야하는 오버헤드가 존재하기 때문이다. 동적 링킹 방식은 compatibility issues 즉, 불일치에 대한 문제를 고려해야 한다. 왜냐하면 동적 링킹 방식은 불일치가 존재할 수 있기 때문이다. 예를 들어 어떤 프로그램에서 A라는 함수를 동적 링킹 방식으로 사용하고 있을 때, A라는 함수가 시스템에서 제거되면 이는 불일치 상황이다. 해당 프로그램의 실행 가능 목적파일에는 A의 주소가 있어서 마치 A가 존재하는 것처럼 움직이지만 실제 A는 시스템에 더이상 존재하지 않기 때문이다. 따라서 이 프로그램은 제대로 실행될 수 없다. ","date":"2022-04-08","objectID":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/:2:0","tags":["linking"],"title":"정적 링킹, 동적 링킹","uri":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/"},{"categories":["etc"],"content":"확장자별 라이브러리 구분 .a : 리눅스 / 정적 라이브러리 .so : 리눅스 / 동적 라이브러리 .lib : 윈도우 / 정적 라이브러리 .dll : 윈도우 / 동적 라이브러리 윈도우의 동적 라이브러리 DLL을 구현하고 컴파일하고 나면 Static library와는 다르게 output file이 2개가 생성된다. 하나는 *.lib 파일이고 하나는 *.dll 파일이다. Static library의 *.lib 파일은 라이브러리 전체 코드를 포함하는 바이너리이며, DLL의 *.lib 파일은 DLL이 제공하고자 하는 함수 정보(함수명)을 가지는 정보 파일이다. 링크 단계에서 실행 바이너리의 *.obj 파일들과 DLL의 *.lib 파일을 함께 링크하여 이 정보를 토대로 runtime에 DLL의 함수 코드를 참조한다. 이를 암시적 링킹(implicit linking)이라고 한다. 즉 *.lib 파일은 링크시 필요하고, *.dll 파일은 실행시 필요하다. ","date":"2022-04-08","objectID":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/:3:0","tags":["linking"],"title":"정적 링킹, 동적 링킹","uri":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/"},{"categories":["etc"],"content":"참고 https://live-everyday.tistory.com/69 https://goodgid.github.io/Static-VS-Dynamic-Libray/ ","date":"2022-04-08","objectID":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/:4:0","tags":["linking"],"title":"정적 링킹, 동적 링킹","uri":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/"},{"categories":["DB"],"content":"트랜잭션은 데이터베이스 상태를 변환시키는 하나의 논리적 기능 수행 단위이다. 즉, 한 번에 처리되어야 할 일련의 작업을 말한다. 트랜잭션으로 원하는 작업의 단위를 정하게 되면 작업을 수행하는 도중 문제가 발생하였을 때 이전에 진행되었던 작업이 롤백된다. 모든 작업을 안정적으로 끝마친 후에 실제 데이터베이스에 반영할 수 있다. 트랜잭션의 범위는 커넥션 기준이다. 스프링 프레임워크의 트랜잭션 처리는 메소드 간에 커넥션 객체를 전달하지 않아도 한 트랜잭션으로 묶어서 실행하도록 돕는다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:0:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"트랜잭션의 성질 ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"Atomicity(원자성) 하나의 트랜잭션이 더 작게 나눌 수 없는 최소의 단위라는 뜻이다. 트랜잭션이 모두 반영되거나, 아니면 전혀 반영되지 않아야 하는 특징을 나타낸다. 계좌이체를 하는 경우를 생각해보자. 송금하는 도중에 문제가 발생하여 돈을 받아야 하는 사람에게 제대로 전달되지 않았다. 하지만 돈을 보내는 사람에게서는 이미 돈이 빠져나갔다면 큰 문제가 발생하게 될 것이다. 계좌이체 도중 문제가 발생하게 되면 송금하기 이전상태를 유지하게 되는 것을 원자성이라 볼 수 있다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:1","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"Consistency(일관성) 트랜잭션이 완료된 결과값이 일관적인 데이터베이스 상태를 유지하는 것을 말한다. 사실 이 말만으로는 잘 이해가 되지 않는다. 예를 들면, 고객 정보가 담겨있는 데이터베이스에 새로운 고객이 등록되면 그 데이터베이스를 참조하는 다른 하위 계층의 데이터베이스도 같은 고객의 세부 정보를 가져와야 한다. 또는 모든 계좌의 돈은 0원 이상이어야 한다. 라는 무결성 제약이 있다면 이를 위반하는 트랜잭션은 모두 중단되어야 한다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:2","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"Isolation(독립성) 트랜잭션이 수행되고 있을 때, 다른 트랜잭션의 연산작업이 중간에 끼어들어 기존 작업에 영향을 주지 못하도록 하는 것을 말한다. 독립성이 보장된다면 계좌 이체작업을 진행하고 있는 도중에 계좌의 잔액을 조회한다 거나 하는 작업을 동시에 수행할 수 없게 되는 것이다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:3","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"Durability(지속성) 트랜잭션을 성공한 후 데이터베이스에 반영된 것은 영원히 반영되어야 한다는 것을 의미한다. 시스템에 문제가 발생하거나 종료되더라도 데이터베이스에 반영된 값은 그대로 유지되어야 한다. 은행에 시스템이 마비되었다가 재개되었을 때 계좌의 금액이 바뀌게 된다면 큰 문제가 될 것이다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:4","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"트랜잭션 격리 수준 여러 클라이언트가 같은 데이터에 접근할 때 문제가 발생할 수 있다. 이러한 상황을 경쟁상태(Race Condition)라고 한다. 이 때 트랜잭션을 격리해서 다른 트랜재션이 영향을 주지 못하게 해야한다. Isolation Level 설명 Dirty Read Non-Repeatable Read Phantom Read 고립성(안정성) 동시성 Read Uncommitted 커밋되지 않은 데이터도 읽을 수 있다. O O O 낮다 높다 Read Committed 커밋된 정보만 읽는다. X O O 중간 중간 Repeatable Read 하나의 트랜잭션에서는 하나의 스냅샷만 사용한다. X X O 중간 중간 Serializable Read 시에 DML 작업이 동시에 진행될 수 없다. X X X 높다 낮다 ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"READ UNCOMMITTED 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.(Dirty Read) 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장한다. Dirty Read commit되지 않은 정보를 볼 수 있는 현상을 말하는 것으로 Read Uncommitted Isolation Level일 때 발생하는 Read 현상이다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:1","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"READ COMMITTED 커밋되지 않은 데이터 읽기 (dirty read), 커밋되지 않은 데이터 덮어쓰기 (dirty write) 문제를 해결한다. 커밋된 데이터만 읽기: 다른 트랜잭션이 쓰고 있으면 대기 했다가 읽게 됨 커밋된 데이터만 덮어쓰기 : 같은 데이터를 수정한 트랜잭션이 끝날 때까지 대기 하나의 트랜잭션에서 같은 쿼리를 두번 실행하여 데이터를 조회할때 값이 달라질 수 있다.(Non-Repeatable Read) 커밋된 정보를 어떤 제약 없이 읽을 수 있기 때문에 여러 스냅샷 버젼으로 읽는 것이 가능하기 때문이다. Non-Repeatable Read 한 트랜잭션안에서 같은 쿼리를 두번 실행 했을 때, 다른 값이 나오는 Read 현상을 말하는 것으로, 하나의 트랜잭션안에서 여러 스냅샷이 사용되는 경우를 말한다. Read-Committed 이하의 Isolation Level에서 나오는 현상이다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:2","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"REPEATABLE READ 다른 사용자가 커밋 이후에 데이터를 조회할 경우 데이터가 변경되는 문제(read skew)를 해결한다. Undo 공간에 백업해두고 실제 레코드 값을 변경한다. 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제한다. Undo에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다. 하나의 트랜잭션 안에서 하나의 스냅샨 버젼으로만 동작하기 때문에 같은 쿼리를 두번 실행한다 할지라도 동일한 값이 유지된다. SQL 표준 트랜잭션 격리 수준에 따르면 Phantom Read를 막지 못한다. 그러나 MySQL InnoDB 엔진의 경우 consistent read를 사용하기 때문에 REPEATABLE READ 레벨임에도 불구하고 phantom read가 발생하지 않는다. Phantom Read 트랜잭션 안에서 첫번째 쿼리 수행 결과와 두번째 쿼리 수행 결과가 다른것을 나타낸다. 영향을 받는 행 자체가 업데이트되지 않았더라도 행이 추가되거나 삭제된 경우 다른 결과를 반환한다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:3","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"SERIALIZABLE 한 트랜잭션의 결과가 다른 트랜잭션의 퀴리 결과에 영향을 주는 문제(같은 데이터를 쓰지 않지만 실제로는 경쟁 상태)를 해결한다. 인덱스 잠금이나 조건 기반 잠금 등을 사용한다. 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준이다. 성능 측면에서는 동시 처리성능이 가장 낮다. 데이터의 안정성에 위배하는 어떤 것도 발생할 수 없을 정도로 높은 고립성을 가지고 있다. 하지만, 그로 인해 동시성이 많이 떨어진다. 그래서, 하나의 데이터영역에 READ가 발생할 때 어떤 DML도 발생할 수 없어서 많은 문제점을 야기시킨다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:4","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"각 DBMS의 기본 트랜잭션 격리수준 대부분의 RDBMS는 Read Committed나 Repeatable Read로 고립성을 유지하여 트랜잭션을 지원한다. mysql : Repeable-read postgres : Read Committed oracle : Read Committed mongodb : Read uncommitted ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:3:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"참고 https://www.youtube.com/watch?v=poyjLx-LOEU https://happy-coding-day.tistory.com/190 https://mysqldba.tistory.com/334 ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:4:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["system"],"content":"데드락이란 서로 요청한 자원이 이미 상대방에게 점유되어 다음 명령을 처리 못하는 상태(교착상태)이다. 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다. ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:0:0","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"발생 조건 데드락은 4가지 조건을 모두 만족해야 발생하게 되는데, 하나라도 조건을 만족하지 않으면 문제를 해결할 수 있는 상황이다. 그 조건들은 아래와 같다. 상호 배제 (Mutual Exclusion) 자원은 한 번에 한 프로세스만 사용할 수 있음. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함. 점유 대기 (Hold and wait) 최소한 하나의 자원을 점유한 채로 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함 비선점 (No Preemption) 이미 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 순 없음 순환 대기 (Circular wait) 대기중인 프로세스 집합에서 순환 형태로 자원을 대기하고 있어야 함 ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:1:0","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"데드락을 해결하는 방안 데드락 상황을 해결하기 위한 방안으로는 예방, 회피, 탐지, 회복 이렇게 4가지가 존재한다. 즉, 데드락이 발생하지 않도록 예방하거나, 발생 가능성을 인정하면서도 적절히 회피하거나, 데드락 발생을 완전히 허용하지만 데드락을 탐지하여 회복하는 방안이다. ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:2:0","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"예방 (Prevention) 데드락 발생 조건 중 하나를 제거하며 데드락을 예방하는 방법이다. 상호배제 부정 : 여러 프로세스가 공유 자원 사용 가능 점유대기 부정 : 프로세스 실행 전 모든 자원을 한 번에 요구하고 허용할 때까지 작업 보류 비선점 부정 : 자원을 점유 중인 높은 우선순위의 프로세스가 다른 자원 요구할 때 해당 자원 반납 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구 하지만 이렇게 데드락을 예방하게 되면 시스템의 처리량이나 효율성은 떨어진다. 아래에서 소계하는 데드락 회피법은 예방법보단 조금 덜 제한적인 방법을 활용하여, 예방법의 단점을 일부 해결한다. ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:2:1","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"회피 (Avoidance) 데드락이 발생했을 때 피해나가는 방법이다. 데드락 회피법에서는 안정상태가 핵심 키워드이다. 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례대로 모두에게 할당해줄 수 있는 상태라면 이것을 안정 상태에 있다고 말한다. 그리고 이처럼, 특정한 순서로 프로세스들에게 자원을 할당하고 실행, 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면, 그것을 안전 순서라고 부른다. 반대로 불안정 상태는 안정 상태가 아닌 상황을 이야기하는데, 즉 데드락이 발생할 수 있는 상황인 것이다. 데드락 회피법은, 자원을 할당한 후에도 시스템이 항상 안정 상태에 있을 수 있도록 할당을 허용하는 것이 기본 특징이다. 이러한 특징을 살린 대표적인 알고리즘으로 ‘은행원 알고리즘’이 있다. Note 은행원 알고리즘 (Banker’s Algorithm) 다익스트라가 고안한 알고리즘 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 데드락 회피 안정 상태라면 자원을 할당하고, 아니라면 다른 프로세스들이 자원을 해제할 때까지 대기 ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:2:2","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"탐지 및 회복(Detection and Recovery) 자원 할당 그래프를 통해 데드락을 탐지한다. 즉 자원 요청 시 탐지 알고리즘을 실행시키는 방식으로, 그에 대한 오버헤드가 발생한다. 탐지 기법에 따라 데드락을 발견했다면, 데드락을 일으킨 프로세스를 종료하거나, 할당된 자원을 반납하게끔 하여 데드락 상황을 해결하는 방법이다. 프로세스 종료 방법 데드락 발생한 프로세스 모두 정지하는 방식 : 연산중이던 프로세스들이 모두 중단되기 때문에 부분 연산 결과가 폐기될 수 있다. 데드락이 제거될 때까지 하나씩 프로세스 중지하는 방식 : 데드락이 회복되는 시점까지 이를 반복하기 때문에 시스템적으로 고비용 작업이다. 자원 선점 시 고려할 점 희생자 선택 (selection of a victim) : 최소의 피해를 줄 수 있는 프로세스를 선택한다. 롤백(rollback) : 선점 된 프로세스를 문제 없던 이전 상태로 롤백해야 한다. 보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 것이다. 기아 상태(starvation) : 한 프로세스가 계속 선점되어 기아상태가 되는 것을 방지해야 한다. 한 가지 방법은 우선 순위를 사용하여 선점 될때마다 프로세스 우선순위를 높이는 것이다. ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:2:3","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"참고 https://velog.io/@haero_kim/%EC%82%AC%EB%82%98%EC%9D%B4%EB%93%A4%EC%9D%98-%EC%9E%90%EA%B0%95%EB%91%90%EC%B2%9C-%EB%8D%B0%EB%93%9C%EB%9D%BD-DeadLock https://yoongrammer.tistory.com/67 ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:3:0","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["etc"],"content":"HDD(Hard Disk Drive) HDD는 자성을 띠는 원형 디스크인 플래터(Platter)와 이 플래터 위를 쉴새 없이 움직이는 헤드(Head)로 구성된다. 돌아가는 LP판의 홈을 바늘이 읽는 것처럼, HDD의 헤드는 회전하는 플래터의 데이터를 읽고 쓴다. 물리적으로 돌아가는 모터 방식이기에 소음이 발생한다. 때문에 소비 전력도 높고 발열 문제가 수반된다는 특징이 있다. HDD는 데이터 처리 속도도 상대적으로 느리며, 충격에 의해 헤드 같은 내부 장치가 손상될 수 있어 내구성도 약하다. ","date":"2022-03-28","objectID":"/hdd-vs-ssd/:1:0","tags":["hdd","ssd"],"title":"HDD vs SSD","uri":"/hdd-vs-ssd/"},{"categories":["etc"],"content":"SSD(Solid State Drive) SSD는 데이터 저장 장치로 메모리 반도체(낸드플래시)를 채택하며 HDD의 한계를 넘어선다. 가장 큰 차이점은 데이터 읽기/쓰기 속도를 압도적으로 높였다는 점이다. 모터가 없으니 소음도 발생하지 않고, 소비전력과 발열도 적다. 또한 내부에 움직이는 부품이 없기 때문에 외부 충격으로 손상될 가능성이 낮아 데이터를 안전하게 유지할 수 있다는 장점이 있다. 2013년 경에는 종래의 SATA 연결방식에서 탈피한 NVMe 연결방식의 SSD가 등장해 보조기억장치의 새로운 장을 열었다. NVMe 방식 SSD는 읽기 및 쓰기 속도가 보조기억장치(HDD, 종래의 SSD 등) 수준이 아니라 주기억장치(RAM)에 가까울 정도로 빠르며 크기도 아주 작아 SSD의 표준이 되었다. 플래시 메모리 플래시 메모리는 비휘발성 반도체 저장장치다. 전기적으로 자유롭게 재기록이 가능하다. ROM의 일종인 EEPROM으로부터 발전하여 현재의 모습으로 정착했다. 예전에는 한 번만 기록이 가능했던 PROM(Programmable ROM)과 삭제가 가능했던 EPROM(Erasable PROM) 2가지의 메모리 방식들이 있었다. PROM은 내용을 기록할 때 하드웨어적으로 내부의 배선을 끊기 때문에 재기록이 불가능하다. EPROM은 삭제 방식에 따라 자외선을 쬐어야 하는 UV-EPROM과 전기적으로 가능한 EEPROM 등으로 나뉜다. 후자는 전술했듯 플래시 메모리로 발전했고, 전자는 매우 번거롭기 때문에 현재는 거의 안 쓰인다. 과거에는 PROM과 EPROM이 각종 펌웨어를 저장하고 있었지만, 요즘은 거의 플래시 메모리로 대체되고 있으므로 펌웨어 업데이트가 과거에 비해 매우 자유롭다. 롬에서 나온 것이니 롬의 일종으로 봐야 할 것 같지만, 플래시 메모리는 기록된 내용을 보존한다는 측면에서는 ROM과 유사한 특징이 있으면서도 메모리 어드레싱이 아닌 섹터 어드레싱을 한다는 특성으로 인해 주 기억 장치로 분류되는 RAM이 아닌 하드디스크와 유사한 보조 기억 장치로 분류된다. ","date":"2022-03-28","objectID":"/hdd-vs-ssd/:2:0","tags":["hdd","ssd"],"title":"HDD vs SSD","uri":"/hdd-vs-ssd/"},{"categories":["etc"],"content":"참고 https://namu.wiki/w/SSD https://namu.wiki/w/%ED%94%8C%EB%9E%98%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC ","date":"2022-03-28","objectID":"/hdd-vs-ssd/:3:0","tags":["hdd","ssd"],"title":"HDD vs SSD","uri":"/hdd-vs-ssd/"},{"categories":["ML"],"content":"선형 회귀는 한 개 이상의 독립 변수 x와 y의 선형 관계를 모델링한다. 가중치 행렬을 W, 편향을 b, 실제값을 y라고 할 때, 선형회귀는 비용함수 MSE를 최소화하는 W와 b를 추정해 나가는 과정이다. ","date":"2022-03-27","objectID":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/:0:0","tags":["linear-regression"],"title":"선형회귀","uri":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/"},{"categories":["ML"],"content":"계산 과정 편차를 $WX_{i}+b-y_{i}$라고 할 때, 비용함수는 다음과 같다. $$cost(W,b) = \\sum_{i=1}^{m} (WX_{i}+b-y_{i})^2 \\cdot \\cfrac{1}{m}$$ $$= \\sum_{i=1}^{m}(X_{i}^2W^2+2X_{i}bW-2by_{i}-2X_{i}y_{i}W+b^2+yi^2) \\cdot \\cfrac{1}{m}$$ 비용함수를 W로 편미분 하면 다음과 같다. $$\\partial{W} = \\cfrac{\\partial{cost(W,b)}} {\\partial{W}} = \\sum_{i=1}^{m}(2X_{i}^2W+2X_{i}b-2X_{i}y_{i})\\cdot \\cfrac{1}{m} $$ $$= 2X_{i}\\sum_{i=1}^{m} (WX_{i}+b-y_{i})\\cdot \\cfrac{1}{m}$$ 비용함수를 b로 편미분 하면 다음과 같다. $$\\partial{b} = \\cfrac{\\partial{cost(W,b)}} {\\partial{b}} = \\sum_{i=1}^{m}(2X_{i}W-2y_{i}+2b)\\cdot \\cfrac{1}{m}$$ $$= 2\\sum_{i=1}^{m} (WX_{i}+b-y_{i})\\cdot \\cfrac{1}{m}$$ W와 b를 Gradient Descent로 추정해나가는 과정은 다음과 같다. $$W:=W-lr\\cfrac{\\partial{cost(W,b)}} {\\partial{W}}$$ $$b:=b-lr\\cfrac{\\partial{cost(W,b)}} {\\partial{b}}$$ ","date":"2022-03-27","objectID":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/:1:0","tags":["linear-regression"],"title":"선형회귀","uri":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/"},{"categories":["ML"],"content":"코드로 구현 import numpy as np xy = np.array([[1., 2., 3., 4., 5., 6.], [3., 6., 9., 12., 15., 18.]]) x_train = xy[0] y_train = xy[1] weight = np.random.rand(1) bias = np.random.rand(1) learning_rate = 0.001 for i in range(10000): pred = weight * x_train + bias error = pred - y_train cost = (error ** 2).mean() weight -= learning_rate * (error * 2 * x_train).mean() bias -= learning_rate * 2 * error.mean() if i % 100 == 0: print('Epoch ({:10d}/1000) error: {:10f}, beta_gd: {:10f}, bias: {:10f}'.format(i, cost, weight.item(), bias.item())) 결과는 다음과 같다. Epoch ( 0/1000) error: 79.680243, beta_gd: 0.628488, bias: 0.666181 Epoch ( 100/1000) error: 0.359263, beta_gd: 2.657885, bias: 1.096474 Epoch ( 200/1000) error: 0.222940, beta_gd: 2.745611, bias: 1.074800 Epoch ( 300/1000) error: 0.207077, beta_gd: 2.757658, bias: 1.036960 Epoch ( 400/1000) error: 0.192499, beta_gd: 2.766458, bias: 0.999819 Epoch ( 500/1000) error: 0.178947, beta_gd: 2.774833, bias: 0.963984 Epoch ( 600/1000) error: 0.166349, beta_gd: 2.782904, bias: 0.929432 Epoch ( 700/1000) error: 0.154637, beta_gd: 2.790685, bias: 0.896118 Epoch ( 800/1000) error: 0.143751, beta_gd: 2.798188, bias: 0.863999 Epoch ( 900/1000) error: 0.133631, beta_gd: 2.805421, bias: 0.833030 Epoch ( 1000/1000) error: 0.124223, beta_gd: 2.812395, bias: 0.803172 Epoch ( 1100/1000) error: 0.115477, beta_gd: 2.819120, bias: 0.774384 Epoch ( 1200/1000) error: 0.107348, beta_gd: 2.825603, bias: 0.746628 Epoch ( 1300/1000) error: 0.099790, beta_gd: 2.831854, bias: 0.719867 Epoch ( 1400/1000) error: 0.092765, beta_gd: 2.837881, bias: 0.694064 Epoch ( 1500/1000) error: 0.086234, beta_gd: 2.843692, bias: 0.669187 Epoch ( 1600/1000) error: 0.080163, beta_gd: 2.849294, bias: 0.645202 Epoch ( 1700/1000) error: 0.074520, beta_gd: 2.854696, bias: 0.622076 Epoch ( 1800/1000) error: 0.069273, beta_gd: 2.859904, bias: 0.599779 Epoch ( 1900/1000) error: 0.064396, beta_gd: 2.864925, bias: 0.578281 Epoch ( 2000/1000) error: 0.059863, beta_gd: 2.869767, bias: 0.557554 Epoch ( 2100/1000) error: 0.055648, beta_gd: 2.874435, bias: 0.537569 Epoch ( 2200/1000) error: 0.051731, beta_gd: 2.878935, bias: 0.518301 Epoch ( 2300/1000) error: 0.048089, beta_gd: 2.883275, bias: 0.499724 Epoch ( 2400/1000) error: 0.044703, beta_gd: 2.887459, bias: 0.481812 Epoch ( 2500/1000) error: 0.041556, beta_gd: 2.891492, bias: 0.464543 Epoch ( 2600/1000) error: 0.038631, beta_gd: 2.895382, bias: 0.447892 Epoch ( 2700/1000) error: 0.035911, beta_gd: 2.899131, bias: 0.431838 Epoch ( 2800/1000) error: 0.033383, beta_gd: 2.902747, bias: 0.416360 Epoch ( 2900/1000) error: 0.031033, beta_gd: 2.906233, bias: 0.401436 Epoch ( 3000/1000) error: 0.028848, beta_gd: 2.909594, bias: 0.387048 Epoch ( 3100/1000) error: 0.026817, beta_gd: 2.912834, bias: 0.373175 Epoch ( 3200/1000) error: 0.024929, beta_gd: 2.915958, bias: 0.359799 Epoch ( 3300/1000) error: 0.023174, beta_gd: 2.918971, bias: 0.346903 Epoch ( 3400/1000) error: 0.021542, beta_gd: 2.921875, bias: 0.334469 Epoch ( 3500/1000) error: 0.020026, beta_gd: 2.924675, bias: 0.322481 Epoch ( 3600/1000) error: 0.018616, beta_gd: 2.927375, bias: 0.310922 Epoch ( 3700/1000) error: 0.017305, beta_gd: 2.929978, bias: 0.299778 Epoch ( 3800/1000) error: 0.016087, beta_gd: 2.932488, bias: 0.289033 Epoch ( 3900/1000) error: 0.014955, beta_gd: 2.934908, bias: 0.278673 Epoch ( 4000/1000) error: 0.013902, beta_gd: 2.937241, bias: 0.268684 Epoch ( 4100/1000) error: 0.012923, beta_gd: 2.939490, bias: 0.259054 Epoch ( 4200/1000) error: 0.012013, beta_gd: 2.941659, bias: 0.249769 Epoch ( 4300/1000) error: 0.011168, beta_gd: 2.943750, bias: 0.240816 Epoch ( 4400/1000) error: 0.010381, beta_gd: 2.945766, bias: 0.232185 Epoch ( 4500/1000) error: 0.009650, beta_gd: 2.947710, bias: 0.223863 Epoch ( 4600/1000) error: 0.008971, beta_gd: 2.949585, bias: 0.215839 Epoch ( 4700/1000) error: 0.008339, beta_gd: 2.951392, bias: 0.208102 Epoch ( 4800/1000) error: 0.007752, beta_gd: 2.953134, bias: 0.200643 Epoch ( 4900/1000) error: 0.007","date":"2022-03-27","objectID":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/:2:0","tags":["linear-regression"],"title":"선형회귀","uri":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/"},{"categories":["web"],"content":"OSI는 Open Systems Interconnection의 약자로 개방형 시스템 간의 상호 연결을 의미한다. 국제 표준화 기구인 ISO에서 개발한 모델로 컴퓨터 네트워크의 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:0","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"1계층 - 물리 계층(Physical Layer) 네트워크 OSI 모델에서 가장 낮은 계층으로 하드웨어 전송 기술로 구성된다. 하드웨어 장비로 케이블, 리피터, 허브가 있으며 네트워크에서 물리적으로 데이터를 전송하는 역할을 수행한다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:1","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"2계층 - 데이터 링크 계층(Data Link Layer) 물리 계층을 통해 데이터를 전송하다가 데이터가 제대로 도착하지 못하고 중도 분실되거나 데이터의 내용이 깨져서 변형이 되는 등 물리적인 오류가 발생할 수 있다. 이러한 물리적인 감지하고 제어하여 포인트 투 포인트 간의 신뢰성 있는 전송을 보장한다. 네트워크 장비 중 브릿지나 L2 (Layer 2) 스위치가 이 계층에서 동작한다. 데이터 링크 계층에서 전송되는 데이터의 단위를 프레임이라고 한다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:2","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"3계층 - 네트워크 계층 네트워크 계층의 핵심은 라우팅이다. 데이터가 전송되기 위해 여러 경로를 거쳐서 가야 하는데 이 경로 배정 기능을 바로 라우터가 수행한다. 네트워크 계층에서 전송되는 데이터 단위는 패킷이다. 네트워크 계층에는 IPv4/IPv6, ICMP (Internet Control Message Protocol), IP 주소를 데이터 링크 계층의 MAC 주소로 변환하는 ARP (Address Resolution Protocol) 등 여러 프로토콜이 있다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:3","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"4계층 - 전송 계층(Transport Layer) 데이터를 전송하며 오류 검출 및 복구, 흐름제어, 중복 검사 등을 수행한다. 전송 계층에는 연결형 서비스와 비연결형 서비스가 있다. TCP는 연결형 서비스로 신뢰성 있는 연결을 보장하고, UDP는 비연결형 서비스로 스트리밍 서비스와 같이 데이터를 빠르게 통신할 때 이용된다. TCP에서의 데이터 단위는 세그먼트이고, UDP에서의 데이터 단위는 데이터그램이다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:4","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"5계층 - 세션 계층(Session Layer) 세션 계층은 세션 연결의 설정과 해제의 기능을 하고 서비스 인증 및 허가의 기능을 처리한다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:5","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"6계층 - 표현 계층(Presentation Layer) 인코딩이나 암호화 동작이 이 계층에서 이루어진다. 데이터를 표현하기 위한 문맥 계층이라 불리고 압축 및 데이터 변환이 일어난다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:6","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"7계층 - 응용 계층(Application Layer) 응용 프로세스 간의 기능을 제공한다. OSI 모델 중 가장 상위 계층으로 추상화된 계층이다. 응용 프로세스의 예로 텔넷 등이 있으며 실제로 애플리케이션과 가장 가까운 계층이다. 7계층에는 원격 로그인에 대한 텔넷부터 파일 전송인 FTP (File Transfer Protocol), 전자 메일에 대한 SMTP (Simple Mail Transfer Protocol), DNS 등 여러 프로토콜이 있다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:7","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"참고 개발자가 되기 위해 꼭 알아야 하는 IT 용어, 비제이리퍼블릭 ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:1:0","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["system"],"content":"생산자 소비자 문제 고정된 크기의 버퍼(데이터를 보유하는 임시 영역)가 있을 때, 생산자는 버퍼에 데이터를 생성하는 기능을 제공하고, 소비자는 버퍼에서 데이터를 소비/제거하는 기능을 제공한다. 이 때 특정 규칙이 있다. 소비자 스레드가 데이터를 소비하는 동안 생산자 스레드는 버퍼에 데이터를 생성할 수 없다. 생산자 스레드가 데이터를 생성하는 동안 소비자 스레드는 버퍼의 데이터를 사용할 수 없다. 버퍼가 가득 차면 생산자 스레드는 더 많은 데이터를 생성할 수 없고, 버퍼가 비어 있으면 소비자 스레드는 데이터를 소비할 수 없다. 이처럼 생산자 소비자 문제는 생산자 스레드는 버퍼가 비었는지 계속 확인해야 하고, 소비자 스레드는 버퍼에 태스크가 있는지 계속 확인해야 하는 문제를 말한다. ","date":"2022-03-26","objectID":"/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/:1:0","tags":["producer-consumer-problem","semaphore"],"title":"생산자 소비자 문제와 해결","uri":"/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/"},{"categories":["system"],"content":"WAIT-NOTIFY를 통한 해결 import java.util.*; import java.lang.*; import java.io.*; class Buffer{ private static final int size = 10; private Queue\u003cInteger\u003e buffer = new LinkedList\u003c\u003e(); public synchronized void produce(int item){ try{ if(this.buffer.size() == size){ this.wait(); } System.out.println(Thread.currentThread().getName() + \" produces item: \" + item); this.buffer.add(item); this.notifyAll(); } catch(InterruptedException exc){ exc.printStackTrace(); } } public synchronized void consume(){ try{ if(this.buffer.isEmpty()){ this.wait(); } System.out.println(Thread.currentThread().getName() + \" consumes item: \" + buffer.poll()); this.notifyAll(); } catch(InterruptedException exc){ exc.printStackTrace(); } } } class Producer implements Runnable{ private Buffer sharedBuffer; public Producer(Buffer buffer){ this.sharedBuffer = buffer; } @Override public void run(){ for(int i=1; i\u003c=10; i++){ sharedBuffer.produce(i); } } } class Consumer implements Runnable{ private Buffer sharedBuffer; public Consumer(Buffer myBuffer){ this.sharedBuffer = buffer; } @Override public void run(){ for(int i=1; i\u003c=10; i++){ sharedBuffer.consume(); } } } public class Main{ public static void main(String[] args) throws java.lang.Exception{ Buffer sharedBuffer = new Buffer(); Thread producerThread1 = new Thread(new Producer(sharedBuffer)); Thread consumerThread2 = new Thread(new Consumer(sharedBuffer)); Thread producerThread2 = new Thread(new Producer(sharedBuffer)); Thread consumerThread2 = new Thread(new Consumer(sharedBuffer)); producerThread.start(); consumerThread.start(); } } ","date":"2022-03-26","objectID":"/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/:2:0","tags":["producer-consumer-problem","semaphore"],"title":"생산자 소비자 문제와 해결","uri":"/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/"},{"categories":["system"],"content":"Semaphore를 통한 해결 import java.util.*; import java.lang.*; import java.io.*; class Buffer{ private Semaphore Prod = new Semaphore(1); private Semaphore Cons = new Semaphore(0); private Queue\u003cInteger\u003e buffer = new LinkedList\u003c\u003e(); public void produce(int item){ try{ Prod.acquire(); System.out.println(Thread.currentThread().getName() + \" produces item: \" + item); buffer.offer(item); Cons.release(); } catch(InterruptedException exc){ exc.printStackTrace(); } } public void consume(){ try{ Cons.acquire(); System.out.println(Thread.currentThread().getName() + \" consumes item: \" + buffer.poll()); Prod.release(); } catch(InterruptedException exc){ exc.printStackTrace(); } } } class Producer implements Runnable{ private Buffer sharedBuffer; public Producer(Buffer buffer){ this.sharedBuffer = buffer; } @Override public void run(){ for(int i=1; i\u003c=10; i++){ sharedBuffer.produce(i); } } } class Consumer implements Runnable{ private Buffer sharedBuffer; public Consumer(Buffer myBuffer){ this.sharedBuffer = buffer; } @Override public void run(){ for(int i=1; i\u003c=10; i++){ sharedBuffer.consume(); } } } public class Main{ public static void main(String[] args) throws java.lang.Exception{ Buffer sharedBuffer = new Buffer(); Thread producerThread1 = new Thread(new Producer(sharedBuffer)); Thread consumerThread2 = new Thread(new Consumer(sharedBuffer)); Thread producerThread2 = new Thread(new Producer(sharedBuffer)); Thread consumerThread2 = new Thread(new Consumer(sharedBuffer)); producerThread.start(); consumerThread.start(); } } ","date":"2022-03-26","objectID":"/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/:3:0","tags":["producer-consumer-problem","semaphore"],"title":"생산자 소비자 문제와 해결","uri":"/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/"},{"categories":["system"],"content":"참고 https://www.youtube.com/watch?v=Dms1oBmRAlo https://medium.com/@madhurgupta977/producer-consumer-problem-and-its-solution-626b1e573c50 ","date":"2022-03-26","objectID":"/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/:4:0","tags":["producer-consumer-problem","semaphore"],"title":"생산자 소비자 문제와 해결","uri":"/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0/"},{"categories":["etc"],"content":"인코딩이란, 사용자가 입력한 문자나 기호를 컴퓨터가 이용할 수 있는 신호로 만드는 것을 말한다. ","date":"2022-03-25","objectID":"/ascii-unicode/:0:0","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["etc"],"content":"아스키코드(American Standard Code for Information Interchange) 가장 처음 만들어진 인코딩방식이다. 숫자와 문자를 매칭시키는 국제적 규칙이다. 패리티 비트를 제외하고, 128개의 문자조합을 제공하는 7비트 부호로 구성된다.(패리티 비트는 데이터의 에러를 탐지하기 위해 사용한다. 일곱자리의 이진수에서 ‘1’이 홀수개라면 끝에 1을, ‘1’이 짝수개라면 끝에 0을 덧붙인다. 아주 정밀하진 않지만 패리티 비트를 이용해 어느 정도의 에러를 탐지할 수 있다.) 아스키코드만으로는 영어만 표현 가능하며 각 나라별 언어를 표현할 수 없다는 단점이 있다. ","date":"2022-03-25","objectID":"/ascii-unicode/:1:0","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["etc"],"content":"유니코드(Unicode) 전 세계 언어의 문자를 정의하기 위한 국제 표준 코드이다. 사용중인 운영체제, 프로그램, 언어에 관계 없이 문자마다 고유한 코드 값을 제공한다. ","date":"2022-03-25","objectID":"/ascii-unicode/:2:0","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["etc"],"content":"UTF-8 (8-bit Unicode Transformation Format) 유니코드를 사용하는 인코딩 방식 중 하나이며 표현범위에 따라 2,3,4바이트를 사용한다. UTF-8은 인코딩 형태를 8비트 단위로 한다는 의미를 가지고 있다. UTF8은 현재 다양한 플랫폼(Windows, Linux, Unix, Mac OS)이 접속하는 인터넷환경에서 de facto standard(사실상의 표준)으로 자리 잡았다. UTF-8의 강점은 아스키방식과 완벽하게 호환(영문 영역에서는 100% 호환) 된다는 것이다. 또한 UTF-8은 endianness 인코딩으로 little endian, big endian의 구분이 없다. 그래서 이 기종간의 데이터 교환을 위해 현재 가장 선호되는 인코딩이다. ","date":"2022-03-25","objectID":"/ascii-unicode/:2:1","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["etc"],"content":"UTF-16 (16-bit Unicode Transformation Format) UTF-16은 아스키와 동일한 범위를 표현할 때도 앞에 0으로 채워서 16 비트가 최소로 이용되며 2 또는 4 바이트 단위로만 사용된다. endian 방식에 따라 다르게 읽힌다. ","date":"2022-03-25","objectID":"/ascii-unicode/:2:2","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["etc"],"content":"UTF-32 (32-bit Unicode Transformation Format) 데이터 표현시 4바이트단위를 사용한다. 메모리 낭비가 심하다는 단점이 있다. ","date":"2022-03-25","objectID":"/ascii-unicode/:2:3","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["etc"],"content":"참고 https://dar0m.tistory.com/212 https://nhj12311.tistory.com/59 ","date":"2022-03-25","objectID":"/ascii-unicode/:3:0","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["system"],"content":"동기화(Synchronization)란 여러 프로세스/스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것을 말한다. 상호 배제(Mutual Exclusion)란 동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해, 즉 동기화를 위해 사용되는 알고리즘을 말한다. 상호 배제는 락(Lock)을 사용해서 달성할 수 있다. do { acquire lock // 여러 프로세스/스레드가 lock을 획득하기 위해 경합 [critical section] // lock을 획득한 프로세스/스레드만 임계 영역에서 실행함 release lock // 작업을 끝내고, lock을 반환함 remainder section } while(true) ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:0:0","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":["system"],"content":"스핀락(Spinlock) volatile int lock = 0; // global void critical() { while(test_and_set(\u0026lock) == 1); // lock을 획득하려는 시도를 함 [... critical section] // lock을 얻었다면, 임계 영역으로 진입 lock = 0; // 작업이 끝난 후, lock을 반환 } int test_and_set(int* lockPtr) { int oldLock = *lockPtr; *lockPtr = 1; // 반환하기 직전에 lock의 값을 1로 바꿔줌 return oldLock; } 위 코드에서는 test_and_set(\u0026lock)을 통해 임계 영역에서의 동시 작업을 방어하고 있다. test_and_set은 CPU의 atomic 명령어로, 하드웨어의 도움을 받아 수행된다. 이것을 활용하면 상호 배제 등을 편리하게 구현할 수 있다. 이와 같이 while loop를 빠져나가기 위해 계속해서 lock을 확인하여 획득하는 방식을 Spinlock(스핀락) 이라고 한다. 다시 말해 ‘락을 가질 수 있을 때 까지 반복해서 시도하는 방식’이다. 이 방식은 쉽게 Mutual Exclusion을 구현할 수 있다는 장점이 존재하지만, 락이 존재하는지를 계속해서 확인해야 하므로 CPU를 낭비한다는 단점이 있다. 특히, 디스크 I/O나 네트워크 통신과 같은 상대적으로 느린 작업을 수행하는 임계 영역이 존재한다면 그 동안 다른 스레드는 락을 획득하려고 계속해서 CPU를 점유하게 된다. 따라서 전체 시스템의 성능이 저하될 수 있다. ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:1:0","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":["system"],"content":"뮤텍스(Mutex) class Mutex{ int value = 1; // 임계 영역에 진입하기 위해 이 value를 취득해야 함 int guard = 0; } Mutex::lock() { while(test_and_set(\u0026guard)); if(value == 0) { // 이미 누가 value를 취득한 상태라면 (lock을 획득할 수 없음) ... 현재 스레드를 큐에 넣음; // lock을 획득할 수 있을 때 깨워주기 위해 선입선출 구조인 Queue에 넣음 guard = 0; \u0026 go to sleep } else { // lock을 획득할 수 있다면 value = 0; // lock을 취득함 guard = 0; } } Mutex::unlock() { while(test_and_set(\u0026guard)); if(큐에 하나라도 대기중이라면) { // ex) queue.isNotEmpty() 그 중에 하나를 깨운다; // ex) queue.poll() } else { value = 1; } guard = 0; } 뮤텍스에서는 당장 lock을 획득할 수 없다면 FIFO구조의 queue에 현재 스레드를 넣고 쉬러 간다(sleep). 그리고 queue에 대기중인 스레드가 존재한다면 스레드를 깨워서 lock을 부여한다. Mutex의 value라는 값도 결국은 여러 프로세스/스레드가 서로 취득하기 위해 경쟁하는 공유 데이터이다. 그렇다면, value라는 값 자체도 그 값을 바꿔줄 때 마다 임계 영역에서 안전하게 바꿔주어야 한다. 그렇지 않으면, 경쟁 상태가 발생할 수 있기 때문이다. 그래서 이 value값을 임계 영역에서 안전하게 바꿔주기 위한 장치가 필요한데 그것이 guard이다. value 값을 바꿔주는 로직을 보호하기 위해 guard라는 장치를 통해 보호하고 있다. ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:2:0","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":["system"],"content":"Spinlock vs Mutex Spinlock과 다르게 Mutex는 lock을 획득할 수 없으면 스레드가 sleep 상태가 되는데, 이로 인해 Cpu Cycle이 낭비되는 것을 최소화할 수 있다. 이러한 이유로 Spinlock보다 Mutex Lock이 사용된다. 그러나 멀티 코어 환경이고, 임계 영역에서의 작업이 문맥 교환보다 더 빨리 끝난다면 Spinlock이 Mutex보다 더 이점이 있다. 멀티 코어라는 조건이 붙는 이유는 싱글 코어 환경에서는 Spinlock을 사용한다고 하더라도, lock을 취득하려면 누군가가 쥐고있는 lock을 해제해야 하는데 이러한 과정이 결국 문맥교환을 필요로 하기 때문이다. 반면 한 코어에서 다른 코어의 락을 획득하기 위해 Spinlock 방식으로 확인하고 있다면, lock을 획득하는 과정에서 문맥교환이 발생하지 않기 때문에 성능 상 이점이 존재한다. Mutex는 lock을 획득할 수 없다면 스레드들이 sleep 상태로 대기하다가 lock을 획득할 수 있다면 깨어나서 lock을 획득하여 작업을 이어가는 방식이다. 반대로 Spinlock은 계속해서 lock을 획득할 수 있는지 확인하는 작업이다. 임계 영역에서의 작업이 문맥교환 시간보다 짧다면 Spinlock이 더 우세할 수 있다. ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:2:1","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":["system"],"content":"세마포어(Semaphore) 세마포어는 임계 영역에 프로세스/스레드가 하나 이상 들어가도록 하는 장치이다. 세마포어는 Signal Mechanism을 가지는데, 이는 Semaphore의 값이 변경될 때 다른 프로세스/스레드에 그 사실을 알리는 방법을 의미한다. 이러한 Signal Mechanism을 통해 실행 순서도 정해줄 수 있게 된다. class Semaphore { int value = 1; // mutex와 달리 0, 1, 2... 의 값을 가질 수 있음 int guard = 0; } Semaphore::wait() { while(test_and_set(\u0026guard)); if(value == 0) { ... 현재 스레드를 큐에 넣음; guard = 0; \u0026 go to sleep } else { value -= 1; // mutex에서는 0으로 바꾸었지만, semaphore에서는 1씩 차감하는 형태 guard = 0; } } Semaphore::signal() { while(test_and_set(\u0026guard)); if(큐에 하나라도 대기중이라면) { 그 중에 하나를 깨운다; } else { value += 1; // mutex에서는 1로 바꾸었지만, semaphore에서는 1씩 증가하는 형태 } guard = 0; } 전체적으로 Mutex의 코드와 비슷하나, 차이점으로는 value(lock)을 Semaphore는 1 이상 가질 수 있는 부분과 락을 획득했을 때와 해제했을 때 단순히 value를 0, 1로 바꾸는 것이 아니라 현재 값에서 차감하고 증가하는 형태로 바뀐 부분이 있다. ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:3:0","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":["system"],"content":"Mutex vs Semaphore Mutual Exclusion(상호 배제)만 필요하다면 Mutex를, 작업 간의 실행 순서 동기화가 필요하다면 Semaphore가 권장된다. 세마포어를 통해 작업순서를 동기화하는 예시는 다음과 같다. //DispatchSemaphore 초기값 0으로 설정 let semaphore = DispatchSemaphore(value: 0) print(\"task A가 끝나길 기다림\") // 다른 스레드에서 task A 실행 DispatchQueue.global(qos: .background).async { //task A print(\"task A 시작!\") print(\"task A 진행중..\") print(\"task A 끝!\") //task A 끝났다고 알려줌 semaphore.signal() } // task A 끝날때까지는 value 가 0이라, task A 종료까지 block semaphore.wait() print(\"task A 완료됨\") ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:3:1","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":["system"],"content":"Mutex vs Binary Semaphore value값으로 1을 가지는 Semaphore를 binary Semaphore, 혹은 이진 세마포어라고 하고, value값으로 1이 아닌 값을 가지는 Semaphore를 Counting Semaphore라고 한다. 차이점은 다음과 같다. Mutex는 lock을 가진 스레드만 lock을 해제 할 수 있지만, Semaphore는 그렇지 않다. Mutex는 lock을 가진 프로세스/스레드만이 lock을 해제할 수 있기 때문에, 누가 lock을 해제할지 예상할 수 있다. 그러나 Semaphore는 wait를 호출하는 존재와 signal을 호출하는 존재가 다를 수 있다. mutex mutex-\u003elock(); // mutex의 lock을 가지기 위해서 경합 [critical section] // lock을 획득했다면, 임계 영역에 진입 mutex-\u003eunlock(); // 작업이 끝났다면, lock을 반환 semaphore semaphore -\u003e wait(); // mutex에서의 lock [critical section] semaphore -\u003e signal(); // mutex에서의 unlock Mutex는 Priority Inheritance 속성을 가지지만, Semaphore는 그렇지 않다. P2의 우선순위를 P1만큼 올려주는 작업을 Priority Inheritance라고 부른다. Semaphore는 누가 lock을 해제할지(signal)알 수 없기 때문에 뮤텍스와 달리 우선순위를 상속하는 속성이 존재하지 않는다. ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:3:2","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":["system"],"content":"모니터(Monitor) Monitor는 임계 구역을 지켜내기 위한 방법인 상호 배제를 프로그램으로 구현한 것이다. 모니터는 프로그래밍 언어 수준에서 제공되며, 순차적으로 사용할 수 있는 공유 자원 혹은 공유 자원 그룹을 할당하는 데 사용된다. 모니터는 이진 세마포어만 가능하다. 공유 자원에 점유 중인 프로세스(스레드)는 Lock을 가지고 있다. 공유 자원을 점유 중인 프로세스(스레드)가 있는 상황에서 다른 프로세스(스레드)가 공유 자원에 접근하려고 하면 외부 모니터 준비 큐에서 진입을 wait 한다. Monitor 는 Semaphore 처럼 signal 연산을 보내는 것이 아니라 조건 변수를 사용하여 특정 조건에 대해 대기 큐에 signal 을 보내 작업을 시작시킨다. 모니터의 구성 요소 mutex lock: critical section에서 mutual exclusion을 보장하는 장치 mutex lock을 취득해야 critical section에 진입할 수 있음 mutex lock을 취득하지 못한 쓰레드는 큐에 들어간 후 대기(wating) 상태로 전환 condition variable waiting queue를 가짐 조건이 충족되길 기다리는 쓰레드들이 대기상태로 머무는 곳 자바에서 Monitor 구현 Java 의 synchronized 키워드는 스레드 동기화를 할 때 사용하는 대표적인 기법이다. 자바의 모든 인스턴스는 Monitor를 가지고 있으며 Monitor 를 통해 Thread 동기화를 수행한다. 자바의 모니터는 condition variable를 하나만 가지며, synchronized 키워드가 붙은 메서드를 사용하려면 Lock을 가지고 있어야 한다. synchronized를 사용하는 방법으로는 메서드 앞에 키워드 명시, 인스턴스로 사용하기가 있다. 동기화가 필요한 메서드 앞에 synchronized 키워드만 붙여주면 편리하게 동기화를 적용할 수 있다. 인스턴스로 사용하려면 메서드 내부에서 synchronized (메서드) { 구현 } 으로 사용할 수 있다. Monitor의 Condition Variable을 통해 wait(), notify() 메서드가 구현되어 있다. Lock 을 가진 스레드가 다른 스레드에 Lock 을 넘겨준 이후에 대기해야 한다면 wait() 를 사용하면 된다. 그리고 대기 중인 임의의 스레드를 깨우려면 notify() 를 통해 깨울 수 있다. 대기 중인 모든 스레드를 깨우려면 notifyAll() 을 통해 깨울 수 있는데, 이 경우에는 하나의 스레드만 Lock 을 획득하고 나머지 스레드는 다시 대기 상태에 들어간다. ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:3:3","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":["system"],"content":"참고 https://www.youtube.com/watch?v=gTkvX2Awj6g https://tecoble.techcourse.co.kr/post/2021-10-23-java-synchronize/ ","date":"2022-03-23","objectID":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/:4:0","tags":["spinlock","mutex","semaphore","monitor"],"title":"스핀락 vs 뮤텍스 vs 세마포어 vs 모니터","uri":"/%EC%8A%A4%ED%95%80%EB%9D%BD-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"categories":[""],"content":"개념 ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:0","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":[""],"content":"블럭/넌블럭 블럭/넌블럭은 함수호출에서의 이야기. 제어권에 의해 대기가 발생하는지 여부로 구분한다. Block 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return하지 않으면 블럭이다. Non-Block 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return하여 호출한 함수가 다른 일을 진행할 수 있도록 하면 넌블럭이다. ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:1","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":[""],"content":"동기/비동기 동기/비동기는 행위에 대한 이야기. 호출한 함수가 호출된 함수를 신경쓰는지 여부로 구분한다. Synchronous 호출된 함수의 수행 결과 및 종료를 호출된 함수 뿐 아니라 호출한 함수도 함께 신경쓰면 동기이다. Asynchoronous 호출된 함수의 수행 결과 및 종료를 호출된 함수 혼자 직접 신경쓰고 처리하면 비동기이다. ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:2","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":[""],"content":"예시 ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:0","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":[""],"content":"동기 \u0026 블로킹 Note 손님: 아메리카 주문 직원: 아메리카노 만드는중 손님: (그 자리에 서서 기다리는중. 결과가 궁금함. 테이블 못가고 서있음.) ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:1","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":[""],"content":"비동기 \u0026 블로킹 블럭 \u0026 비동기는 결국 다른 작업이 끝날 때를 기다려야 하기 때문에 동기 \u0026 비동기와 비슷한 효율이 나온다. Note 손님: 아메리카노 주문 직원 : 아메리카노 만드는중 손님 : (안궁금함. 테이블에 가고싶지만 못가고 서있음.) ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:2","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":[""],"content":"동기 \u0026 논블로킹 논블로킹으로 자신의 작업을 계속하고 있지만 다른 작업과의 동기를 위해 계속해서 다른 작업이 끝났는지 조회한다. 즉, 호출된 함수가 호출한 함수에게 제어권을 바로 return하여 호출한 함수가 다른 업무를 볼 수 있었음(Non-Blocked)에도 불구하고, 여전히 호출된 함수의 업무 결과에만 계속 함께 신경쓰느라(Synchronous) 제 할일을 못하게 되는 현상이 일어난다. 넌블럭 \u0026 동기도 효율이 좋지 않다. Note 손님: 아메리카노 주문 직원 : 아메리카노 만드는중 손님 : 다른 작업하며 계속 확인 ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:3","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":[""],"content":"비동기 \u0026 논블로킹 자원이 충분하다면 효율이 좋다. 자신의 작업이 멈추지도 않고, 다른 주체가 하는 작업의 결과가 나왔을 때 콜백을 설정하기도 한다. 다른 주체에게 작업을 맡겨놓고 자신이 하던 일을 계속할 수 있기 때문에 해야 할 작업이 대규모이고, 동기가 필요하지 않을 때 효과적이다. Note 손님: 아메리카노 주문 직원 : 아메리카노 만드는중 손님 : 자리가서 SNS, 유튜브 시청 직원 : 아메리카노 제작 완료 후 알림 ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:4","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":[""],"content":"참고 https://velog.io/@leehyunho2001/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:3:0","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["java"],"content":"추상클래스 자바에서는 하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 추상 클래스(abstract class)라고 한다. 이러한 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해준다. 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로, 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야 할 경우 사용한다. ","date":"2022-03-17","objectID":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/:1:0","tags":["abstract-class","interface"],"title":"추상클래스 vs 인터페이스","uri":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"categories":["java"],"content":"인터페이스 인터페이스는 상속 관계를 타고 올라갔을 때 다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다. 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다. 예를 들어 Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데, 구현클래스들 간에 관련성이 없다. ","date":"2022-03-17","objectID":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/:2:0","tags":["abstract-class","interface"],"title":"추상클래스 vs 인터페이스","uri":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"categories":["java"],"content":"사용 예시 추상클래스는 IS - A, 즉 “~이다” 로 표현되는 관계에 사용한다. 인터페이스는 HAS - A, 즉 “~을 할 수 있는\"로 표현되는 관계에 사용된다. 위의 예제에서 인간과 동물은 생명체를 상속하고 각 생명체들은 구분에 따라 인간과 동물을 상속한다. 이러한 관계는 추상클래스로 표현할 수 있다. 그리고 각각 할 수 있는 기능들은 인터페이스로 구현할 수 있다. 인터페이스와 추상 클래스는 존재 목적이 다르다. 추상 클래스는 그 추상 클래스를 상속받아서 기능을 이용하고, 확장시키는 데 있다. 반면에 인터페이스는 구현을 강제함으로써 구현 객체의 같은 동작을 보장할 수 있다. ","date":"2022-03-17","objectID":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/:3:0","tags":["abstract-class","interface"],"title":"추상클래스 vs 인터페이스","uri":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"categories":["java"],"content":"참고 https://velog.io/@dongvelop/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4 https://myjamong.tistory.com/150 https://brunch.co.kr/@kd4/6 ","date":"2022-03-17","objectID":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/:4:0","tags":["abstract-class","interface"],"title":"추상클래스 vs 인터페이스","uri":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"categories":["java"],"content":"제네릭이란 JDK 1.5부터 도입한 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법이다. 제네릭이 갖는 의미는 ‘일반화’이다. 그리고 자바에서 그 일반화의 대상은 자료형이다. ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:0:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"용어 Box\u003cT\u003e 클래스에서 사용된 T를 가리켜 ‘타입 매개변수(Type Parameter)’라 한다. 메소드의 매개변수와 유사하게 자료형 정보를 인자로 전달받는 형태이기 때문이다. \u003c\u003e안에 전달되는 것을 가리켜 ‘타입 인자(Type Argument)’라 한다. 타입 매개변수 T에 전달되는 인자로 바라보고 그렇게 이름을 지어준 것이다. Box\u003cApple\u003e aBox = new Box\u003cApple\u003e(); -\u003e Box\u003cApple\u003e을 가리켜 ‘매개변수화 타입(Parameterized Type)’이라 한다. 자료형 Apple이 타입 매개변수 T에 전달되어 Box\u003c Apple\u003e이라는 새로운 자료형이 완성된 것이기 때문에 ‘매개변수화 타입’이라 부른다. ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:1:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"제네릭 필요성 ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:2:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"불필요한 타입 변경을 없애준다. 다음 예제를 보자. public static void main(String[] args) { List numbers = Arrays.asList(1, 2, 3, 4, 5, 6); int sum = 0; for (Object number : numbers) { sum += (int) number; } } List에 있는 모든 숫자를 더하는 로직이다. List에 타입 지정을 안 했기 때문에 Object로 타입이 지정되고 더하는 부분에서 형 변환을 직접 해줘야 하는 번거로움이 있다. 위 예제에서는 형 변환을 한 번밖에 안 했지만 만약 타입 지정을 안 한 List가 사용되는 곳이 1000군데가 넘는다면 1000군데서 전부 예제처럼 직접 형변환을 해줘야 하는 번거로움이 있다. 아래와 같이 제네릭을 사용한다면 public static void main(String[] args) { List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5, 6); int sum = 0; for (Integer number : numbers) { sum += number; } } 불필요한 형 변환을 안 해도 되고 코드도 더 깔끔해진다. ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:2:1","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"타입 안전성이 있다. public static void main(String[] args) { List numbers = Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"); int sum = 0; for (Object number : numbers) { sum += (int) number; } } int형으로 형 변환을 해주며 더해주지만 List의 요소가 int형이라는 보장이 없다. 위 예제와 같이 List에 문자열을 넣어주어도 컴파일 에러가 발생하지 않고 런타임에 ClassCastException 이 터지게 된다. 컴파일 시 타입을 체크하고 에러를 찾아낼 수 있는 컴파일 언어의 장점을 발휘하지 못하는 셈이다. 제네릭을 사용했다면 아래와 같이 컴파일 시에 의도하지 않은 타입이 들어오는 걸 막을 수 있다. ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:2:2","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"제한된 제네릭 제네릭은 원하는 타입이 있을 때도 모든 타입이 들어올 수 있는 문제가 있다. public class Car\u003cT\u003e { private final T name; public Car(T name) { this.name = name; } ... } 위와 같은 Car 클래스 인스턴스 변수 name은 문자 관련 타입 지정되기를 원해도 아래와 같이 아무 타입이나 들어올 수 있다. public static void main(String[] args) { Car\u003cInteger\u003e car = new Car\u003c\u003e(1); } 이럴 때 타입 뒤에 extends 키워드를 사용해 타입을 제한시킬 수 있다. public class Car\u003cT extends CharSequence\u003e { private final T name; public Car(T name) { this.name = name; } ... } CharSequence 인터페이스 하위 객체들만 데이터 타입으로 지정할 수 있게 함으로써 인스턴스 변수 name에 문자열 관련 타입만 지정할 수 있게 되었다. public static void main(String[] args) { Car\u003cString\u003e car = new Car\u003c\u003e(\"sports\"); } Collections.sort에서도 제한된 제네릭을 사용하고 있다. public static \u003cT extends Comparable\u003c? super T\u003e\u003e void sort(List\u003cT\u003e list) { list.sort(null); } 정렬하기 위해서 List에 지정될 타입 T를 Comparable 인터페이스 하위 타입으로 제한시킨 것이다. ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:3:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-11-09-generics-basic/ ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:4:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["web"],"content":"포워드 프록시(Forward Proxy) 일반적으로, 프록시 서버라고 하면 포워드 프록시를 의미한다. 포워드 프록시란 클라이언트와 인터넷 사이에 프록시가 위치해서 클라이언트 대신 서버에 요청을 보내주는 형태를 말한다. 포워드프록시를 통해 얻는 이점은 다음과 같다. 로컬 네트워크와 인터넷 사이 오가는 트래픽을 제어할 수 있다. 예를 들어 초등학교 안에서 학생들이 부적절한 콘텐츠를 브라우징하는 것을 막기 위해서 포워드 프록시를 사용할 수 있다. 포워드 프록시는 대개 캐싱 기능이 있으므로 어떤 콘텐츠가 빈번하게 사용된다면 월등한 성능 향상을 가져올 수 있다. 서버의 응답을 캐싱해서 저장해두면 전송 시간이 절약되며, 불필요한 외부 전송을 하지 않아도 된다. 또한 외부 요청이 감소되므로 네트워크 병목 현상을 방지할 수 있다. 보안을 강화할 수 있다. 클라이언트의 요청을 포워드 프록시가 요청한 것처럼 가장함으로써 서버로부터 클라이언트의 정보를 클라이언트의 요청을 숨길 수 있고, 정해진 사이트만 연결하게 설정하는 등 웹 사용 환경을 제한하는 것도 가능하다. 또한 포워드 프록시에서 네트워크 패킷 로깅도 가능하기 때문에 보안이 매우 중요한 기업 환경등에서 많이 사용한다. ","date":"2022-03-13","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/:1:0","tags":["forward-proxy","reverse-proxy"],"title":"프록시 서버","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/"},{"categories":["web"],"content":"리버스 프록시(Reverse Proxy) 리버스 프록시는 서버와 인터넷 사이에 위치해서 서버의 응답을 대신 클라이언트에게 전달해주는 역할을 한다. 리버스 프록시는 포워드 프록시의 가장 큰 차이점은 리버스 프록시는 포워드 프록시와 다르게 인터넷과 서버 사이에 위치한다는 점이다. 리버스 프록시를 통해 얻는 이점은 다음과 같다. 로드밸런싱(Load Balancing) 이 가능하다. 클라이언트의 요청이 많아지면 서버는 과부하로 동작을 멈추게 될 수 있다. 이러한 문제를 방지하기 위해서는 여러대의 서버에게 적절하게 트래픽을 나눠주어야 한다. 이러한 방법을 로드밸런싱이라고 한다. 보안상의 이유로 클라이언트가 직접서버에 접근하는 것을 원하지 않는 경우, 리버스 프록시를 통해 클라이언트가 간접적으로 서버에 접근할 수 있도록 만들 수 있다. 이 경우 리버스 프록시가 방화벽 역할을 한다고도 볼 수 있다. ","date":"2022-03-13","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/:2:0","tags":["forward-proxy","reverse-proxy"],"title":"프록시 서버","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/"},{"categories":["web"],"content":"참고 개발자가 되기 위해 꼭 알아야 하는 IT 용어, 비제이리퍼블릭 ","date":"2022-03-13","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/:3:0","tags":["forward-proxy","reverse-proxy"],"title":"프록시 서버","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/"},{"categories":["설계방법론"],"content":"DIP(Dependency Inversion Principle) 우리가 다루는 모듈은 고수준 모듈과 저수준 모듈로 나눌 수 있다. 고수준 모듈이란 의미있는 단일 기능을 제공하는 모듈이며, 저수준 모듈은 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현인 모듈이다. Layered Architecture 상에서 Application 및 Domain 등의 고수준 모듈은 Infrastructure라는 저수준 모듈을 의존한다. 그 결과, 구현 부분의 변경에 유연하지 못하고 테스트하기 어렵다는 문제점이 발생한다. DIP(Dependency Inversion Principle)이란 의존 관계를 역전시켜서 저수준 모듈이 고수준 모듈에 의존하도록 구현하는 것을 의미한다. 고수준 모듈이 저수준 모듈을 직접 의존하는 것이 아니라, 저수준 모듈이 인터페이스 등 추상을 매개체로 고수준 모듈을 참조하도록 한다. 이를 통해 구현 기술과 관련된 종속성을 쉽게 제거할 수 있다. ","date":"2022-03-09","objectID":"/dependency-inversion-principle/:1:0","tags":["solid"],"title":"Dependency Inversion Principle","uri":"/dependency-inversion-principle/"},{"categories":["설계방법론"],"content":"DIP 예제 public interface PlatformContributionCalculator { Contribution calculate(String accessToken, String username); } @RequiredArgsConstructor @Component public class GithubContributionCalculator implements PlatformContributionCalculator { @Value(\"${github.contribution.url}\") private final String url; public Contribution calculate(String accessToken, String username) { HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.setBearerAuth(accessToken); RequestEntity\u003cVoid\u003e requestEntity = RequestEntity .get(url) .headers(httpHeaders) .build(); RestTemplate restTemplate = new RestTemplate(); return restTemplate.exchange(requestEntity, Contribution.class) .getBody(); } } @RequiredArgsConstructor @Transactional @Service public class UserService { private final UserRepository userRepository; private final PlatformContributionCalculator platformContributionCalculator; public ContributionResponseDto calculateContributions(ContributionRequestDto requestDto) { User user = userRepository.findByName(requestDto.getUsername()) .orElseThrow(InvalidUserException::new); Contribution contribution = platformContributionCalculator .calculate(requestDto.getAccessToken(), user.getName()); return ContributionResponseDto.builder() .starsCount(contribution.getStarsCount()) .commitsCount(contribution.getCommitsCount()) .prsCount(contribution.getPrsCount()) .issuesCount(contribution.getIssuesCount()) .reposCount(contribution.getReposCount()) .build(); } } Application 계층이 Infrastructure 계층의 구현체가 아닌 Domain 계층의 PlatformContributionCalculator 인터페이스를 의존하도록 구현한다. 만약 요구사항 변경으로 인해 저수준 모듈이 GitHub 플랫폼 연동에서 GitLab 플랫폼 연동으로 변경되더라도, 고수준 모듈에서의 변경을 최소화할 수 있게 된다. @Autowired private UserRepository userRepository; private UserService userService; @BeforeEach void setUp() { PlatformContributionCalculator platformContributionCalculator = (accessToken, username) -\u003e { // do something }; userService = new UserService(userRepository, platformContributionCalculator); } 테스트를 진행할 때 PlatformContributionCalculator에 적합한 Mock Object를 주입할 수 있게 된다. 따라서 GitHub 서버가 아닌 Mock 서버로 API 요청을 보내게끔 테스트 대역을 조절함으로써, Access Token으로 인한 문제에서 벗어나 자동화된 테스트를 쉽게 작성할 수 있다. @TestConfiguration public class InfrastructureTestConfiguration { @Bean public PlatformContributionCalculator platformContributionCalculator() { return new MockContributionCalculator(); } } 테스트 클래스에 정의하는 것이 번거롭다면 대역을 테스트용 Bean으로 주입해 여러 통합 테스트에서 사용할 수 있다. ","date":"2022-03-09","objectID":"/dependency-inversion-principle/:2:0","tags":["solid"],"title":"Dependency Inversion Principle","uri":"/dependency-inversion-principle/"},{"categories":["설계방법론"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-21-dip/ ","date":"2022-03-09","objectID":"/dependency-inversion-principle/:3:0","tags":["solid"],"title":"Dependency Inversion Principle","uri":"/dependency-inversion-principle/"},{"categories":["설계방법론"],"content":"디미터의 법칙(Law of Demeter) 디미터의 법칙은 “Object-Oriented Programming: An Objective Sense of Style” 에서 처음으로 소개되었다. Demeter라는 프로젝트를 진행하던 개발자들은 어떤 객체가 다른 객체에 대해 지나치게 많이 알다보니, 결합도가 높아지고 좋지 못한 설계를 야기한다는 것을 발견하였다. 그래서 이를 개선하고자 객체에게 자료를 숨기는 대신 함수를 공개하도록 하였는데, 이것이 바로 디미터의 법칙이다. 즉, 디미터의 법칙은 다른 객체가 어떠한 자료를 갖고 있는지 속사정을 몰라야 한다는 것을 의미하며, 이러한 이유로 Don’t Talk to Strangers(낯선 이에게 말하지 마라) 또는 Principle of least knowledge(최소 지식 원칙) 으로도 알려져 있다. 또는 직관적으로 이해하기 위해 여러 개의 .(도트)을 사용하지 말라는 법칙으로도 많이 알려져 있으며, 디미터의 법칙을 준수함으로써 캡슐화를 높혀 객체의 자율성과 응집도를 높일 수 있다. 객체 지향 프로그래밍에서 가장 중요한 것은 “객체가 어떤 데이터를 가지고 있는가?“가 아니라, “객체가 어떤 메세지를 주고 받는가?\" 이다. 그렇기에 디미터의 법칙은 객체 지향 프로그래밍에서 상당히 중요한 개념인데, 디미터의 법칙이 위배된다는 것은 올바른 객체 지향 프로그래밍을 하지 못하고 있다는 증거이기도 하다. ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:1:0","tags":["oop","law-of-demeter"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["설계방법론"],"content":"디미터(Demeter)의 법칙 예시 ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:2:0","tags":["oop","law-of-demeter"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["설계방법론"],"content":"디미터의 법칙을 위반하는 코드 예를 들어 서울에 살고 있는 어떤 사용자에게 알림을 보내주는 함수를 구현한다고 하자. 이를 구현하기 위해 우리는 다음과 같은 User 객체와 Address 객체를 필요로 할 것이고, User객체는 Address라는 주소 객체를 가지고 있을 것이다. @Getter public class User { private String email; private String name; private Address address; } @Getter public class Address { private String region; private String details; } 이제 어떤 사용자가 서울에 살고 있으면 알림을 보내주는 함수를 다음과 같이 구현하였다고 하자. @Service public class NotificationService { public void sendMessageForSeoulUser(final User user) { if (\"서울\".equals(user.getAddress().getRegion())) { sendNotification(user); } } } 위와 같이 구현된 코드는 정말 흔하게 볼 수 있는 코드이지만, 디미터의 법칙을 위반하고 있는 코드이며 객체지향스럽지 못하다. 왜냐하면 우리는 객체에게 메세지를 보내는 것이 아니라 객체가 가지는 자료를 확인하고 있으며, 다른 객체가 어떠한 자료를 갖고 있는지 지나치게 잘 알기 때문이다. 우리는 Getter 메소드를 통해 user객체가 email, name, address를 가지고 있음을 파악할 수 있다. 그렇기에 우리는 위의 코드를 객체 지향스러우며 디미터의 법칙을 준수하도록 수정할 필요가 있다. ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:2:1","tags":["oop","law-of-demeter"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["설계방법론"],"content":"디미터의 법칙을 준수하는 코드 우리는 Address 객체의 데이터를 통해 사용자의 지역을 파악하는 것이 아니라, Address의 객체에 메세지를 보내서 서울 지역에 사는지 파악하도록 구현해야 한다. public class Address { private String region; private String details; public boolean isSeoulRegion() { return \"서울\".equals(region); } } public class User { private String email; private String name; private Address address; public boolean isSeoulUser() { return address.isSeoulRegion(); } } 위와 같이 객체에게 보내는 메세지를 구현하면 불필요한 @Getter들 역시 지워줄 수 있고, User 객체와 Address 객체가 어떠한 데이터들을 지니고 있는지 모른 채 메세지를 보낼 수 있다. 그리고 기존의 알림을 보내는 로직을 다음과 같이 수정할 수 있다. @Service public class NotificationService { public void sendMessageForSeoulUser(final User user) { if (user.isSeoulUser()) { sendNotification(user); } } } 그리고 새롭게 작성된 코드를 살펴보면, 기존의 user.getAddress().getRegion() 처럼 여러 개의 .(도트)을 사용하여 참조하지 않기 때문에 디미터의 법칙을 잘 준수하고 있다. ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:2:2","tags":["oop","law-of-demeter"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["설계방법론"],"content":"참고 https://mangkyu.tistory.com/147 ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:3:0","tags":["oop","law-of-demeter"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["설계방법론"],"content":"객체지향과 캡슐화 객체는 캡슐화된 상태와 외부에 노출되어 있는 행동을 갖고 있으며, 다른 객체와 메시지를 주고 받으면서 협력한다. 객체는 메시지를 받으면 객체 그에 따른 로직(행동)을 수행하게 되고, 필요하다면 객체 스스로 내부의 상태값도 변경한다. 간단히 말해서 객체지향 프로그래밍은 객체가 스스로 일을 하도록 하는 프로그래밍이다. 상태를 가지는 객체를 추가했다면 객체가 제대로 된 역할을 하도록 구현해야 한다. 즉 객체가 로직을 구현하도록 한다. 상태 데이터를 꺼내 로직을 처리하도록 구현하지 말고 객체에 메시지를 보내 일을 하도록 해야한다. ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:1:0","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["설계방법론"],"content":"캡슐화 예제 ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:2:0","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["설계방법론"],"content":"캡슐화를 위반하는 코드 자동차 경주 게임의 예시 코드를 보자. public class Cars { public static final String DELIMITER = \",\"; public static final int MINIMUM_TEAM = 2; private List\u003cCar\u003e cars; public Cars(String inputNames) { String[] names = inputNames.split(DELIMITER, -1); cars = Arrays.stream(names) .map(name -\u003e new Car(name.trim())) .collect(Collectors.toList()); validateCarNames(); } ... public List\u003cString\u003e findWinners() { final int maximum = cars.stream() .map(car -\u003e car.getPosition()) .max(Integer::compareTo) .get(); return cars.stream() .filter(car -\u003e car.getPosition() == maximum) .map(Car::getName) .collect(Collectors.toList()); } ... } 여러 자동차들 중 position값이 제일 큰 우승 자동차(들)를 구하는 findWinners() 메소드를 살펴보자. Car 객체에서 getPosition() 을 사용해 position 상태값을 직접 꺼내 비교한다. 그러나, Cars에서 position 값을 비교하는 로직을 수행하는 게 맞을까? Car의 접근 제한자가 private인 멤버변수 position 값 끼리 비교하는 로직이다. 따라서 Car 객체에게 position 값을 비교할 또 다른 Car 객체를 넘겨주고 Car끼리 position을 비교해야 한다. Cars가 아니라 Car에서 해야 하는 일인 것이다. ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:2:1","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["설계방법론"],"content":"캡슐화를 준수하는 코드 Car 객체 내에서 같은 자동차끼리 position 값을 비교하고, Car 객체 내에서 maximum 과 일치하는지 비교하도록 Cars의 로직을 Car 안으로 옮기도록 하자. 즉, Car 객체에게 position 값을 비교할 수 있도록 메시지를 보내고, Car 객체에게 maximum 값과 자신의 position 값이 같은지 물어보는 메시지를 보내 getPosition() 을 사용하지 않도록 리팩토링하면 결과는 다음과 같다. public class Car implements Comparable\u003cCar\u003e { ... public boolean isSamePosition(Car other) { return other.position == this.position; } @Override public int compareTo(Car other) { return this.position - other.position; } ... } public class Cars { ... public List\u003cString\u003e findWinners() { final Car maxPositionCar = findMaxPositionCar(); return findSamePositionCars(maxPositionCar); } private Car findMaxPositionCar() { Car maxPositionCar = cars.stream() .max(Car::compareTo) .orElseThrow(() -\u003e new IllegalArgumentException(\"차량 리스트가 비었습니다.\")); } private List\u003cString\u003e findSamePositionCar(Car maxPositionCar) { return cars.stream() .filter(maxPositionCar::isSamePosition) .map(Car::getName) .collect(Collectors.toList()); } } getPosition() 을 없애는 방향으로 리팩토링 한 코드이다. Car에서 Comparable을 상속받아 compareTo()를 구현해 Car내에서 자동차끼리 비교를 해준다. max를 통해 cars 중, 최대 길이의 position을 가진 Car를 찾을 수 있다. 또, isSamePosition()을 구현해 Car 내에서 직접 position 값을 비교할 수 있게 된다. ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:2:2","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["설계방법론"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/ ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:3:0","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["java"],"content":"Pure Java, JDK Dynamic Proxy, CGLib Dynamic Proxy를 이용하여 문자열을 대문자로 변환하는 프록시를 구현해보도록 하자. 인터페이스와 타겟 클래스는 다음과 같다. public interface Hello { String sayHello(String name); String sayHi(String name); String sayThankyou(String name); } public class HelloTarget implements Hello { @Override public String sayHello(String name) { return \"Hello \" + name; } @Override public String sayHi(String name) { return \"Hi \" + name; } @Override public String sayThankyou(String name) { return \"Thankyou \" + name; } } 예상 결과는 다음과 같다. HELLO YYOUNGEUN HI YYOUNGEUN THANKYOU YYOUNGEUN ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:0:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Pure Java Proxy public class HelloProxy implements Hello { HelloTarget helloTarget = new HelloTarget(); @Override public String sayHello(String name) { return helloTarget.sayHello(name).toUpperCase(); } @Override public String sayHi(String name) { return helloTarget.sayHi(name).toUpperCase(); } @Override public String sayThankyou(String name) { return helloTarget.sayThankyou(name).toUpperCase(); } } public class Main { public static void main(String[] args) { String name = \"yyoungeun\"; HelloProxy proxy = new HelloProxy(); System.out.println(proxy.sayHello(name)); System.out.println(proxy.sayHi(name)); System.out.println(proxy.sayThankyou(name)); } } 순수 Java Proxy 구현은 다음과 같은 문제가 있다. 인터페이스에 대해서 모든 메서드를 직접 구현해야 한다. 동일한 액션이 있을경우 중복이 발생한다. ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:1:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"JDK Dynamic Proxy 다이나믹 프록시는 InvocationHandler를 통해 위의 두 문제를 해결한다. Reflection API를 사용하는 invoke 메서드를 구현 함으로서 proxy를 수행한다. 핵심은 타깃의 인터페이스를 기준으로 Proxy를 생성해준다는 점이다. Spring AOP는 JDK Dynamic Proxy를 기반으로 AOP 기술을 구현하였다. 프록시 인스턴스를 만드는 메소드는 다음과 같다. Object Proxy.newProxyInstance(ClassLoader, Interfaces, InvocationHandler) 첫 번째 인자: 프록시를 만들 클래스 로더 두 번째 인자: 어떤 인터페이스에 대해 프록시를 만들 것인지 명시 세 번째 인자: InvocationHandler 인터페이스의 구현체 리턴 값: 동적으로 만든 프록시 객체 import java.lang.reflect.Proxy; public class Main { public static void main(String[] args) { String name = \"yyoungeun\"; Hello proxy = (Hello) Proxy.newProxyInstance( Main.class.getClassLoader(), new Class[]{Hello.class}, new UpperHandler(new HelloTarget()) ); System.out.println(proxy.sayHello(name)); System.out.println(proxy.sayHi(name)); System.out.println(proxy.sayThankyou(name)); } } import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; @AllArgsConstructor class UpperHandler implements InvocationHandler { Object target; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object invoke = method.invoke(target, args); if (invoke instanceof String \u0026\u0026 method.getName().startsWith(\"say\")) return ((String) invoke).toUpperCase(); else return invoke; } } InvocationHandler는 invoke()라는 메소드 하나만 가지고 있는 인터페이스이다. invoke() 메소드는 다이나믹하게 생성될 프록시의 메소드가 호출됐을 때 호출되는 메소드로, 여기서 어떤 메소드의 기능을 확장할지 결정할 수 있고, 확장된 기능을 구현할 수 있다. JDK Dynamic Proxy는 다음과 같은 단점이 있다. Advise 대상이든 아니든 모든 Method Call 마다 reflection API의 invoke를 실시한다. 인터페이스 기반의 Proxy이기 때문에 모든 Target Class는 Interface를 implement 하고 있어야 한다. ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:2:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"CGLIB(Code Generator Library)을 통한 Dynamic Proxy 실제 바이트 코드를 조작하여 JDK Dynamic Proxy 보다 상대적으로 빠르다. 그러나 final이나 private으로 선언된 경우에는 해당 행위에 대해서 Aspect를 적용할 수 없다. CGLib은 클래스를 상속받아 Proxy를 생성해 주므로 Spring Boot에는 CGLib 방식을 기본 Proxy 생성 방법으로 사용하고 있다. import org.springframework.cglib.proxy.Enhancer; import org.springframework.cglib.proxy.MethodInterceptor; import org.springframework.cglib.proxy.MethodProxy; public class Main { public static void main(String[] args) { String name = \"yyoungeun\"; MethodInterceptor methodInterceptor = new MethodInterceptor() { final HelloTarget helloTarget = new HelloTarget(); @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { Object invoke = method.invoke(helloTarget, args); if (invoke instanceof String \u0026\u0026 method.getName().startsWith(\"say\")) return ((String) invoke).toUpperCase(); else return invoke; } }; Hello proxy = (HelloTarget) Enhancer.create(HelloTarget.class, methodInterceptor); System.out.println(proxy.sayHello(name)); System.out.println(proxy.sayHi(name)); System.out.println(proxy.sayThankyou(name)); } } ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:3:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"참고 https://lob-dev.tistory.com/entry/Java%EC%97%90%EC%84%9C-%EA%B5%AC%ED%98%84%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-Proxy-%EB%93%A4-Pure-JDK-CGLIB https://live-everyday.tistory.com/217 https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:4:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"DTO Data Transfer Object의 약자로 계층(Layer) 간 데이터를 전달하는 객체이다. 조금 더 쉽게 말하면, 데이터를 담아서 전달하는 바구니라고 할 수 있다. Controller는 View와 도메인 Model의 데이터를 주고 받을 때 별도의 DTO 를 주로 사용한다. 도메인 객체를 View에 직접 전달할 수 있지만, 민감한 도메인 비즈니스 기능이 노출될 수 있으며 Model과 View 사이에 의존성이 생기기 때문이다. DTO는 데이터 접근 메서드(Getter, Setter), 생성자 외에 기능을 갖지 않는다. (정렬, 직렬화 등 데이터 표현을 위한 기능은 가질 수 있다.) 데이터의 캡슐화를 통해 유연한 대응이 가능하여 데이터 요청 수의 감소 효과가 있다. ","date":"2022-03-04","objectID":"/dto-vs-vo/:1:0","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"VO Value Object의 약자로 값을 자체로 의미를 갖는 객체이다. 변하지 않는 값을 갖는 객체로 값이 변하지 않음을 보장 하여 코드의 안정성을 높인다. 서로 다른 이름을 가진 VO의 인스턴스가 모든 속성이 같다면 동일한 객체라고 판단한다. 이를 위해 VO 클래스는 equals와 hasCode를 오버라이딩 해야 한다. DTO와 달리 데이터 접근 메서드 이외의 로직을 포함할 수 있다. ","date":"2022-03-04","objectID":"/dto-vs-vo/:2:0","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"공통점과 차이점 ","date":"2022-03-04","objectID":"/dto-vs-vo/:3:0","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"공통점 레이어 간 데이터를 전달할 때 사용 가능하다. ","date":"2022-03-04","objectID":"/dto-vs-vo/:3:1","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"차이점 구분 DTO VO 용도 레이어 간 데이터 전달 값 자체 표현 동등 결정 속성값이 모두 같다고 해서 같은 객체 X 속성값이 모두 같으면 같은 객체 가변/불변 setter존재 시, 가변 setter 비 존재 시 불변 불변 로직 데이터 접근(getter, setter) 이외의 기능을 갖지 않음 데이터 접근 이외의 특정한 비즈니스 로직을 가질 수 있음 ","date":"2022-03-04","objectID":"/dto-vs-vo/:3:2","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"참고 https://backtony.github.io/interview/2021-11-13-interview-3/ ","date":"2022-03-04","objectID":"/dto-vs-vo/:4:0","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"volatile란? volatile 키워드는 java 변수를 Main Memory에 저장하겠다라는 것을 명시한다. 즉 매번 변수의 값을 읽을 때마다 CPU cache에 저장된 값이 아닌 Main Memory에서 읽는 것이다. 또한 변수의 값을 쓸 때마다 Main Memory까지 작성한다. ","date":"2022-03-03","objectID":"/volatile/:1:0","tags":["volatile"],"title":"volatile","uri":"/volatile/"},{"categories":["java"],"content":"volatile 키워드의 필요성 멀티쓰레드 어플리케이션에서의 non-volatile 변수에 대한 작업은 성능상의 이유로 CPU 캐시를 이용한다. 둘 이상의 CPU가 탑재된 컴퓨터에서 어플리케이션을 실행한다면, 각 쓰레드는 변수를 각 CPU의 캐시로 복사하여 읽어들인다. 쓰레드가 변경한 값이 메인 메모리에 저장되지 않아서 다른 쓰레드가 이 값을 볼 수 없는 상황을 ‘가시성’ 문제라 한다. 한 쓰레드의 변경(update)이 다른 쓰레드에게 보이지 않는다. 변수에 volatile 키워드를 선언한다면 이 변수에 대한 쓰기 작업은 즉각 메인 메모리로 이루어질 것이고, 읽기 작업 또한 메인 메모리로부터 다이렉트로 이루어질 것이다. 따라서 가시성 문제가 해결된다. ","date":"2022-03-03","objectID":"/volatile/:2:0","tags":["volatile"],"title":"volatile","uri":"/volatile/"},{"categories":["java"],"content":"volatile 사용 시 주의할 점 한 변수를 두고 오직 한 쓰레드만 이 변수에 읽기/쓰기 작업을 하고, 다른 쓰레드들은 읽기 작업만 하는 상황에서라면 이 때는 volatile 선언이 유효하다. 읽기 작업을 수행하는 쓰레드들은 언제나 이 변수의 가장 최근 수정된 값을 봐야하고, volatile 은 이를 보장해준다. 그러나 하나의 Thread가 아닌 여러 Thread가 write하는 상황에서는 적합하지 않다. 여러 Thread가 write하는 상황이라면 synchronized를 통해 변수 read \u0026 write의 원자성(atomic)을 보장해야 한다. volatile 변수의 읽기/쓰기는 메인 메모리를 이용한다. 메인 메모리로부터 데이터를 읽고 쓰는 작업은 CPU 캐시를 이용하는 것 보다 많은 비용이 요구된다. 따라서 변수 값 일치을 보장해야 하는 경우에만 volatile 사용하는 것이 좋다. volatile 선언은 JVM 의 성능 향상을 위한 기술인 코드 재정리를 막기도 한다. 그러므로 volatile 키워드는 변수의 가시성 보장이 반드시 필요한 경우에만 사용되어야 한다. ","date":"2022-03-03","objectID":"/volatile/:3:0","tags":["volatile"],"title":"volatile","uri":"/volatile/"},{"categories":["java"],"content":"참고 https://junghyungil.tistory.com/99 ","date":"2022-03-03","objectID":"/volatile/:4:0","tags":["volatile"],"title":"volatile","uri":"/volatile/"},{"categories":["java"],"content":"싱글톤 패턴은 프로세스(Java에서는 JVM) 내에 1개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역 접근점을 제공하는 패턴이다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:0:0","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"즉시 초기화(Eager Initialization) 싱글톤 패턴을 가장 단순하게 구현하는 방법은 외부에서 해당 클래스의 인스턴스를 생성할 수 없도록 private 생성자를 만들고, 1개의 인스턴스만을 초기화(public static final)하여 이에 대한 접근을 제공하는 방식이다. public class SimpleSingleton { //public static final으로 1개의 인스턴스만을 초기화하여 접근점을 제공하고, 2개 이상의 인스턴스를 못 만들게 한다. public static final SimpleSingleton INSTANCE = new SimpleSingleton(); private SimpleSingleton(){ //생성자는 private으로 만들어 외부에서 새로운 인스턴스를 만들 수 없도록 한다. } } ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:0","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"지연 초기화(Lazy Initialization) Singleton의 static 필드나 메소드를 사용해야 하지만, 싱글톤 객체는 초기화시키지 않고 싶은 경우가 있을 수 있다. 이러한 경우에는 Lazy Initialization 방식을 사용할 수 있다. Lazy Initialization 방식은 Singleton 객체가 필요할 때 이를 초기화(초기화되어 있지 않은 경우에만)하고, Singleton 객체를 반환받을 수 있는 진입점(static 메소드)를 제공하는 방식이다. Singleton.java public class Singleton { public static Singleton INSTANCE; private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } public static Singleton getInstance(){ if(INSTANCE == null) INSTANCE = new Singleton(); return INSTANCE; } public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Singleton singleton = Singleton.getInstance(); } } 실행 결과 Hello world Simple singleton instance initialized. 명시적으로 getInstance 메소드를 호출하지 않는 이상 Singleton 객체(INSTANCE)가 초기화되지 않기 때문에, Eager Initialization 방식의 단점을 보완할 수 있다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:2:0","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Multi Thread 환경에서의 문제점 Lazy Initialization 방식은 Multi Thread 환경에서의 문제점을 가지고 있다. Multi Thread 환경에서 서로 다른 Thread들이 동시에 getInstance를 호출한다고 생각해보자. 위의 getInstance는 Multi Thread 환경에 대한 고려가 되어 있지 않기 떄문에, if(INSTANCE == null)이 여러번 참인 경우가 발생하여 여러 개의 객체가 생성될 수 있다. Singleton.java public class Singleton { public static final AtomicInteger NUM_INSTANCE = new AtomicInteger(0); private static Singleton INSTANCE; private Singleton() { System.out.println(\"Constructor called\"); } public static Singleton getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton(); NUM_INSTANCE.incrementAndGet(); } return INSTANCE; } public static int getNumberOfInstance() { return NUM_INSTANCE.get(); } public static void main(String[] args) throws Exception { Thread[] threads = new Thread[1000]; for (int i = 0; i \u003c threads.length; i++) { threads[i] = new Thread(new Runnable() { public void run() { Singleton.getInstance(); } }); } for (int i = 0; i \u003c threads.length; i++) { threads[i].start(); } for (int i = 0; i \u003c threads.length; i++) { threads[i].join(); } System.out.println(Singleton.getNumberOfInstance()); } } 실행 결과 Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called 24 ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:2:1","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Multi Thread 환경에서 Lazy Initialization 방법 정적 팩터리 메서드에 동기화 키워드 사용하기 Singleton 객체를 생성하는 정적 팩터리 메서드 자체에 synchronized를 붙여주거나, 내부 초기화 구문을 synchronized 구문으로 감싸주는 방법이 있다. 정적 팩터리 메서드 자체에 synchronized 붙이기 기존의 public static Singleton getInstance() 를 public static synchronized Singleton getInstance()와 같이 바꾸는 방법이다. 내부 초기화 구문을 synchronized로 감싸주기 초기화에 사용할 Lock 객체를 만들고, Singleton 객체의 초기화 여부 확인 시 동기화하는 방법이다. private static Object lock = new Object(); public static Singleton getInstance() { synchronized (lock) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } return INSTANCE; } 동기화 방식은 Multi Thread 환경에서 객체를 안전하게 1개를 생성할 수 있지만, 객체 획득 시의 병렬성을 잃어버린다는 단점이 존재한다. 또한 초기 호출 이후에는 객체 초기화 확인 구문(if(INSTANCE) == null))이 계속해서 참을 반환하기 때문에 불필요한 Lock을 거는 상황이 발생하게 된다. DCL(Double-Checked-Locking) 방식 사용하기 Multi Thread 환경에서 병렬성을 확보하기 위해서는 동기화 구문을 필요한 곳에서만 사용해야 한다. DCL 방식은 동기화를 최소화하므로써 불필요한 Lock을 거는 단점을 없앤 방식이다. private static Object lock = new Object(); public static Singleton getInstance() { if (INSTANCE == null) { synchronized (lock) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } } return INSTANCE; } 첫번째 if문을 통해 객체가 초기화되었는지 검사할 때는 동기화를 하지 않고, 두번째 if문을 통해 객체가 초기화되었는지 검사할 때는 동기화를 수행한다. getInstance 호출 후 충분한 시간이 지나 동기화가 필요 없을 때는 첫번째 if문만 실행하므로써 동기화에 따른 병렬성 감소를 감소시킬 수 있는 방식이다. 언뜻 보기에는 동기화 문제도 없고 성능적으로 뛰어난 방식이라고 생각할 수 있다. 그러나 위 코드는 문제점을 가지고 있다. 위 DCL 코드의 문제점과 해결 위 DCL 코드는 JVM의 Low-Level 동작 방식때문에 문제가 발생한다. 예를 들어 2개의 Thread(A, B)가 getInstance를 호출했다고 생각해보자. Thread A는 INSTANCE = new Singleton() 구문을 수행하고 있고, 이 때 Thread B는 첫번째 if문에서 INSTANCE의 초기화 여부를 검사(if(INSTANCE == null))하고 있다. 여기서 Thread A가 수행하는 ‘객체 생성’과 ‘변수 할당’ 구문은 한번에 실행되지 않고, 특정 시점에는 INSTANCE에는 일부만 초기화된 객체가 할당되어 있을 수 있다. 이 때 Thread B는 non-null check만 하기 때문에 일부만 초기화된 객체를 가져다 쓰게 되어 Crash가 발생할 수 있다. 이러한 문제점을 해결하기 위해서는 INSTANCE 객체에 volatile 키워드를 붙여주면 된다. volatile은 원자적으로 동작하기 때문에 첫번째 if문이 완전히 초기화된 객체를 얻거나 아닌 경우 둘 중 하나로 동작하게 된다. Lazy Holder 방식 사용하기 Multi Thread 환경에서도 잘 동작하고, Lazy Initialization도 가능한 방식이다. public class LazySingletonHolder { public static Singleton getInstance() { return Singleton.INSTANCE; } public static class Singleton { private static final Singleton INSTANCE = new Singleton(); private Singleton() { } } } 위 코드를 보면 ‘Lazy Initialization 방식이 아니지 않은가?’ 라고 생각할 수 있다. LazySingletonHolder의 getInstance에서 Singleton 클래스의 INSTANCE를 그대로 반환하기 때문이다. 그러나 Singleton 클래스의 INSTANCE는 Singleton 클래스의 클래스 로딩이 일어날 때 발생하게 되고, 클래스 로딩은 LazySingletonHolder의 getInstance가 호출되었을 때 발생한다. 또한 INSTANCE는 static final 이기 때문에 클래스 로딩에 의해 1회만 초기화되고, 이로써 Multi Thread 환경에서의 문제점도 없어지게 된다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:2:2","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"참고 https://leeyh0216.github.io/posts/singleton/ ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:3:0","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"각 자료구조는 필요에 따라 선택되고 활용된다. Map 인터페이스의 구현체로는 HashMap, HashTable, ConcurrentHashMap 등이 있다. Map 인터페이스를 구현하면, \u003cKey, Value\u003e 형태를 띈다. 그렇다면 이 셋은 무슨 특징을 가지고, 서로 어떤 차이가 있을까? 이번 글에서 해당 구현체를 비교하며 확인해보자. ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:0:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"HashMap key와 value에 null을 허용한다. 동기화를 보장하지 않는다. HashMap은 thread-safe하지 않아, 싱글 쓰레드 환경에서 사용하는 게 좋다. 한편, 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다. 결국 HashTable과 ConcurrentHashMap보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어진다. public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable { ... public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u003e= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:1:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"HashTable key와 value에 null을 허용하지 않는다. 동기화를 보장한다. HashTable은 thread-safe하기 때문에, 멀티 쓰레드 환경에서 사용할 수 있다. 이는 데이터를 다루는 메소드(get(), put(), remove() 등)에 synchronized 키워드가 붙어 있다. 해당 키워드는 메소드를 호출하기 전에 쓰레드간 동기화 락을 건다. 그래서 멀티 쓰레드 환경에서도 데이터의 무결성을 보장한다. 그러나, 쓰레드간 동기화 락은 매우 느린 동작이라는 단점이 있다. public class Hashtable\u003cK,V\u003e extends Dictionary\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, java.io.Serializable { ... public synchronized V put(K key, V value) { if (value == null) { throw new NullPointerException(); } Entry\u003c?,?\u003e tab[] = table; int hash = key.hashCode(); int index = (hash \u0026 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry\u003cK,V\u003e entry = (Entry\u003cK,V\u003e)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) \u0026\u0026 entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } addEntry(hash, key, value, index); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:2:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"ConcurrentHashMap key와 value에 null을 허용하지 않는다. 동기화를 보장한다. ConcurrentHashMap은 thread-safe하기 때문에, 멀티 쓰레드 환경에서 사용할 수 있다. 이 구현체는 HashMap의 동기화 문제를 보완하기 위해 나타났다. 동기화 처리를 할 때, 어떤 Entry를 조작하는 경우에 해당 Entry에 대해서만 락을 건다. 그래서 HashTable보다 데이터를 다루는 속도가 빠르다. 즉, Entry 아이템별로 락을 걸어 멀티 쓰레드 환경에서의 성능을 향상시킨다. public class ConcurrentHashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements ConcurrentMap\u003cK,V\u003e, Serializable { ... public V put(K key, V value) { return putVal(key, value, false); } final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) { throw new NullPointerException(); } int hash = spread(key.hashCode()); int binCount = 0; for (Node\u003cK,V\u003e[] tab = table;;) { Node\u003cK,V\u003e f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) { if (casTabAt(tab, i, null, new Node\u003cK,V\u003e(hash, key, value, null))) break; } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh \u003e= 0) { binCount = 1; for (Node\u003cK,V\u003e e = f;; ++binCount) { K ek; if (e.hash == hash \u0026\u0026 ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node\u003cK,V\u003e pred = e; if ((e = e.next) == null) { pred.next = new Node\u003cK,V\u003e(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { Node\u003cK,V\u003e p; binCount = 2; if ((p = ((TreeBin\u003cK,V\u003e)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { if (binCount \u003e= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:3:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"정리 HashMap HashTable ConcurrentHashMap key와 value에 null 허용 O X X 동기화 보장(Thread-safe) X O O 추천 환경 싱글 쓰레드 멀티 쓰레드 멀티 쓰레드 ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:4:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"결론 싱글 쓰레드 환경이면 HashMap을, 멀티 쓰레드 환경이면 HashTable이 아닌 ConcurrentHashMap을 쓰자. 그 이유는 HashTable보다 ConcurrentHashMap이 성능적으로 우수하기 때문이다. 앞에서도 언급했듯이 HashTable은 쓰레드간 락을 걸어 데이터를 다루는 속도가 느리다. 반면, ConcurrentHashMap은 Entry 아이템별로 락을 걸어 데이터를 다루는 속도가 빠르다. ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:5:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-26-hashmap-hashtable-concurrenthashmap/ ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:6:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"Reflection API란? 아래와 같이 Car 클래스가 존재한다. public class Car { private final String name; private int position; public Car(String name, int position) { this.name = name; this.position = position; } public void move() { this.position++; } public int getPosition() { return position; } } 자바의 특징 중 하나인 다형성 덕분에 아래와 같이 객체 생성이 가능하다. public static void main(String[] args) { Object obj = new Car(\"foo\", 0); } 자바는 컴파일러를 사용한다. 즉 컴파일 타임에 타입이 결정된다. obj라는 이름의 객체는 컴파일 타임에 Object로 타입이 결정됐기 때문에 Object 클래스의 인스턴스 변수와 메서드만 사용할 수 있다. 따라서 obj라는 이름의 객체는 Car 클래스의 move 메서드를 사용할 수 없다. 그러므로 아래와 같은 코드는 필연적으로 컴파일 에러가 난다. public static void main(String[] args) { Object obj = new Car(\"foo\", 0); obj.move(); // 컴파일 에러 발생 java: cannot find symbol } 생성된 obj라는 객체는 Object 클래스라는 타입만 알 뿐, Car 클래스라는 구체적인 타입은 모른다. 결국 자바는 구체적인 클래스를 모르면 해당 클래스의 정보에 접근할 수 없다. Reflection API는 이렇게 불가능한 일을 마법처럼 가능하게 해준다. 위에서 봤던 예제와 똑같은 상황에서 Reflection API를 활용해 Car 클래스의 move 메서드를 호출해보자. 리플렉션을 실행하는 메소드는 다음과 같다. Object Method.invoke(object, params) public static void main(String[] args) throws Exception { Object obj = new Car(\"foo\", 0); Class carClass = Car.class; Method move = carClass.getMethod(\"move\"); // move 메서드 실행, invoke(메서드를 실행시킬 객체, 해당 메서드에 넘길 인자) move.invoke(obj, null); Method getPosition = carClass.getMethod(\"getPosition\"); int position = (int)getPosition.invoke(obj, null); System.out.println(position); // 출력 결과: 1 } move 메서드가 실행되고 0으로 초기화했던 Car 클래스 인스턴스 변수 position이 1로 출력되는 걸 확인할 수 있다. 구체적인 클래스 Car 타입을 알지 못해도 Reflection API를 통해 move 메서드에 접근한 것이다. Class carClass2 = Class.forName(\"Car\"); 위의 예제처럼 클래스의 이름만으로도 해당 클래스의 정보를 가져올 수 있다. 다시 말해서 Reflection API를 통해 클래스의 이름만 가지고도 생성자, 필드, 메서드 등등 해당 클래스에 대한 거의 모든 정보를 가져올 수 있다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:1:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Reflection은 어떻게 가능할까? JVM이 실행되면 사용자가 작성한 자바 코드가 컴파일러를 거쳐 바이트 코드로 변환되어 Runtime Data Area에 저장된다. Reflection API는 Runtime Data Area에 저장된 정보를 활용한다. 그래서 클래스 이름만 알고 있다면 언제든 정보를 가져올 수 있는 것이다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:2:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Reflection을 어디에 활용할 수 있을까? 위에서 살펴봤던 예제 코드를 보면 멀쩡한 Car 객체를 Object 타입으로 생성하고 있다. 실제로 우리가 코드를 작성할 때는 예제와 같이 작성하지 않는다. 그러므로 우리가 코드를 작성하면서 Reflection을 활용할 일은 거의 없다. 구체적인 클래스를 모를 일이 거의 없기 때문이다. 게다가 Reflection은 마법 같은 힘을 가지고 있는 만큼 치명적인 단점들을 가지고 있다. 당연히 사용하지 않을 수 있다면 대부분의 경우 사용하지 않는 게 좋다. 치명적인 단점 중 대표적으로 성능 오버헤드가 있다. 컴파일 타임이 아닌 런타임에 동적으로 타입을 분석하고 정보를 가져오므로 JVM을 최적화할 수 없기 때문이다. 뿐만 아니라 직접 접근할 수 없는 private 인스턴스 변수, 메서드에 접근하기 때문에 내부를 노출하면서 추상화가 깨진다. 이로 인해 예기치 못한 부작용이 발생할 수 있다. 결론적으로 Reflection은 애플리케이션 개발보다는 프레임워크나 라이브러리에서 많이 사용된다. 프레임워크나 라이브러리는 사용자가 어떤 클래스를 만들지 예측할 수 없기 때문에 동적으로 해결해주기 위해 Reflection을 사용한다. 실제로 intellij의 자동완성, jackson 라이브러리, Hibernate 등등 많은 프레임워크나 라이브러리에서 Reflection을 사용하고 있다. Spring Framework에서도 Reflection API를 사용하는데 대표적으로 Spring Container의 BeanFactory가 있다. Bean은 애플리케이션이 실행한 후 런타임에 객체가 호출될 때 동적으로 객체의 인스턴스를 생성하는데 이때 Spring Container의 BeanFactory에서 리플렉션을 사용한다. Spring Data JPA 에서 Entity에 기본 생성자가 필요한 이유도 동적으로 객체 생성 시 Reflection API를 활용하기 때문이다. Reflection API로 가져올 수 없는 정보 중 하나가 생성자의 인자 정보이다. 그래서 기본 생성자가 반드시 있어야 객체를 생성할 수 있는 것이다. 기본 생성자로 객체를 생성만 하면 필드 값 등은 Reflection API로 넣어줄 수 있다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:3:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-07-16-reflection-api/ ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:4:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Garbage Collection Garbage Collection, GC는 JVM 상에서 더 이상 사용되지 않는 데이터가 할당되어있는 메모리를 해제시키는 작업이다. JVM에서 자동으로 동작하기 때문에 특별한 경우가 아니면 메모리 관리를 개발자가 직접 해줄 필요가 없다. 참조되고 있는지에 대한 개념을 reachability라고 하고, 유효한 참조를 reachable, 유효하지 않은 참조를 unreachable이라고 한다. Garbace Collector는 unreachable 한 객체들을 garbage라고 인식한다. Heap 영역 내부의 객체들은 Method Area, Stack, Native Stack에서 참조되면 reachable로 판정된다. 이렇게 reachable로 인식되게 만들어주는 JVM Runtime Area들을 root set 이라고 한다. reachable 객체가 이 참조하고 있는 다른 객체는 reachable이 된다. 반면에 root set에의해 참조되고 있지 않은 객체들은 unreachable로 판정이 되어 GC 의 대상이 된다. ","date":"2022-03-01","objectID":"/garbage-collection/:1:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Stop-The-World JVM 은 GC를 통해 여유 메모리를 확보할 수가 있다. 하지만 빈번한 GC는 프로그램의 성능을 저하시킨다. GC가 일어나면 GC를 담당하는 쓰레드를 제외한 모든 쓰레드들은 작동이 일시적으로 정지되게 되며, 이를 Stop-The-World 현상이라고 한다. 따라서 적절한 빈도의 GC가 실행되도록 하여 Stop-The-World 시간을 줄여 쓰레드가 정지되는 시간을 줄이는 것이 중요하다. ","date":"2022-03-01","objectID":"/garbage-collection/:2:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"GC 알고리즘 ","date":"2022-03-01","objectID":"/garbage-collection/:3:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Weak Generational Hypothesis Weak Generational Hypothesis 가설은 대부분의 객체는 빠르게 unreachable 한 상태로 전환이 된다고 본다. 또한, Heap 메모리 영역 기준으로 오래된 영역에서 최신 영역으로의 참조는 적게 존재한다고 가정한다. 실제로 이 가설은 여러 관찰을 통해서 높은 경향성을 가지는 것으로 증명이 되었다. ","date":"2022-03-01","objectID":"/garbage-collection/:3:1","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Mark And Sweep Algorithm 가장 기본적인 알고리즘이다. root set으로부터 출발하여, 참조되는 객체들에 대해서 마크를 한다. 이 단계를 Mark Phase라고 한다. 이후에는 마크되지 않은 객체들을 추적하여 삭제한다. 삭제하는 단계를 Sweep Phase 라고 한다. Mark And Sweep 알고리즘은 메모리가 단편화되는 단점이 있다. 메모리에서의 단편화는 데이터가 정렬되지 않은 조각으로 나뉘어져 절대적인 크기는 충분하지만 추가적으로 메모리 할당이 되기 힘든 상태를 의미한다. ","date":"2022-03-01","objectID":"/garbage-collection/:3:2","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Mark And Compact Algorithm Mark And Compact 알고리즘은 Mark And Sweep 알고리즘처럼 참조되는 객체들에 대해서 마크를 하고, 참조되지 않으면 삭제한다. 이후에 메모리를 정리하여 메모리 단편화를 해결한다. 많은 GC 방식들이 Mark And Compact 알고리즘을 바탕으로 하여 구현되어 있다. ","date":"2022-03-01","objectID":"/garbage-collection/:3:3","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Major GC 와 Minor GC ","date":"2022-03-01","objectID":"/garbage-collection/:4:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Heap의 세부 영역 Heap은 Eden, Survivor0, Survivor1, Old , Perm 으로 나누어진다. Young Gen 이라고 불리는 비교적 신생 데이터 부분은 Eden, Survivor0, Survivor1이다. Eden에는 new 키워드를 통해 새롭게 생성된 인스턴스가 위치하며, 이후에는 Survivor로 이동하게 된다. ","date":"2022-03-01","objectID":"/garbage-collection/:4:1","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Minor GC Minor GC 는 JVM 의 Young 영역에서 일어나는 GC이다. Young 에 위치한 각각의 영역이 가득 차게 되어 더 이상 새로운 객체를 생성할 수 없을 때 마크된 영역이 다음 영역으로 복사가 되면서 이루어진다. 마크가 된 영역만 복사되기 때문에 삭제는 이루어지지 않는다. ","date":"2022-03-01","objectID":"/garbage-collection/:4:2","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Major GC Major GC 는 Old 영역에서 이루어진다. 상당히 긴 시간 Stop-The-World 가 이루어지며, 이는 Java 프로그램에 영향을 준다. 이를 해결하기 위해서 여러 GC 방식들이 선택 및 적용된다. ","date":"2022-03-01","objectID":"/garbage-collection/:4:3","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"G1 GC G1 GC의 핵심은 Heap을 동일한 크기의 Region으로 나누고, 가비지가 많은 Region에 대해 우선적으로 GC를 수행하는 것이다. 그리고 G1 GC도 다른 가비지 컬렉션과 마찬가지로 2가지 GC(Minor GC, Major GC)로 나누어 수행된다. ","date":"2022-03-01","objectID":"/garbage-collection/:5:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Minor GC 한 지역에 객체를 할당하다가 해당 지역이 꽉 차면 다른 지역에 객체를 할당하고, Minor GC가 실행된다. G1 GC는 각 지역을 추적하고 있기 때문에, 가비지가 가장 많은(Garbage First) 지역을 찾아서 Mark and Sweep를 수행한다. Eden 지역에서 GC가 수행되면 살아남은 객체를 식별(Mark)하고, 메모리를 회수(Sweep)한다. 그리고 살아남은 객체를 다른 지역으로 이동시키게 된다. 복제되는 지역이 Available/Unused 지역이면 해당 지역은 이제 Survivor 영역이 되고, Eden 영역은 Available/Unused 지역이 된다. ","date":"2022-03-01","objectID":"/garbage-collection/:5:1","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Major GC(Full GC) 시스템이 계속 운영되다가 객체가 너무 많아 빠르게 메모리를 회수 할 수 없을 때 Major GC(Full GC)가 실행된다. 그리고 여기서 G1 GC와 다른 GC의 차이점이 두각을 보인다. 기존의 다른 GC 알고리즘은 모든 Heap의 영역에서 GC가 수행되었으며, 그에 따라 처리 시간이 상당히 오래 걸렸다. 하지만 G1 GC는 어느 영역에 가비지가 많은지를 알고 있기 때문에 GC를 수행할 지역을 조합하여 해당 지역에 대해서만 GC를 수행한다. 그리고 이러한 작업은 Concurrent하게 수행되기 때문에 애플리케이션의 지연도 최소화할 수 있다. G1 GC는 어떠한 GC 방식보다 처리 속도가 빠르며 큰 메모리 공간에서 멀티 프로세스 기반으로 운영되는 애플리케이션을 위해 고안되었다. 또한 G1 GC는 다른 GC 방식의 처리속도를 능가하기 때문에 Java9부터 기본 가비지 컬렉터(Default Garbage Collector)로 사용된다. ","date":"2022-03-01","objectID":"/garbage-collection/:5:2","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-08-30-jvm-gc/ ","date":"2022-03-01","objectID":"/garbage-collection/:6:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"1. 컴파일 자바 소스 파일(*.java)을 Java Compiler가 JVM이 해석할 수 있는 파일인 Java ByteCode (*.class)파일로 변환한다. Java Compiler는 Java 설치 시 Javac.exe라는 실행 파일 형태로 존재한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:1:0","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"2. Class Loader를 통해 ByteCode를 메모리(Runtime Data Area)에 배치 ClassLoader는 크게 Loading, Linking, 그리고 Initialization 3가지 역할을 한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:0","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"Loading .class 확장자를 가진 클래스 파일은 각 디렉터리에 흩어져 있다. 또한, 기본적인 라이브러리의 클래스 파일들은 $JAVAHOME_ 내부 경로에 존재한다. 각각의 클래스 파일들을 찾아서 JVM 의 메모리에 탑재해주는 역할을 하는 것이 ClassLoader의 역할이다. 클래스 로더는 .class 파일을 읽어 바이트 코드를 Runtime Data Area의 메소드 영역(Method Area)에 저장한다. 각 .class 파일은 JVM에 의해 메소드 영역에 다음의 정보들을 저장한다. 로드된 클래스를 비롯한 그의 부모 클래스의 정보 class 파일이 Class, Interface, Enum와 관련 여부 변수나 메소드의 정보 등 .class 파일이 로딩된 후에는, JVM은 힙 메모리 영역에 이 파일이 나타내는 클래스 유형의 객체를 생성한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:1","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"Linking Linking 은 로드된 클래스 파일들을 검증하고, 사용할 수 있게 준비하는 과정을 의미한다. Verification, Preparation, 그리고 Resolution이라는 세 가지 단계로 이루어진다. Verification : 클래스 파일이 유효한지를 확인하는 과정이다. 클래스 파일이 JVM 의 구동 조건대로 구현되지 않았을 경우에는 VerifyError를 던지게 된다. Preparation : 클래스 및 인터페이스에 필요한 static field 메모리를 할당하고, 이를 기본값으로 초기화한다. 기본값으로 초기화된 static field 값들은 이후 Initialization 과정에서 코드에 작성한 초기값으로 변경된다. Resolution : Symbolic Reference 값을 JVM 의 메모리 구성 요소인 Method Area 의 런타임 환경 풀을 통하여 Direct Reference 라는 메모리 주소 값으로 바꾼다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:2","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"Initialization Initialization 단계에서는 클래스 파일의 코드를 읽고 Java 코드에서의 class와 interface의 값들을 지정한 값들로 초기화한다. 여기에 static field도 포함된다. 이때, JVM 은 멀티 쓰레딩으로 작동을 하며, 같은 시간에 한 번에 초기화를 하는 경우가 있기 때문에 초기화 단계에서도 동시성을 고려해주어야 한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:3","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"3. 실행 시점에 Execution Engine에서 바이트코드를 기계어로 해석 Execution Engine은 Java Native Interface(JNI), Native Method Libraries와 상호작용하며 해석한다. Java Native Interface(JNI) : Native Method Libraries와 상호작용하고 실행에 필요한 네이티브 라이브러리(C, C++)을 제공하는 인터페이스이다. JVM은 C/C++ 라이브러리를 통해 호출할 수 있고, 특정 하드웨어와 관련된 C/C++ 라이브러리로 호출 될 수도 있다. Native Method Libraries : Execution Engine으로 인해 요구되는 네이티브 라이브러리(C,C++)의 모음이다. 해석 방식은 인터프리터 방식 혹은 JIT(Just-In-Time) Compiler 방식이 있다. 인터프리터(Interpreter) : 바이트코드를 한줄씩 해석한다. 단점은 여러번 하나의 메소드를 호출할 경우 매번 해석을 요청해야하기 때문에 비효율적이다. Just-In-Time(JIT) Compiler : 같은 코드를 매번 해석하지 않고 기계어로 번역하면서 캐싱한다. 해당 파일이 다시 기계어로 컴파일 된다면 이전 파일과 비교해서 바뀐 부분은 새롭게 컴파일하고 변동 사항이 없는 부분은 캐싱된 코드를 사용한다. 메소드의 반복 호출을 확인할 때마다 직접 네이티브 코드로 제공함으로써 효율성이 증가된다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:3:0","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"참고 https://velog.io/@zayson/%EB%B0%B1%EA%B8%B0%EC%84%A0%EB%8B%98%EA%B3%BC-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-live-study-1%EC%A3%BC%EC%B0%A8-JVM%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80 https://mygumi.tistory.com/115 ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:4:0","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"JVM의 메모리 영역은 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 세분화된다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:0:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"Method Area Method Area 에는 클래스, 인터페이스, 생성자, 메소드, Runtime Constant Pool과 static 변수 등이 저장된다. 이 영역은 JVM 당 하나만 생성이 되며 JVM 의 모든 Thread 들이 Method Area 을 공유한다. JVM 구동 시작 시에 생성이 되며, 종료 시까지 유지된다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:1:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"Heap Heap 영역에는 문자열에 대한 정보를 가진 String Pool 뿐만 아니라 실제 데이터를 가진 인스턴스, 배열 등이 저장된다. JVM 당 하나만 생성이 되고, 해당 영역이 가진 데이터는 모든 Java Stack 영역에서 참조되어 Thread 간 공유가 되므로 동기화를 신경써야 한다. Heap 영역이 가득 차게 되면 OutOfMemoryError이 발생한다. Heap 영역은 GC의 주 대상이다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:2:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"Stack Area 각 Thread 별로 따로 할당되는 영역이다. 각각의 Thread 별로 메모리를 따로 할당하기 때문에 동시성 문제에서 자유롭다. 각 Thread 들은 메소드를 호출할 때마다 Stack에 Frame 이라는 단위를 추가(push)한다. 메소드가 결과를 반환하면 해당 Frame 은 Stack 으로부터 제거(pop)가 된다. Frame 은 메소드에 대한 정보를 가지고 있는 Local Variable, Operand Stack 그리고 Constant Pool Reference로 구성이 되어 있다. Local Variable 은 메소드 안의 지역 변수들을 가지고 있다. Operand Stack은 메소드 내 연산을 위해서, 바이트 코드 명령문들이 들어있는 공간이다. Constant Pool Reference 는 Constant Pool 참조를 위한 공간이다. Java Stack 영역이 가득 차게 되면 StackOverflowError이 발생한다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:3:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"PC(Program Counter) Register Java 에서 Thread 는 각자의 메소드를 실행한다. 이때, Thread 별로 동시에 실행하는 환경이 보장되어야 하므로 최근에 실행한 명령어 주소값을 저장할 공간이 필요한데, 이 부분을 PC Registers 영역이 관리하여 추적한다. Thread 들은 각각 자신만의 PC Registers 를 가지고 있다. 만약 실행했던 메소드가 네이티브하다면 undefined가 기록이 된다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:4:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"Native Method Stack Java 로 작성된 프로그램을 실행하면서, 순수하게 Java 로 구성된 코드만을 사용할 수 없는 시스템의 자원이나 API 가 존재한다. 다른 프로그래밍 언어로 작성된 메소드들을 Native Method 라고 한다. Native Method Stack은 Java로 작성되지 않은 메소드를 다루는 영역이다. C Stacks 라고 부르기도 한다. Native Method가 실행될 경우 Stack에 해당 프레임이 쌓이게 된다. Thread가 생성되면 Native Method Stack도 동일하게 생성된다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:5:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-08-09-jvm-memory/ ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:6:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["DB"],"content":"캐시란 cache란 사용자의 입장에서 데이터의 원래 소스보다 더 빠르게 그리고 더 효율적으로 액세스할 수 있는 임시 데이터 저장소를 뜻한다. 대부분의 애플리케이션에서 속도 향상을 위해 cache를 사용하고 있다. 캐시에 데이터나 계산된 결과 값의 복사본을 저장해 둠으로써 전체적인 처리 속도를 향상시킨다. 캐시를 사용하는 경우는 다음과 같다. 데이터에 직접적으로 접근하는 데 걸리는 시간이 오래 걸릴 때 데이터가 잘 변하지 않는 경우 반복적으로 동일한 결과를 돌려주는 경우 (이미지와 썸네일 등) ","date":"2022-02-28","objectID":"/redis/:1:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"Redis란 레디스는 전 세계에서 가장 유명한 caching 솔루션이다. 단순하게 key-value 형태로 저장할 수 있기 때문에 어떤 데이터라도 쉽게 저장할 수 있다. 또한 레디스는 모든 데이터를 메모리에 올려두는 인메모리 데이터 스토어이다. 평균 읽기 및 쓰기 작업 속도가 1밀리 세컨드 미만이니 초당 수백만 건의 작업이 가능하다. ","date":"2022-02-28","objectID":"/redis/:2:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"캐싱 전략 레디스를 cache로 사용할 때 어떻게 배치하는지가 시스템의 성능에 큰 영향을 끼치기 때문에 caching 전략은 데이터의 유형과 해당 데이터에 대한 액세스 패턴을 잘 고려해서 선택해야 한다. ","date":"2022-02-28","objectID":"/redis/:3:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"읽기 전략 Cache-Aside 애플리케이션이 요청을 받으면, 데이터가 캐시에 있는지 먼저 검사를 하며, 그 결과(캐시에 데이터가 로딩되어 있는지 여부)에 따라 다음 액션이 결정된다. 캐시에 데이터가 없다면, 애플리케이션이 캐시에 데이터를 업데이트한다. 캐시에 대한 의존성이 낮으므로, 캐시가 다운되더라도 원천 데이터베이스로 서비스를 계속할 수 있다. 읽기 요청이 많은 경우에 적합하다. Read-Through 캐시 미스 시 데이터베이스와 동기화하는 몫은 캐시에 위임된다. 최초 데이터 로딩은 미스가 나며, 그 때 데이터가 로딩된다. Cache-Aside 전략과 마찬가지로 읽기요청이 많은 경우를 처리하는데 적합하다. 첫 요청의 캐시 미스를 방어해야 한다면 스케쥴 작업 등을 통해 미리 캐시를 warm up시켜놓기도 한다. ","date":"2022-02-28","objectID":"/redis/:3:1","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"쓰기 전략 Write-Around write around 방식은 DB에만 데이터를 저장한다. 일단 모든 데이터는 DB에 저장되고 읽은 데이터만 캐시에 저장된다. 이 경우엔 cahce 내의 데이터와 DB 내의 데이터가 다를 수 있다는 단점이 있다. 데이터가 한 번 쓰여지고, 덜 자주 읽히거나 읽지 않는 상황에서 좋은 성능을 제공한다. 예를들어, 실시간 로그 또는 채팅방 메시지가 있다. Write-Through write-through 전략은 DB에 데이터를 저장할 때 cache에도 함께 저장하는 방법이다. cache는 항상 최신 정보를 가지고 있다는 장점이 있지만 저장할 때마다 두 단계 스텝을 거쳐야 하기 때문에 상대적으로 느리다고 볼 수 있다. 그리고 저장하는 데이터가 재사용되지 않을 수도 있는데 무조건 캐시에 넣어버리기 때문에 이는 일종의 리소스 낭비라고도 볼 수 있다. 따라서 이렇게 데이터를 저장할 때는 몇 분 혹은 몇 시간 동안만 데이터를 보관하겠다는 의미인 expire time을 설정해 주는 것이 좋다. ","date":"2022-02-28","objectID":"/redis/:3:2","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"참고 https://wnsgml972.github.io/database/2020/12/13/Caching/ https://youtu.be/92NizoBL4uA ","date":"2022-02-28","objectID":"/redis/:4:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 기술이다. 인덱스는 테이블 내 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다. 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:0:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"인덱스 사용 시 장단점 ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"장점 검색은 속도가 무척 빨라질 수 있다. (단, 항상 그런 것은 아니다.) 그 결과 해당 쿼리의 부하가 줄어들어서 결국 시스템 전체의 성능이 향상된다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:1","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"단점 인덱스가 데이터베이스 공간을 차지해서 추가적인 공간이 필요해지는데, 대략 그 비율은 10% 정도이다. 처음 인덱스를 생성하는 데 시간이 많이 소요될 수 있다. 데이터의 변경 작업이 자주 일어날 경우에는 오히려 성능이 나빠질 수 있다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:2","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"인덱스 자료구조 ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:2:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"Hash Table 해시 테이블은 Key-Value로 이루어진 데이터를 저장하는데 특화된 자료 구조이다. 해시 테이블 기반의 DB Index는 특정 컬럼의 값과 데이터의 위치를 Key-Value로 사용한다. 해시 테이블은 내부에 버켓이라고 하는 배열이 존재한다. 해시 함수를 통해 Key를 고유한 해시 값으로 변환시키는데, 이를 버켓 배열의 인덱스로 사용하며 해당 인덱스에 Value를 저장한다. Key 값으로 Value가 저장되어 있는 위치(주소)를 바로 산출할 수 있기 때문에, 해시 테이블의 평균적인 시간 복잡도는 O(1) 이다. 하지만 해시 함수를 제대로 정의하지 않으면 해시 함수를 통해 산출한 해시 값이 중복되는 해시 충돌이 발생한다. 너무 많은 해시 충돌이 발생하면 검색 성능이 하락해 시간 복잡도가 O(N)에 수렴할 수 있다. Index 자료 구조로 해시 테이블을 사용하는 경우는 매우 제한적이다. 해시 함수는 Key가 조금이라도 다르면 완전히 다른 해시 값을 생성한다. 이러한 해시 테이블을 사용하는 Index의 경우 WHERE 조건의 등호(=) 연산에는 효율이 좋지만, 부등호 연산(\u003e, \u003c)은 부적합하다. 해시 테이블은 내부 데이터들이 정렬되어 있지 않아 탐색이 효율적이지 않다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:2:1","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"B-Tree B-Tree란 자식 노드가 2개 이상인 트리를 의미한다. 이진검색 트리처럼 각 Key의 왼쪽 자식은 항상 Key보다 작은 값을, 오른쪽 자식은 큰 값을 가진다. B-Tree 기반의 DB Index는 특정 컬럼의 값(Key)에 해당하는 노드에 데이터의 위치(Value)를 저장한다. 각 Node에는 여러개의 Key를 갖고 있고 각 Key에 대응하는 Data도 함께 갖고 있다. Key는 Binary Search와 유사한 형태로 정렬되어 각 Node에 배치된다. Binary Search에서 오른쪽 Child Node의 Key는 자신보다 작고 왼쪽 Child Node의 Key는 자신보다 큰데, B-Tree에서도 각 Key에 대해서 유사한 규칙이 적용된다. B-Tree의 Key-Value 값들은 항상 Key를 기준으로 오름차순 정렬이다. 이로 인해 부등호 연산(\u003e, \u003c)에 대해 해시 테이블보다 효율적인 데이터 탐색이 가능하다. 또한 B-Tree는 균형 트리(Balanced Tree)로서, **최상위 루트 노드에서 리프 노드까지의 거리가 모두 동일하기 때문에 평균 시간 복잡도는 O(logN)**이다. 하나의 Node에 여러개의 Key를 갖는 특성 때문에 용량이 큰 Block 단위로 Data를 Read/Write하는 Disk 환경에서는 Binary Search Tree보다 B-Tree를 이용하는 것이 유리하다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:2:2","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"B+Tree B+ Tree는 B-Tree를 개량한 자료구조 이다. B-tree처럼 모든 Leaf Node는 동일한 Depth를 갖는다. B-Tree와의 가장 큰 차이점은 Inner Node에는 Key만 저장이 되고 Leaf Node에 Key와 Data를 함께 저장한다는 점이다. Leaf Node에만 Data가 저장되기 때문에 Leaf Node 사이를 Link (Pointer)로 연결하여 B-Tree에 비하여 쉬운 순회가 가능하도록 만든점도 B+ Tree의 특징이다. DB Index 컬럼은 부등호(\u003e, \u003c)를 이용한 순차 검색 연산이 자주 발생한다. B-Tree가 해시 테이블보다 부등호를 이용한 검색 연산 성능이 좋지만, 순차 검색의 경우 중위 순회를 하기 때문에 효율이 좋지 않다. 따라서 MySQL 엔진인 InnoDB는 B-Tree를 확장 및 개선한 B+Tree를 Index의 자료 구조로 사용한다. B+Tree에서 말단의 리프 노드들끼리는 LinkedList 구조로 서로를 참조하고 있다. 따라서 부등호(\u003e, \u003c)를 이용한 순차 검색 연산을 하는 경우, 많은 노드를 방문해야 하는 B-Tree에 비해 B+Tree는 말단 리프 노드를 저장한 LinkedList를 한 번만 탐색하는 등 속도 이점이 있다. B+ Tree의 Inner Node는 Data가 없기 때문에 B-Tree의 Inner Node에 비하여 용량작다. 하나의 Disk Block에 더 많은 Inner Node를 배치 할 수 있게 되어, Key 탐색시 B-Tree에 비하여 상대적으로 적은 Disk Block만 읽어도 된다. 이러한 이점 때문에 일반적으로 B+ Tree는 Key 탐색시 B-Tree보다 좀더 나은 성능을 보여준다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:2:3","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"인덱스의 종류 ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:3:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"클러스터형 인덱스(Clustered Index) 영어 사전처럼 책의 내용 자체가 순서대로 정렬되어 있어서 인덱스 자체가 책의 내용과 같은 것 테이블 당 한 개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하는지에 따라서 시스템의 성능이 달라질 수 있다. 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 신중하게 생각해야 한다. 보조 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:3:1","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"보조 인덱스(Secondary Index) \u003c찾아보기\u003e가 별도로 있고, \u003c찾아보기\u003e를 찾은 후에 그 옆에 표시된 페이지로 가야 실제 찾는 내용이 있는 것 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다. 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소값이다. 클러스터형 인덱스보다 검색 속도는 더 느리지만 입력/수정/삭제는 덜 느리다. 테이블 당 여러 개를 생성할 수 있다. 하지만 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있으므로 꼭 필요한 열에만 생성하는 것이 좋다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:3:2","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"MYSQL 인덱스의 특징 PRIMARY KEY로 지정한 열은 클러스터형 인덱스가 생성된다. UNIQUE NOT NULL로 지정한 열은 클러스터형 인덱스가 생성된다. UNIQUE(또는 UNIQUE NULL)로 지정한 열은 보조 인덱스가 생성된다. PRIMARY KEY와 UNIQUE NOT NULL이 있으면 PRIMARY KEY로 지정한 열에 우선 클러스터형 인덱스가 생성된다. PRIMARY KEY로 지정한 열로 데이터가 오름차순 정렬된다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:4:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"인덱스를 생성할 때 고려할 점 테이블 조회 시에 WHERE 절의 조건에 해당 열이 나오는 경우에만 인덱스를 사용한다. WHERE절에 사용되더라도 자주 사용해야 가치가 있다. 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다. 외래 키를 지정한 열에는 자동으로 외래 키 인데스가 생성된다. JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다. 사용하지 않는 인덱스는 제거하자. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:5:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"참고 https://www.youtube.com/watch?v=iCIK7qv6GnU https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/ https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:6:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["설계방법론"],"content":"AOP는 기능을 핵심 비즈니스 로직과 공통 모듈로 구분하고 핵심 로직에 영향을 미치지 않고 사이사이에 공통 모듈을 효과적으로 잘 끼워 넣어 중복성을 감소시킬 수 있는 개발 방법이다. ","date":"2022-02-24","objectID":"/aop/:0:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"AOP 용어 용어 설명 Advice Joinpoint에서 실행되어야 하는 프로그램 코드 독립된 클래스의 메소드로 작성함 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체 BEFORE, AROUND, AFTER의 실행 위치 지정 Joinpoint Advice를 적용할 수 있는 후보 지점 혹은 호출 이벤트 관심사를 구현한 코드를 끼워 넣을 수 있는 프로그램의 이벤트를 말하며, 예로는 call events, execution events, initialization events 등이 있음 Pointcut 언제 Advice를 실행할지를 정의 Target 클래스와 Advice가 결합(Weaving)될 때 둘 사이의 결합규칙을 정의 특정 조건에 의해 필터링된 조인포인트, 수많은 조인포인트 중에 특정 메소드에서만 횡단 공통기능을 수행시키기 위해서 사용한다. Target 실질적인 비지니스 로직을 구현하고 있는 코드 JoinPoint에서 실제 Advice가 적용될 지점 Weaving PointCut에 Advice 메서드가 삽입되는 과정 ","date":"2022-02-24","objectID":"/aop/:1:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"AOP 구현 implementation 'org.springframework.boot:spring-boot-starter-aop' // @EnableAspectJAutoProxy 생략 가능 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } } @Service public class AuthServiceImpl { public void businessLogicMethod(){ System.out.println(\"businessLogicMethod process!\"); } } ","date":"2022-02-24","objectID":"/aop/:2:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"일반적인 구현 import org.aspectj.lang.ProceedingJoinPoint; @Aspect @Configuration public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"execution(* com.demo.study.service.AuthServiceImpl.*(..))\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"execution(* com.demo.study.service.AuthServiceImpl.*(..))\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } ","date":"2022-02-24","objectID":"/aop/:2:1","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"어노테이션으로 구현 @Target(ElementType.METHOD) @Retention(RetentionPolicy.CLASS) public @interface PerformanceCheck { } @Service public class AuthServiceImpl { @PerformanceCheck public void businessLogicMethod(){ System.out.println(\"businessLogicMethod process!\"); } } import org.aspectj.lang.ProceedingJoinPoint; @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"@annotation(com.demo.study.annotation.PerformanceCheck)\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"@annotation(com.demo.study.annotation.PerformanceCheck)\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } 어노테이션과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다. ","date":"2022-02-24","objectID":"/aop/:2:2","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"빈으로 구현 import org.aspectj.lang.ProceedingJoinPoint; @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"bean(com.demo.study.service.AuthServiceImpl)\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"bean(com.demo.study.service.AuthServiceImpl)\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } 빈과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다. ","date":"2022-02-24","objectID":"/aop/:2:3","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"AOP PointCut 설정 execution(* com.springbook.biz..*Impl.get*(..))\" * : 리턴값 com.springbook.biz.. : 패키지 *Impl: 클래스 이름 get* : 메서드 이름 (..) : 매개변수 중간마다의 . : 구분점 ","date":"2022-02-24","objectID":"/aop/:3:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"execution 포인트 컷 리턴 표현식 설명 * 모든 리턴타입 허용 void 리턴타입이 void인 메서드 선택 !void 리턴타입이 void가 아닌 메서드 선택 ","date":"2022-02-24","objectID":"/aop/:3:1","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"execution 포인트 컷 패키지 표현식 설명 com.springbook.biz 정학하게 해당 패키지만 선택 com.springbook.biz.. 해당 패키지 및 모든 하위 패키지 선택 com.springbook..impl ..앞 패키지로 시작하면서 마지막 패키지 이름이 ..뒤로 끝나는 패키지 선택 ","date":"2022-02-24","objectID":"/aop/:3:2","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"execution 포인트 컷 클래스 표현식 설명 BoardServiceImpl 정학하게 해당 클래스만 선택 *Impl 클래스 이름이 *뒷 글자로 끝나는 클래스만 선택 BoardService+ 해당 클래스는 물론 파생된 모든 자식 클래스도 선택 가능 variable+ 해당 인터페이스를 구현한 모든 클래스 선택 가능 ","date":"2022-02-24","objectID":"/aop/:3:3","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"execution execution 포인트 컷 메서드 표현식 설명 *(..) 가장 기본 설정으로 모든 메서드 선택 get*(..) 메서드 이름이 get으로 시작하는 모든 메서드 선택 매서드이름(..) 특정 메서드 이름을 가진 메서드 선택 execution 포인트 컷 매개변수 표현식 설명 (..) 가장 기본 설정으로서 매개변수 타입의 제한이 없음을 의미 (*) 반드시 1개의 매개변수를 가지는 메서드만 허용한다는 의미 (com.spring.user.User) 해당 패키지의 클래스를 가지는 메서드만 허용한다는 의미 (!com.spring.user.User) 해당 패키지의 클래스를 가지지 않는 메서드만 허용한다는 의미 (Integer, ..) 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용 (Integer, *) 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용 ","date":"2022-02-24","objectID":"/aop/:3:4","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"AOP 구현체 SpringAOP AspectJ 목표 간단한 AOP 제공 완벽한 AOP 제공 join point 메서드 레벨만 지원 생성자, 필드, 메서드 등 다양하게 지원 weaving 런타임 시에만 가능 런타임은 제공하지 않음, compile-time, post-compile, load-time 제공 대상 Spring Container가 관리하는 Bean에만 가능 모든 JAVA Object에 가능 ","date":"2022-02-24","objectID":"/aop/:4:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["설계방법론"],"content":"참고 https://github.com/kwj1270/TIL_Seminar/blob/master/AOP.md https://swingswing.tistory.com/m/272 ","date":"2022-02-24","objectID":"/aop/:5:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["java"],"content":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:1:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:2:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:3:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Local Class 중괄호 내에, 특히 메소드 내에 정의 ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:4:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:5:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"equals와 hashCode는 왜 같이 재정의해야 할까? hash 값을 사용하는 Collection(HashMap, HashSet, HashTable)은 객체가 논리적으로 같은지 비교할 때 아래 그림과 같은 과정을 거친다. hashCode 메소드의 반환값을 이용해서 검색의 범위를 확 줄여버리고, 해당 부류 내에 존재하는 데이터의 내용 비교는 equals 메소드를 통해서 진행한다. Object 클래스의 hashCode 메소드는 인스턴스가 다르면 구성 내용에 상관없이 전혀 다른 해시값을 반환하도록 정의되어 있다. equals 메소드도 내용 비교가 아닌, 참조값만 비교하도록 정의되어 있다. 따라서 이 두 메소드를 적절히 오버라이딩해야 두 개의 인스턴스를 동일한 인스턴스로 인식시킬 수 있다. ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:1:0","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"equals와 hashCode 재정의 예시 ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:2:0","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"String String 클래스에 정의된 hashCode 메소드는 다음과 같다. public int hashCode() { int h = this.hash; if (h == 0 \u0026\u0026 this.value.length \u003e 0) { this.hash = h = this.isLatin1() ? StringLatin1.hashCode(this.value) : StringUTF16.hashCode(this.value); } return h; } String 클래스에 정의된 equals 메소드는 다음과 같다. public boolean equals(Object anObject) { if (this == anObject) { return true; } else { if (anObject instanceof String) { String aString = (String)anObject; if (this.coder() == aString.coder()) { return this.isLatin1() ? StringLatin1.equals(this.value, aString.value) : StringUTF16.equals(this.value, aString.value); } } return false; } } ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:2:1","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"Arrays Arrays 클래스에 정의된 hashCode 메소드는 다음과 같다. public static int hashCode(Object a[]) { if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; } public static boolean equals(int[] a, int[] a2) { if (a == a2) { return true; } else if (a != null \u0026\u0026 a2 != null) { int length = a.length; if (a2.length != length) { return false; } else { return ArraysSupport.mismatch(a, a2, length) \u003c 0; } } else { return false; } } ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:2:2","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"Iterable 인터페이스 Collection 인터페이스의 상위 인터페이스는 Iterable 이다. package java.lang; public interface Iterable\u003cT\u003e { /** * Returns an iterator over elements of type {@code T}. * * @return an Iterator. */ Iterator\u003cT\u003e iterator(); /** * Performs the given action for each element of the {@code Iterable} * until all elements have been processed or the action throws an * exception. Actions are performed in the order of iteration, if that * order is specified. Exceptions thrown by the action are relayed to the * caller. * \u003cp\u003e * The behavior of this method is unspecified if the action performs * side-effects that modify the underlying source of elements, unless an * overriding class has specified a concurrent modification policy. * * @implSpec * \u003cp\u003eThe default implementation behaves as if: * \u003cpre\u003e{@code * for (T t : this) * action.accept(t); * }\u003c/pre\u003e * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */ default void forEach(Consumer\u003c? super T\u003e action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } } Iterable 인터페이스 안에는 iterator 메소드가 추상메소드로 선언이 되어있다. 이렇게 때문에 Collection 인터페이스 계층구조에서 List, Set, Queue를 구현하는 클래스들은 다 iterator 메소드를 가지고 있다. 따라서 Iterable 인터페이스는 iterator() 메소드를 하위 클래스에서 구현하도록 강제하기 위해 사용한다. ","date":"2022-02-15","objectID":"/iterable-and-iterator/:1:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"Iterator 인터페이스 Iterator 인터페이스는 Collection과는 별개로 존재하는 인터페이스이다. package java.util; public interface Iterator\u003cE\u003e { /** * Returns {@code true} if the iteration has more elements. * (In other words, returns {@code true} if {@link #next} would * return an element rather than throwing an exception.) * * @return {@code true} if the iteration has more elements */ boolean hasNext(); /** * Returns the next element in the iteration. * * @return the next element in the iteration * @throws NoSuchElementException if the iteration has no more elements */ E next(); /** * Removes from the underlying collection the last element returned * by this iterator (optional operation). This method can be called * only once per call to {@link #next}. * \u003cp\u003e * The behavior of an iterator is unspecified if the underlying collection * is modified while the iteration is in progress in any way other than by * calling this method, unless an overriding class has specified a * concurrent modification policy. * \u003cp\u003e * The behavior of an iterator is unspecified if this method is called * after a call to the {@link #forEachRemaining forEachRemaining} method. * * @implSpec * The default implementation throws an instance of * {@link UnsupportedOperationException} and performs no other action. * * @throws UnsupportedOperationException if the {@code remove} * operation is not supported by this iterator * * @throws IllegalStateException if the {@code next} method has not * yet been called, or the {@code remove} method has already * been called after the last call to the {@code next} * method */ default void remove() { throw new UnsupportedOperationException(\"remove\"); } } Iterator 인터페이스를 구현함으로써 hasNext(), next(), remove() 등의 메소드를 이용할 수 있다. 따라서 Iterable 인터페이스는 hasNext()와 next() 메소드를 하위 클래스에서 구현하도록 강제하기 위해 사용한다. import java.util.Iterator; import java.util.LinkedList; public class Test { public static void main(String[] args) { LinkedList\u003cString\u003e list = new LinkedList\u003c\u003e(); list.add(\"Lee\"); list.add(\"ekk\"); list.add(\"eww\"); Iterator it = list.iterator(); while (it.hasNext()) { System.out.print(it.next() + \" \"); } } } 이처럼 인터페이스를 사용하면 표준을 정의하고 구현을 강제함으로써 코드의 일관성을 유지할 수 있다. ","date":"2022-02-15","objectID":"/iterable-and-iterator/:2:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"참고 https://devlog-wjdrbs96.tistory.com/84 ","date":"2022-02-15","objectID":"/iterable-and-iterator/:3:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다. public interface Comparable\u003cT\u003e { int compareTo(T obj); } 사용 예시는 다음과 같다. import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable\u003cPerson\u003e { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void showData() { System.out.printf(\"%s %d \\n\", name, age); } public int compareTo(Person p) { if (age \u003e p.age) return 1; else if (age \u003c p.age) return -1; else return 0; } } class ComparablePerson { public static void main(String[] args) { TreeSet\u003cPerson\u003e sTree = new TreeSet\u003cPerson\u003e(); sTree.add(new Person(\"Lee\", 24)); sTree.add(new Person(\"Hong\", 29)); sTree.add(new Person(\"Choi\", 21)); Iterator\u003cPerson\u003e itr = sTree.iterator(); while (itr.hasNext()) itr.next().showData(); } } ","date":"2022-02-15","objectID":"/comparable-and-comparator/:1:0","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이","uri":"/comparable-and-comparator/"},{"categories":["java"],"content":"Comparator 인터페이스 String 클래스는 이미 compareTo 메소드를 구현하고 있다. 이 때 정령기준을 변경하기 위해서 String 클래스를 상속하는 클래스를 새로 정의하는 것은 번거롭다 따라서 새로운 정렬 기준을 파라미터로 넘길 수 있도록 정의된 것이 Comparator 인터페이스이다. public interface Comparator\u003cT\u003e { int compare(T o1, T o2); } 사용 예시는 다음과 같다. import java.util.TreeSet; import java.util.Iterator; import java.util.Comparator; class StrLenComparator implements Comparator\u003cString\u003e { public int compare(String str1, String str2) { if (str1.length() \u003e str2.length()) return 1; else if (str1.length() \u003c str2.length()) return -1; else return 0; /* * return str1.length()-str2.length(); */ } } class IntroComparator { public static void main(String[] args) { TreeSet\u003cString\u003e tSet = new TreeSet\u003cString\u003e(new StrLenComparator()); tSet.add(\"Orange\"); tSet.add(\"Apple\"); tSet.add(\"Dog\"); tSet.add(\"Individual\"); Iterator\u003cString\u003e itr = tSet.iterator(); while (itr.hasNext()) System.out.println(itr.next()); } } ","date":"2022-02-15","objectID":"/comparable-and-comparator/:2:0","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이","uri":"/comparable-and-comparator/"},{"categories":["java"],"content":"Enum의 목적 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다. 예를 들어 DB에 저장된 code의 값이 “CALC_A\"일 경우엔 값 그대로, “CALC_B\"일 경우엔 10 한 값을, “CALC_C\"일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 “DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.“는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. import java.util.function.Function; public enum CalculatorType { CALC_A(value -\u003e value), CALC_B(value -\u003e value * 10), CALC_C(value -\u003e value * 30), CALC_ETC(value -\u003e 0L); private Function\u003cLong, Long\u003e expression; CalculatorType(Function\u003cLong, Long\u003e expression) { this.expression = expression; } public long calculate(long value) { return expression.apply(value); } } import javax.persistence.Column; import javax.persistence.EnumType; import javax.persistence.Enumerated; public class Entity { @Column //@Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다. @Enumerated(EnumType.STRING) private CalculatorType calculatorType; } import org.testng.annotations.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTypeTest { private CalculatorType selectType() { return CalculatorType.CALC_B; } @Test public void 코드에_따라_서로다른_계산하기_Enum() { CalculatorType code = selectType(); long originValue = 10000L; long result = code.calculate(originValue); assertEquals(result, 100000L); } } 값(상태)과 메소드(행위)가 어떤 관계가 있는지에 대해 더이상 다른 곳을 찾을 필요가 없게 되었다. 코드내에 전부 표현되어 있고, Enum 상수에게 직접 물어보면 되기 때문이다. ","date":"2022-02-03","objectID":"/enum-%EC%82%AC%EC%9A%A9/:1:0","tags":["enum"],"title":"Enum 사용","uri":"/enum-%EC%82%AC%EC%9A%A9/"},{"categories":["java"],"content":"Enum 활용 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다. 결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다. 이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다. public enum PayType { ACCOUNT_TRANSFER(\"계좌이체\"), REMITTANCE(\"무통장입금\"), ON_SITE_PAYMENT(\"현장결제\"), TOSS(\"토스\"), PAYCO(\"페이코\"), CARD(\"신용카드\"), KAKAO_PAY(\"카카오페이\"), BAEMIN_PAY(\"배민페이\"), POINT(\"포인트\"), COUPON(\"쿠폰\"); private final String title; PayType(String title) { this.title = title; } public String getTitle() { return title; } } import lombok.Getter; import java.util.Arrays; import java.util.Collections; import java.util.List; @Getter public enum PayGroup { CASH(\"현금\", Arrays.asList(PayType.ACCOUNT_TRANSFER, PayType.REMITTANCE, PayType.ON_SITE_PAYMENT, PayType.TOSS)), CARD(\"카드\", Arrays.asList(PayType.PAYCO, PayType.CARD, PayType.KAKAO_PAY, PayType.BAEMIN_PAY)), ETC(\"기타\", Arrays.asList(PayType.POINT, PayType.COUPON)), EMPTY(\"없음\", Collections.EMPTY_LIST); private final String title; private final List\u003cPayType\u003e payList; PayGroup(String title, List\u003cPayType\u003e payList) { this.title = title; this.payList = payList; } public static PayGroup findByPayType(PayType payType){ return Arrays.stream(PayGroup.values()) .filter(payGroup -\u003e payGroup.hasPayType(payType)) .findAny() .orElse(EMPTY); } private boolean hasPayType(PayType payType){ return payList.stream() .anyMatch(pay -\u003e pay == payType); } } import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PayGroupTest { @Test public void PayGroup에게_직접_결제종류_물어보기_PayType () { PayType payType = selectPayType(); PayGroup payGroup = PayGroup.findByPayType(payType); assertEquals(payGroup.name(), \"CARD\"); assertEquals(payGroup.getTitle(), \"카드\"); } private PayType selectPayType(){ return PayType.BAEMIN_PAY; } } DB 혹은 API에서 PayType으로 데이터를 받아, 타입 안전성까지 확보하여 PayGroup 관련된 처리를 진행할 수 있게 되었다. ","date":"2022-02-03","objectID":"/enum-%EC%82%AC%EC%9A%A9/:2:0","tags":["enum"],"title":"Enum 사용","uri":"/enum-%EC%82%AC%EC%9A%A9/"},{"categories":["java"],"content":"참고 https://github.com/jojoldu/blog-code/tree/master/enum-settler ","date":"2022-02-03","objectID":"/enum-%EC%82%AC%EC%9A%A9/:3:0","tags":["enum"],"title":"Enum 사용","uri":"/enum-%EC%82%AC%EC%9A%A9/"},{"categories":["ML"],"content":"Step Function 활성화 함수는 신경망의 행동을 결정하는 중요한 역할을 합니다. 가장 간단한 형태의 활성화 함수는 계단 함수(Step function) 라고 합니다. 계단 함수는 입력값의 합이 임계값을 넘으면 $0$ 을, 넘지 못하면 $1$ 을 출력하게 됩니다. 계단 함수의 그래프는 다음과 같이 생겼습니다. 이미지 출처 : wikipedia - Heaviside step function 계단 함수는 활성화 함수의 조건을 가장 잘 만족하는 함수이고 직관적으로도 이해하기 쉽습니다. 하지만 불연속 함수라는 단점 때문에 실제 신경망에 사용되지는 않습니다. 그래프를 보면 알 수 있듯 임계값 지점에서 불연속점을 갖게 되는데 이 점에서 미분이 불가능하기 때문에 학습이 필요한 신경망에 사용할 수 없습니다. 이런 문제점을 해결하기 위해서 등장한 것이 시그모이드 함수(Sigmoid) 입니다. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:1:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"Sigmoid Function 시그모이드 함수는 기본적으로 $S$ 모양을 그리는 곡선 함수를 통칭하여 부르는 말입니다. 이 중 대표적인 함수는 로지스틱(Logistic) 함수와 하이퍼탄젠트(Hyper tangent, $\\tanh$) 함수가 있습니다. 두 함수의 수식과 그래프를 보며 시그모이드 함수와 계단 함수가 다른 점이 무엇인지 알아보도록 하겠습니다. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"로지스틱 함수(Logistic Function) $$ \\text{Logistic} : \\frac{1}{1+e^{-x}} $$ 이미지 출처 : wikipedia - Logistic function ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:1","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"하이퍼탄젠트 함수(Hypertangent Function) $$ \\text{Hypertangent} : \\frac{e^x-e^{-x}}{e^x+e^{-x}} = \\frac{e^{2x}-1}{e^{2x}+1} $$ 이미지 출처 : mathworld.wolfram.com 두 함수는 모두 연속함수입니다. 계단 함수의 치명적인 단점이었던 불연속을 해결했지요. 계단 함수와 시그모이드 함수의 중요한 공통점은 비선형 함수(Non-linear) 라는 점입니다. 활성화 함수는 비선형 함수를 사용해야 합니다. 활성화 함수가 선형 함수이면 안되는 이유는 무엇일까요? 선형인 활성화 함수 $l(x) = ax + b$ 가 있다고 해보겠습니다. 이 함수를 사용하여 3개의 층을 쌓는다면 최종적인 활성화 함수는 $l(l(l(x))) = l^3(x) = a(a(ax+b)+b)+b = a^3x+a^2b+ab+b$가 됩니다. $a^3 = c, d = a^2b+ab+b$라고 하면 $l^3(x) = cx+d$로 여전히 같은 형태의 함수를 사용하게 됩니다. 이렇듯 층을 아무리 깊게 쌓아도 여러 층을 쌓는 이점을 살리지 못하게 되지요. 여러 층을 쌓을 때의 장점을 살리기 위해 비선형 함수를 사용하게 되는 것이지요. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:2","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"ReLU Function 시그모이드 함수는 불연속이라는 계단 함수의 단점을 해결했습니다. 하지만 시그모이드는 대부분의 점에서 기울기 값이 0이 됩니다. 이 때문에 **기울기 소실(Gradient vanishing)**이라는 문제가 발생합니다. 기울기 소실은 시그모이드 함수를 활성화 함수로 사용하여 층을 깊게 쌓았을 때 학습이 잘 되지 않는 현상입니다. 이런 현상이 왜 발생하는지 알아보겠습니다. 로지스틱 함수 $L(x)$를 미분한 함수 $L^\\prime(x)$ 의 수식은 다음과 같습니다. $$ L^\\prime(x) = \\bigg(\\frac{1}{1+e^{-x}}\\bigg)^\\prime = \\frac{e^x}{(1+e^{-x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 그래프에서 볼 수 있듯 최댓값이 $0.25$ 밖에 되지 않고 $x\u003c-5, x\u003e5$ 범위에서는 거의 $0$ 에 가깝습니다. 역전파(Back propagation) 과정에서는 미분값을 사용하여 학습을 하게 됩니다. 따라서 이 값이 0에 가까워 지면 정보가 유실되면서 학습이 잘 안되게 됩니다. 특히 층을 깊게 쌓을 경우에는 정보가 모두 유실되는 사태가 발생하게 되지요. 그렇다면 하이퍼탄젠트 함수는 어떻게 될까요? 하이퍼탄젠트 함수 $\\tanh$를 미분한 함수의 수식은 다음과 같습니다. $$ \\tanh^\\prime(x) = \\bigg(\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\bigg)^\\prime = \\frac{4e^{2x}}{(1+e^{2x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 하이퍼탄젠트 함수를 미분한 함수의 최댓값은 $1$ 입니다. 최댓값이 $0.25$ 밖에 안되었던 로지스틱 함수 보다는 정보를 잘 전달하게 되지요. 하지만 여전히 $x$ 가 0에서 멀어질수록 원래 함수의 미분값은 0에 가까워집니다. 그래서 하이퍼탄젠트 함수를 활성화 함수로 하더라도 퍼셉트론을 여러 층으로 쌓는다면 학습이 제대로 안되게 되지요. 이렇게 시그모이드 함수를 활성화 함수로 사용할 때 역전파시 학습이 제대로 진행되지 않는 현상을 기울기 소실이라고 합니다. 기울기 소실 문제를 극복하기 위해서 등장한 함수가 바로 ReLU(Rectified Linear Unit)함수입니다. ReLU함수는 입력값이 0보다 작을 경우에는 0을 반환하고, 0보다 클 경우에는 입력값을 그대로 반환합니다. 아래는 ReLU함수의 그래프를 나타낸 것입니다. 이미지 출처 : medium.com ReLU함수는 $x$ 가 $0$ 보다 클 때, 미분값이 항상 $1$ 입니다. 그래서 층이 아무리 깊어져도 손실없이 정보를 전달할 수 있습니다. 미분값이 항상 $0$과 $1$ 이기 때문에 연산이 빠르다는 점도 ReLU함수의 장점입니다. 덕분에 ReLU함수는 은닉층에서 가장 많이 사용되는 활성화 함수가 되었습니다. 물론 ReLU함수에게도 문제가 있습니다. 0이하의 값이 그대로 보존되지 않고 버려진다는 것이지요. 이를 보완하기 위해 Leaky ReLU함수가 고안되어 사용되고 있습니다. 일반적으로는 $a=0.01$을 사용하며 그래프는 다음과 같습니다. 이미지 출처 : medium.com ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:3:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["web"],"content":"SOP SOP(Same Origin Policy)는 다른 Origin으로 요청을 보낼 수 없도록 금지하는 브라우저의 기본적인 보안 정책이다. 즉, 동일한 Origin으로만 요청을 보낼 수 있게 하는 것이다. 실제로 아주 옛날에는 이것이 절대적인 규칙이었기 때문에, 다른 Origin으로 요청을 보내는 건 애초에 불가능하였다. 그러나 기술이 발달하면서 서로 다른 Origin끼리 데이터를 주고받아야 하는 일이 많아졌고, 이로 인해 SOP는 별도의 예외 사항을 두게 되었다. 즉, 몇 가지 예외 상황에 대해서는 다른 Origin으로도 요청을 보낼 수 있게 하는 것이다. 의미 Origin은 URL에서 프로토콜, 도메인, 포트 번호를 합친 부분을 의미한다. 예를 들어, 다음과 URL이 https://youngeun-in.github.io/posts/ 일 때, 도메인은 https://youngeun-in.github.io:80 이다. RFC 6454에서는 SOP의 예외 상황을 다음과 같이 정의하고 있다. Generally, reading information from another origin is forbidden. However, an origin is permitted to use some kinds of resources retrieved from other origins. For example, an origin is permitted to execute script, render images, and apply style sheets from any origin. Likewise, an origin can display content from another origin, such as an HTML document in an HTML frame. Network resources can also opt into letting other origins read their information, for example, using Cross-Origin Resource Sharing. 해석해보면, 다음과 같다. \u003cscript\u003e 태그로 JavaScript를 실행하는 경우, 이미지를 렌더링 하는 경우 \u003clink\u003e 태그로 스타일 시트 파일을 불러오는 경우 HTML 문서를 화면에 보여주는 경우 CORS 정책을 지키는 요청의 경우 ","date":"2022-01-07","objectID":"/cors/:1:0","tags":["cors","csrf"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"CORS CORS(Cross Origin Resource Sharing)는 다른 Origin으로 요청을 보내기 위해 지켜야 하는 정책으로, 원래대로라면 SOP에 의해 막히게 될 요청을 풀어주는 정책이다. 여기서 주목할 만한 점은, CORS는 ‘브라우저’의 정책이라는 것이다. 즉, 서버는 평소처럼 요청이 오면 응답을 해줄 뿐이고, 브라우저가 자신이 보낸 요청 및 서버로부터 받은 응답의 데이터가 CORS 정책을 지키는지 검사하여 안전한 요청을 보낸 건지 검사하는 것이다. 따라서 서버가 정상적으로 응답을 해줬더라도, 알고 보니 안전한 요청이 아니라고 판단되면 해당 응답을 버린다. 참고로, 위에서 언급한 예외 상황 중 CORS 요청을 제외한 나머지 경우는 요청 시 Sec-Fetch-Mode 헤더의 값을 no-cors로 설정한다. 이는 서버가 보내준 응답에 대해 CORS 정책을 검사하지 않게 하는 대신, 해당 응답을 JavaScript 단에서 읽을 수 없도록 한다. ","date":"2022-01-07","objectID":"/cors/:2:0","tags":["cors","csrf"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"CORS의 필요성 CORS는 CSRF 공격을 막는다. CSRF 공격의 예시는 다음과 같다. 악의적인 마음을 품은 해커가 자신의 웹사이트를 구축해놓고, 이 웹사이트를 가리키는 링크를 담은 메일을 사용자에게 보내는 것이다. 그리고 이 사용자는 A라는 웹사이트에 로그인이 되어 있어서 브라우저 단에 인증 정보가 존재한다고 해보자. 만약 그 사용자가 실수로 해당 링크를 클릭하여 해커의 웹사이트에 접속하면, 해커가 심어둔 JavaScript 코드가 실행되어 자기도 모르게 A 웹사이트로 개인 정보를 조회하는 API 요청을 보낼 것이다. 이 사용자의 브라우저 단에는 인증 정보가 존재하기 때문에, 이것이 해당 요청에 함께 실어서 전송되면 서버는 인증된 요청이라 생각하여 개인 정보를 응답해줄 것이다. 그러고 나면 그 개인 정보를 해커가 빼돌릴 수 있게 된다. 만약 다른 Origin으로의 요청을 막는 정책, 즉 SOP가 존재한다면 문제를 어느 정도 예방할 수 있다. 해커가 구축한 웹사이트와 A 웹사이트는 당연히 Origin이 다르기 때문에, 해커의 웹사이트에서 A 웹사이트로 API 요청을 보낼 수 없기 때문이다. 따라서 SOP는 브라우저의 아주 기본적인 보안 정책으로서 기능한다. ","date":"2022-01-07","objectID":"/cors/:3:0","tags":["cors","csrf"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"CORS 동작 과정 CORS 요청은 다음과 같이 세 가지 과정으로 나눠서 생각해볼 수 있다. ","date":"2022-01-07","objectID":"/cors/:4:0","tags":["cors","csrf"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"단순 요청 (Simple Request) 단순 요청이 되기 위한 조건은 대략 다음과 같다. 메소드가 GET, HEAD, POST 중 하나여야 한다. User Agent가 자동으로 설정한 헤더를 제외하면, 아래와 같은 헤더들만 사용할 수 있다. Accept Accept-Language Content-Language Content-Type DPR Downlink (en-US) Save-Data Viewport-Width Width Content-Type 헤더에는 아래와 같은 값들만 설정할 수 있다. application/x-www-form-urlencode multipart/form-data text/plain 위와 같은 조건을 만족하는 단순 요청은 안전한 요청으로 취급되어, 단 한 번의 요청만을 전송한다. 브라우저는 다른 Origin으로 요청을 보낼 때 Origin 헤더에 자신의 Origin을 설정하고, 서버로부터 응답을 받으면 응답의 Allow-Control-Allow-Origin 헤더에 설정된 Origin의 목록에 요청의 Origin 헤더 값이 포함되는지 검사한다. CORS허용을 위해서는 서버에서 응답의 Allow-Control-Allow-Origin 헤더에 허용되는 Origin의 목록 혹은 와일드카드(*)를 설정해주면 된다. ","date":"2022-01-07","objectID":"/cors/:4:1","tags":["cors","csrf"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"프리플라이트 요청 (Preflight Request) 단순 요청의 조건에 벗어나는(= 안전하지 않은) 요청의 경우, 서버에 실제 요청을 보내기 전에 예비 요청에 해당하는 프리플라이트 요청(Preflight Request)을 먼저 보내서 실제 요청이 전송하기에 안전한지 확인한다. 만약 안전한 요청이라고 확인이 된다면, 그때서야 실제 요청을 서버에게 보낸다. 따라서 총 두 번의 요청을 전송한다. 프리플라이트 요청의 특징은 다음과 같다. 메소드로 OPTIONS를 사용한다. Origin 헤더에 자신의 Origin을 설정한다. Access-Control-Request-Method 헤더에 실제 요청에 사용할 메소드를 설정한다. Access-Control-Request-Headers 헤더에 실제 요청에 사용할 헤더들을 설정한다. 서버는 이러한 프리플라이트 요청에 대해 다음과 같은 특징을 가진 응답을 제공해야 한다. Access-Control-Allow-Origin 헤더에 허용되는 Origin들의 목록 혹은 와일드카드(*)를 설정한다. Access-Control-Allow-Methods 헤더에 허용되는 메소드들의 목록 혹은 와일드카드(*)를 설정한다. Access-Control-Allow-Headers 헤더에 허용되는 헤더들의 목록 혹은 와일드카드(*)를 설정한다. Access-Control-Max-Age 헤더에 해당 프리플라이트 요청이 브라우저에 캐시 될 수 있는 시간을 초 단위로 설정한다. 이러한 응답을 받고 나면 브라우저는 이 응답의 정보를 자신이 전송한 요청의 정보와 비교하여 실제 요청의 안전성을 검사한다. 만약 이 안전성 검사에 통과하게 된다면, 그때서야 실제 요청을 서버에게 보낸다. ","date":"2022-01-07","objectID":"/cors/:4:2","tags":["cors","csrf"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"인증 정보를 포함한 요청 (Credentialed Request) 인증 정보(Credential)란 쿠키(Cookie) 혹은 Authorization 헤더에 설정하는 토큰 값 등을 일컫는다. 만약 이러한 인증 정보를 함께 보내야 하는 요청(Credentialed Request)이라면, 별도로 따라줘야 하는 CORS 정책이 존재한다. 쿠키 등의 인증 정보를 보내기 위해서는 클라이언트 단에서 요청 시 별도의 설정이 필요하다. 이는 Ajax 요청을 위해 어떠한 도구를 사용하느냐에 따라 달라진다. 만약 XMLHttpRequest, jQuery의 ajax, 또는 axios를 사용한다면 withCredentials 옵션을 true로 설정해줘야 한다. 반면, fetch API를 사용한다면 credentials 옵션을 include로 설정해줘야 한다. 이러한 별도의 설정을 해주지 않으면 쿠키 등의 인증 정보는 절대로 자동으로 서버에게 전송되지 않는다. 위와 같은 설정을 통해 인증 정보를 요청에 포함시켰다면, 이 요청은 이제 인증 정보를 포함한 요청이 된다. 그리고 서버는 이러한 요청에 대해 일반적인 CORS 요청과는 다르게 대응해줘야 한다. 응답의 Allow-Control-Allow-Origin 헤더가 와일드카드(*)가 아닌 분명한 Origin으로 설정되어야 하고, Allow-Control-Allow-Credentials 헤더는 true로 설정되어야 한다. 그렇지 않으면 브라우저에 의해 응답이 거부된다. ","date":"2022-01-07","objectID":"/cors/:4:3","tags":["cors","csrf"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"참고 https://it-eldorado.tistory.com/163 ","date":"2022-01-07","objectID":"/cors/:5:0","tags":["cors","csrf"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"ETag(entity tag)는 웹 서버가 주어진 URL의 콘텐츠가 변경되었는지 알려주고 이를 반환하는 HTTP 응답 헤더이다. ETag는 사용하는 캐시가 유효한지 검증하기 위해 사용한다. Static file(js, css, image) 뿐만 아니라 API와 같은 Dynamic content에도 간단하게 Cache기능을 사용하게 설정하면 API속도도 증가되고 유저 입장에서는 네트웍 트래픽을 줄일 수 있다. API와 같이 언제 바뀔지 모르는 데이터의 Cache는 쉽지 않은데, Etag를 이용하면 서버에서 새로운 데이터를 먼저 확인하고 줄 수 있기 때문에 API에도 충분히 적용가능하다. ","date":"2022-01-06","objectID":"/etag/:0:0","tags":["http-cache","etag"],"title":"ETag","uri":"/etag/"},{"categories":["web"],"content":"ETag를 사용한 요청과 응답 예시 클라이언트가 요청을 보낸다. curl -H \"Accept: application/json\" -i http://localhost:8080/spring-boot-rest/foos/1 서버는 ETag를 응답 header에 담아서 보낸다. HTTP/1.1 200 OK ETag: \"f88dd058fe004909615a64f01be66a7\" Content-Type: application/json;charset=UTF-8 Content-Length: 52 클라이언트는 재요청할 때 ETag를 header의 If-None-Match에 담아 요청을 보낸다. Note ETag를 사용할 때 Conditional headers로 If-None-Match와 If-Match가 있다. If-None-Match - 클라이언트에서 캐싱된 ETag와 서버의 ETag가 다를 때 요청을 처리한다. If-Match - 클라이언트에서 캐싱된 ETag와 서버의 ETag가 같을 때 요청을 처리한다. curl -H \"Accept: application/json\" -H 'If-None-Match: \"f88dd058fe004909615a64f01be66a7\"' -i http://localhost:8080/spring-boot-rest/foos/1 리소스가 바뀌지 않았기 때문에 서버는 304 Not Modified를 응답한다. ETag는 이전 요청에 대한 응답과 같다. HTTP/1.1 304 Not Modified ETag: \"f88dd058fe004909615a64f01be66a7\" 클라이언트의 요청에 대해 다른 응답을 하도록 서버의 데이터를 바꾼다. 클라이언트는 같은 요청을 다시 한다. 요청을 다시 할 때는 마지막으로 가지고 있던 ETag를 담아서 보낼 것이다. curl -H \"Accept: application/json\" -H 'If-None-Match: \"f88dd058fe004909615a64f01be66a7\"' -i http://localhost:8080/spring-boot-rest/foos/1 클라이언트에서 보낸 ETag와 서버의 ETag가 다르기 때문에 서버는 요청을 처리한다. 리소스가 바뀌었으니 새로운 ETag를 header에 담아 보낸다. 새로운 요청을 처리했기 때문에 서버는 200 OK를 응답한다. HTTP/1.1 200 OK ETag: \"03cb37ca667706c68c0aad4cb04c3a211\" Content-Type: application/json;charset=UTF-8 Content-Length: 56 ","date":"2022-01-06","objectID":"/etag/:1:0","tags":["http-cache","etag"],"title":"ETag","uri":"/etag/"},{"categories":["web"],"content":"ETag를 사용하지 않은 API vs 사용한 API ETag 사용 예시와 ETag를 사용한 API와 사용하지 않은 API를 비교를 설명하기 위해 간단하게 Controller를 작성해 보았다. @RequestMapping(\"/posts\") @RestController public class PostController { // ... @GetMapping(\"/no-etag\") public ResponseEntity\u003cList\u003cPostResponse\u003e\u003e findAllWhenNoETag() { return ResponseEntity.ok().body(postService.findAll()); } @GetMapping(\"/etag\") public ResponseEntity\u003cList\u003cPostResponse\u003e\u003e findAllWhenETag() { return ResponseEntity.ok().body(postService.findAll()); } // ... } 그리고 ETag 설정으로 ShallowEtagHeaderFilter를 Bean으로 등록해준다. @Configuration public class ETagHeaderFilter { @Bean public ShallowEtagHeaderFilter shallowEtagHeaderFilter() { return new ShallowEtagHeaderFilter(); } } 추가 필터를 구성할 필요 없다면 위의 코드와 같이 작성해도 된다. 하지만 ETag를 사용한 API와 사용하지 않은 API를 비교하기 위해 필터를 사용했다. 추가 필터 구성을 하고 싶다면 다음과 같이 설정해주면 된다. @Configuration public class ETagHeaderFilter { @Bean public FilterRegistrationBean\u003cShallowEtagHeaderFilter\u003e shallowEtagHeaderFilter() { FilterRegistrationBean\u003cShallowEtagHeaderFilter\u003e filterRegistrationBean = new FilterRegistrationBean\u003c\u003e( new ShallowEtagHeaderFilter()); filterRegistrationBean.addUrlPatterns(\"/posts/etag\"); filterRegistrationBean.setName(\"PostAPIFilter\"); return filterRegistrationBean; } } 현재 PostController에서 /posts/etag만 etag를 사용한다는 설정이다. 만약 /post/에 대해 전부 ETag를 설정하고 싶다면 filterRegistrationBean.addUrlPatterns(\"/posts/*\") 이렇게 설정하면 된다. 그럼 이제 /no-etag와 /etag를 호출해 보자. 얼핏 보면 둘의 차이가 안 보인다. 하지만 Response Headers를 보면 차이를 볼 수 있다. 두 응답의 차이를 볼 수 있는 곳은 ETag일 것이다. /etag는 ETag를 사용하고 있기 때문에 응답으로 ETag를 header에 해시값으로 보내준다. 이는 재요청할 때 header의 If-None-Match의 값으로 보내 줄 것이다. If-None-Match: \"0fad8e1b47f45fa4ce7fef400e87c9289\" 이렇게 ETag를 /etag 요청 header의 If-None-Match에 담아 재요청해 보겠다. etag를 보면 앞서 설명했듯이 같은 요청에 대해서 304 상태 코드를 응답한다. 이는 서버에서 캐시 유효성 검사를 한 결과 변경되지 않았기 때문이다. 여기서 봐야 할 것은 사이즈다. no-etag는 재요청에 대해서 796B -\u003e 796B인 반면에 etag는 820B -\u003e 145B이다. 이유는 ETag를 사용하지 않으면 했던 일을 똑같이 또 하지만, ETag를 사용하면 같은 요청에 대해서 변경된 리소스가 없다면 304 상태 코드와 ETag를 header에 담아 보내줄 뿐 요청에 대한 리소스를 또 보내지 않기 때문이다. ","date":"2022-01-06","objectID":"/etag/:2:0","tags":["http-cache","etag"],"title":"ETag","uri":"/etag/"},{"categories":["web"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-09-30-ETag-with-Spring/ ","date":"2022-01-06","objectID":"/etag/:3:0","tags":["http-cache","etag"],"title":"ETag","uri":"/etag/"},{"categories":["개발방법론"],"content":"테스트 더블(Test Double)이란 xUnit Test Patterns의 저자인 제라드 메스자로스(Gerard Meszaros)가 만든 용어로 테스트를 진행하기 어려운 경우 이를 대신해 테스트를 진행할 수 있도록 만들어주는 객체를 말한다. 테스트 더블이라는 용어는 영화 촬영 시 위험한 역할을 대신하는 스턴트 더블에서 비롯되었다. 예를 들어 우리가 데이터베이스로부터 조회한 값을 연산하는 로직을 구현했다고 하자. 해당 로직을 테스트하기 위해선 항상 데이터베이스의 영향을 받을 것이고, 이는 데이터베이스의 상태에 따라 다른 결과를 유발할 수도 있다. 이처럼 테스트하려는 객체와 연관된 객체를 사용하기가 어렵고 모호할 때 대신해 줄 수 있는 객체를 테스트 더블이라 한다. ","date":"2022-01-01","objectID":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/:0:0","tags":["dummy","fake","stub","mock"],"title":"테스트 더블(Test Double)","uri":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/"},{"categories":["개발방법론"],"content":"Dummy 인스턴스화 된 객체가 필요하지만 기능은 필요하지 않은 경우에 사용한다. Dummy 객체의 메서드가 호출되었을 때 정상 동작은 보장하지 않는다. 객체는 전달되지만 사용되지 않는 객체이다. 간단한 예시를 통해 알아보자. public interface PringWarning { void print(); } public class PrintWarningDummy implements PrintWarning { @Override public void print() { // 아무런 동작을 하지 않는다. } } 실제 객체는 PrintWarning 인터페이스의 구현체를 필요하지만, 특정 테스트에서는 해당 구현체의 동작이 전혀 필요하지 않을 수 있다. 실제 객체가 로그용 경고만 출력한다면 테스트 환경에서는 전혀 필요 없기 때문이다. 이런 경우에는 print() 가 아무런 동작을 하지 않아도 테스트에는 영향을 미치지 않는다. ","date":"2022-01-01","objectID":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/:1:0","tags":["dummy","fake","stub","mock"],"title":"테스트 더블(Test Double)","uri":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/"},{"categories":["개발방법론"],"content":"Fake 복잡한 로직이나 객체 내부에서 필요로 하는 다른 외부 객체들의 동작을 단순화하여 구현한 객체이다. 동작의 구현을 가지고 있지만 실제 프로덕션에는 적합하지 않은 객체이다. 간단한 예시를 통해 알아보자. @Entity public class User { @Id private Long id; private String name; protected User() {} public User(Long id, String name) { this.id = id; this.name = name; } public Long getId() { return this.id; } public String getName() { return this.name; } } public interface UserRepository { void save(User user); User findById(long id); } public class FakeUserRepository implements UserRepository { private Collection\u003cUser\u003e users = new ArrayList\u003c\u003e(); @Override public void save(User user) { if (findById(user.getId()) == null) { user.add(user); } } @Override public User findById(long id) { for (User user : users) { if (user.getId() == id) { return user; } } return null; } } 테스트해야 하는 객체가 데이터베이스와 연관되어 있다고 가정해보자. 그럴 경우 실제 데이터베이스를 연결해서 테스트해야 하지만, 실제 데이터베이스 대신 가짜 데이터베이스 역할을 하는 FakeUserRepository를 만들어 테스트 객체에 주입하는 방법도 있다. 이렇게 하면 테스트 객체는 데이터베이스에 의존하지 않으면서도 동일하게 동작을 하는 가짜 데이터베이스를 가지게 된다. ","date":"2022-01-01","objectID":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/:1:1","tags":["dummy","fake","stub","mock"],"title":"테스트 더블(Test Double)","uri":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/"},{"categories":["개발방법론"],"content":"Stub 테스트에서 호출된 요청에 대해 미리 준비해둔 결과를 제공한다. 간단한 예시를 통해 살펴보자. public interface UserRepository { void save(User user); User findById(long id); } public class StubUserRepository implements UserRepository { // ... @Override public User findById(long id) { return new User(id, \"Test User\"); } } 위의 코드처럼 StubUserRepository는 findById() 메서드를 사용하면 언제나 Test User라는 이름을 가진 User 인스턴스를 반환받는다. 테스트 환경에서 User 인스턴스의 name을 Test User만 받기를 원하는 경우 이처럼 동작하는 객체(UserRepository의 구현체)를 만들어 사용할 수 있다. 물론 이러한 방식의 단점은 테스트가 수정될 경우(findById() 메서드가 반환해야 할 값이 변경되야 할 경우) Stub 객체도 함께 수정해야 하는 단점이 있다. public interface UserRepository { void save(User user); User findById(long id); } SpringBoot에서의 Mockito 프레임워크는 다음과 같이 Stub을 검증할 수 있다. @ExtendWith(MockitoExtension.class) public class UserServiceTest { @Mock private UserRepository userRepository; @Test void test() { when(userRepository.findById(anyLong())).thenReturn(new User(1, \"Test User\")); User actual = userService.findById(1); assertThat(actual.getId()).isEqualTo(1); assertThat(actual.getName()).isEqualTo(\"Test User\"); } } ","date":"2022-01-01","objectID":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/:1:2","tags":["dummy","fake","stub","mock"],"title":"테스트 더블(Test Double)","uri":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/"},{"categories":["개발방법론"],"content":"Mock 객체의 행동을 사전에 설정하고, 그 행동이 제대로 호출되었는지를 검증한다. SpringBoot에서의 Mockito 프레임워크는 다음과 같이 Mock을 검증할 수 있다. public interface UserRepository { void save(User user); User findById(long id); } @ExtendWith(MockitoExtension.class) public class UserServiceTest { @Mock private UserRepository userRepository; @Test void test() { User actual = userService.findById(1); verify(userRepository).findById(any()); } } ","date":"2022-01-01","objectID":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/:1:3","tags":["dummy","fake","stub","mock"],"title":"테스트 더블(Test Double)","uri":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/"},{"categories":["개발방법론"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/ ","date":"2022-01-01","objectID":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/:2:0","tags":["dummy","fake","stub","mock"],"title":"테스트 더블(Test Double)","uri":"/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double/"}]