[{"categories":["java"],"content":"Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다. 위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다. 캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다. - 나무위키 Array 는 연속적인 memory block 으로, array 에 처음 접근할 때 전체 array 가 cache 에 로드된다. 첫 액세스 이후로는 공간 지역성이 생기는 것이다. 그러나 java 는 jvm 이 알아서 메모리를 관리 하기 때문에 array 사용시 cache locality 가 적용되는지 여부는 jvm 이 메모리 관리하는 방법을 공부해서 좀 더 알아봐야 할 것 같다. 지금 자세한 설명을 할 지식은 없지만 아마 java 에서는 ‘해당사항 없음’ 이라는 결론이 날 것 같다. ","date":"2022-02-17","objectID":"/array-arraylist/:1:0","tags":["array","array-list"],"title":"Array \u0026 ArrayList","uri":"/array-arraylist/"},{"categories":["java"],"content":"ArrayList Java 의 ArrayList 는 AbstractList 를 상속받고 List 인터페이스를 구현한 클래스이다. Array 와 비슷하지만 size 가 dynamic 하게 조절된다. ArrayList.java 코드를 열어보면 default size 는 10 인 것을 알 수 있다. private static final int DEFAULT_CAPACITY = 10; ArrayList 에서 새로운 element 를 추가하는 메소드는 add() 로, 두 가지 방식의 오버로딩 된 메소드가 정의되어 있다. /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return \u003ctt\u003etrue\u003c/tt\u003e (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 아래에 있는 add() 메소드는 특정 index 에 element 를 삽입하는 메소드로, 어떤 작업을 한 다음에 기존 array 를 copy 한 더 큰 size 를 가진 새로운 array 를 만들어 낸다. 결국 copy 라는 작업이 필요한 것이다. 그럼 매개변수 하나만 받는 위에있는 add() 는 어떻게 동작하는 걸까? 방금 언급한 어떤 작업 에서 ensureCapacityInternal() 메소드가 사이즈 조절을 담당한다. private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u003e 0) grow(minCapacity); } ensureCapacityInternal() 메소드로 가보면, 사이즈 조절을 위해 ensureExplicitCapacity() 를 또 호출한다. ensureExplicitCapacity() 메소드에서는 if (minCapacity - elementData.length \u003e 0) 이 if 문에 의해 현재 data 를 담고 있는 array 의 length 가 full 이면 grow() 라는 함수를 호출해서 size 를 늘린다. grow() 함수로 가보면 /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } int newCapacity = oldCapacity + (oldCapacity » 1); 여기가 포인트다. 비트연산으로 기존 size 의 1/2 만큼 새로운 capacity 를 할당하도록 한다. oldCapacity 값이 10 (default) 이었다면, 10 » 1 의 경우 10 의 2진수인 1010(2) 을 1-bit right shifting 한 값인 0101(2) , 즉 10진수 5 만큼 size 를 키우는 것이다. 이렇게 size 키워서 결국 한다는 게 copy 다. 결국 java 에서 제공하는 ArrayList 도 별다른 신박한 방법으로 관리하는 array 가 아니라 그냥 array 인 것이다. 즉, size 가 고정되지 않게 하려면 비용이 많이 든다는 단점이 있는 것은 확실하다. ","date":"2022-02-17","objectID":"/array-arraylist/:2:0","tags":["array","array-list"],"title":"Array \u0026 ArrayList","uri":"/array-arraylist/"},{"categories":["java"],"content":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:1:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:2:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:3:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Local Class 중괄호 내에, 특히 메소드 내에 정의 ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:4:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:5:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다. public interface Comparable\u003cT\u003e { int compareTo(T obj); } 사용 예시는 다음과 같다. import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable\u003cPerson\u003e { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void showData() { System.out.printf(\"%s %d \\n\", name, age); } public int compareTo(Person p) { if (age \u003e p.age) return 1; else if (age \u003c p.age) return -1; else return 0; } } class ComparablePerson { public static void main(String[] args) { TreeSet\u003cPerson\u003e sTree = new TreeSet\u003cPerson\u003e(); sTree.add(new Person(\"Lee\", 24)); sTree.add(new Person(\"Hong\", 29)); sTree.add(new Person(\"Choi\", 21)); Iterator\u003cPerson\u003e itr = sTree.iterator(); while (itr.hasNext()) itr.next().showData(); } } ","date":"2022-02-15","objectID":"/comparable-and-comparator/:1:0","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이","uri":"/comparable-and-comparator/"},{"categories":["java"],"content":"Comparator 인터페이스 String 클래스는 이미 compareTo 메소드를 구현하고 있다. 이 때 정령기준을 변경하기 위해서 String 클래스를 상속하는 클래스를 새로 정의하는 것은 번거롭다 따라서 새로운 정렬 기준을 파라미터로 넘길 수 있도록 정의된 것이 Comparator 인터페이스이다. public interface Comparator\u003cT\u003e { int compare(T o1, T o2); } 사용 예시는 다음과 같다. import java.util.TreeSet; import java.util.Iterator; import java.util.Comparator; class StrLenComparator implements Comparator\u003cString\u003e { public int compare(String str1, String str2) { if (str1.length() \u003e str2.length()) return 1; else if (str1.length() \u003c str2.length()) return -1; else return 0; /* * return str1.length()-str2.length(); */ } } class IntroComparator { public static void main(String[] args) { TreeSet\u003cString\u003e tSet = new TreeSet\u003cString\u003e(new StrLenComparator()); tSet.add(\"Orange\"); tSet.add(\"Apple\"); tSet.add(\"Dog\"); tSet.add(\"Individual\"); Iterator\u003cString\u003e itr = tSet.iterator(); while (itr.hasNext()) System.out.println(itr.next()); } } ","date":"2022-02-15","objectID":"/comparable-and-comparator/:2:0","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이","uri":"/comparable-and-comparator/"},{"categories":["spring"],"content":"Spring의 대표적인 핵심가치 3가지로 IoC, AOP, PSA가 있다. ","date":"2022-02-15","objectID":"/spring-psa/:0:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"PSA (Portable Service Abstraction) @Transactional 어노테이션을 선언하는 것 만으로 별도의 코드 추가 없이 트랜잭션 서비스를 사용할 수 있다. 내부적으로 트랜잭션 코드가 추상화되어 숨겨져 있는 것이다. 이렇게 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이며, 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다. ","date":"2022-02-15","objectID":"/spring-psa/:1:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"PSA의 원리 트랜잭션을 예로 들어 설명하겠다. 위 그림처럼 Spring의 @Transactional은 각 TransactionManager를 각각 구현하고 있는 것이 아니라 최상위 PlatformTransactionManager를 이용하고 필요한 TransactionManager를 DI로 주입받아 사용하고 있다. PlatformTransactionManager 인터페이스의 소스코드는 다음과 같다. public interface PlatformTransactionManager extends TransactionManager { TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException; } ","date":"2022-02-15","objectID":"/spring-psa/:2:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["design pattern"],"content":"프록시 패턴 Proxy는 우리말로 대리자, 대변인 이라는 뜻이다. 대리자, 대변인은 다른 누군가를 대신해서 그 역할을 수행하는 존재를 말한다. 프록시는 타겟의 기능을 확장하거나 타깃에 대한 접근을 제어하기 위한 목적으로 사용된다. ","date":"2022-02-06","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/:1:0","tags":["proxy"],"title":"프록시 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/"},{"categories":["design pattern"],"content":"상속을 사용한 구현 아래와 같은 타겟 클래스가 있다고 하자. public class GameService { public void startGame() { System.out.println(\"Hello\"); } } 다음과 같이 프록시 클래스가 타겟 클래스를 상속받도록 만든다. public class GameServiceProxy extends GameService { @Override public void startGame() { long before = System.currentTimeMillis(); //상위 메소드 실행 super.startGame(); System.out.println(System.currentTimeMillis() - before); } } public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(); gameService.startGame(); } } 결과는 다음과 같다. Hello 0 ","date":"2022-02-06","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/:1:1","tags":["proxy"],"title":"프록시 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/"},{"categories":["design pattern"],"content":"인터페이스를 사용한 구현 인터페이스를 사용할 경우, 좀 더 구조가 유연하며 테스트하기에도 쉽다. 다음과 같이 인터페이스를 선언한다. public interface GameService { void startGame(); } 인터페이스를 구현한 클래스를 만들고, 메소드를 오버라이드한다. public class DefaultGameService implements GameService{ @Override public void startGame() { System.out.println(\"Hello\"); } } 다음과 같이 프록시 클래스를 선언한다. @RequiredArgsConstructor public class GameServiceProxy implements GameService { //GameService를 외부에서 주입받는다. private final GameService gameService; @Override public void startGame() { long before = System.currentTimeMillis(); gameService.startGame(); System.out.println(System.currentTimeMillis() - before); } } 클라이언트에서는 GameService 구현체를 생성하여 프록시 객체에 넘겨준다. public class Client { public static void main(String[] args) { GameService gameService = new GameServiceProxy(new DefaultGameService()); gameService.startGame(); } } ","date":"2022-02-06","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/:1:2","tags":["proxy"],"title":"프록시 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/"},{"categories":["design pattern"],"content":"다이나믹 프록시 프록시 패턴의 단점은 다음과 같다. 인터페이스를 직접 구현해야 한다. 프록시 클래스 내에 중복이 발생한다. 위와 같은 문제는 다이나믹 프록시를 사용하여 해결할 수 있다. Dynamic Proxy는 런타임 시점에 인터페이스를 구현하는 클래스 또는 인스턴스를 만드는 기술을 말한다. 다이나믹 프록시를 사용하면, 일일이 구현해야한다는 문제는 reflection API가 해결해주고, 중복은 InvocationHandler가 해결해준다. InvocationHandler의 invoke() 메소드에서 타겟의 어떤 메소드에 적용할지 검사하고, 적용해야 하는 메소드라면 타겟의 원래 메소드를 호출하여 결과를 담아둔 뒤 추가 기능을 적용하여 리턴한다. 적용하지 말아야 하는 메소드라면 타겟의 원래 메소드의 리턴을 그대로 리턴한다. BookService bookService = (BookService) Proxy.newProxyInstance(BookService.class.getClassLoader(), new Class[]{BookService.class}, new InvocationHandler() { BookService bookService = new RealSubjectBookService(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName() == \"rent\") { System.out.println(\"11111\"); Object invoke = method.invoke(bookService, args); System.out.println(\"22222\"); return invoke; } return method.invoke(bookService, args); } }); Proxy.newProxyInstance 메소드를 이용해 프록시 객체를 생성한다. 첫번째 인자는 프록시 객체를 생성할 인터페이스 타입의 클래스로더 두번째 인자는 해당 프록시가 어떤 인터페이스를 구현체인가 3번째 인자는 이를 구현하는 InvocationHandler 이다. InvocationHandler는 invoke 메소드를 구현한다. 첫번째 인자는 newProxyInstance를 사용해 생성된 프록시 객체의 참조 두번째 인자는 프록시를 통해 호출된 메소드의 참조 세번째 인자는 해당 메소드의 파라메터들의 참조 invoke 메소드 내에서 method.invoke 를 통해 메소드를 호출할 수 있다. 만약 프록시 객체를 통해 부가적인 기능을 추가하고싶다면 invoke 메소드 내에서 구현을 해주면 된다. ","date":"2022-02-06","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/:2:0","tags":["proxy"],"title":"프록시 패턴","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/"},{"categories":["java"],"content":"데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다. 결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다. 이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다. public enum PayType { ACCOUNT_TRANSFER(\"계좌이체\"), REMITTANCE(\"무통장입금\"), ON_SITE_PAYMENT(\"현장결제\"), TOSS(\"토스\"), PAYCO(\"페이코\"), CARD(\"신용카드\"), KAKAO_PAY(\"카카오페이\"), BAEMIN_PAY(\"배민페이\"), POINT(\"포인트\"), COUPON(\"쿠폰\"); private final String title; PayType(String title) { this.title = title; } public String getTitle() { return title; } } import lombok.Getter; import java.util.Arrays; import java.util.Collections; import java.util.List; @Getter public enum PayGroup { CASH(\"현금\", Arrays.asList(PayType.ACCOUNT_TRANSFER, PayType.REMITTANCE, PayType.ON_SITE_PAYMENT, PayType.TOSS)), CARD(\"카드\", Arrays.asList(PayType.PAYCO, PayType.CARD, PayType.KAKAO_PAY, PayType.BAEMIN_PAY)), ETC(\"기타\", Arrays.asList(PayType.POINT, PayType.COUPON)), EMPTY(\"없음\", Collections.EMPTY_LIST); private final String title; private final List\u003cPayType\u003e payList; PayGroup(String title, List\u003cPayType\u003e payList) { this.title = title; this.payList = payList; } public static PayGroup findByPayType(PayType payType){ return Arrays.stream(PayGroup.values()) .filter(payGroup -\u003e payGroup.hasPayType(payType)) .findAny() .orElse(EMPTY); } private boolean hasPayType(PayType payType){ return payList.stream() .anyMatch(pay -\u003e pay == payType); } } import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PayGroupTest { @Test public void PayGroup에게_직접_결제종류_물어보기_PayType () { PayType payType = selectPayType(); PayGroup payGroup = PayGroup.findByPayType(payType); assertEquals(payGroup.name(), \"CARD\"); assertEquals(payGroup.getTitle(), \"카드\"); } private PayType selectPayType(){ return PayType.BAEMIN_PAY; } } DB 혹은 API에서 PayType으로 데이터를 받아, 타입 안전성까지 확보하여 PayGroup 관련된 처리를 진행할 수 있게 되었다. ","date":"2022-02-04","objectID":"/enum-usage-2/:0:0","tags":["enum"],"title":"Enum 사용 (활용)","uri":"/enum-usage-2/"},{"categories":["java"],"content":"참고 https://github.com/jojoldu/blog-code/tree/master/enum-settler ","date":"2022-02-04","objectID":"/enum-usage-2/:1:0","tags":["enum"],"title":"Enum 사용 (활용)","uri":"/enum-usage-2/"},{"categories":["java"],"content":"상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 “CALC_A\"일 경우엔 값 그대로, “CALC_B\"일 경우엔 10 한 값을, “CALC_C\"일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 “DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.“는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다. import java.util.function.Function; public enum CalculatorType { CALC_A(value -\u003e value), CALC_B(value -\u003e value * 10), CALC_C(value -\u003e value * 30), CALC_ETC(value -\u003e 0L); private Function\u003cLong, Long\u003e expression; CalculatorType(Function\u003cLong, Long\u003e expression) { this.expression = expression; } public long calculate(long value) { return expression.apply(value); } } import javax.persistence.Column; import javax.persistence.EnumType; import javax.persistence.Enumerated; public class Entity { @Column //@Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다. @Enumerated(EnumType.STRING) private CalculatorType calculatorType; } import org.testng.annotations.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTypeTest { private CalculatorType selectType() { return CalculatorType.CALC_B; } @Test public void 코드에_따라_서로다른_계산하기_Enum() { CalculatorType code = selectType(); long originValue = 10000L; long result = code.calculate(originValue); assertEquals(result, 100000L); } } 값(상태)과 메소드(행위)가 어떤 관계가 있는지에 대해 더이상 다른 곳을 찾을 필요가 없게 되었다. 코드내에 전부 표현되어 있고, Enum 상수에게 직접 물어보면 되기 때문이다. ","date":"2022-02-03","objectID":"/enum-usage-1/:1:0","tags":["enum"],"title":"Enum 사용 (개념)","uri":"/enum-usage-1/"},{"categories":["ML"],"content":"Step Function 활성화 함수는 신경망의 행동을 결정하는 중요한 역할을 합니다. 가장 간단한 형태의 활성화 함수는 계단 함수(Step function) 라고 합니다. 계단 함수는 입력값의 합이 임계값을 넘으면 $0$ 을, 넘지 못하면 $1$ 을 출력하게 됩니다. 계단 함수의 그래프는 다음과 같이 생겼습니다. 이미지 출처 : wikipedia - Heaviside step function 계단 함수는 활성화 함수의 조건을 가장 잘 만족하는 함수이고 직관적으로도 이해하기 쉽습니다. 하지만 불연속 함수라는 단점 때문에 실제 신경망에 사용되지는 않습니다. 그래프를 보면 알 수 있듯 임계값 지점에서 불연속점을 갖게 되는데 이 점에서 미분이 불가능하기 때문에 학습이 필요한 신경망에 사용할 수 없습니다. 이런 문제점을 해결하기 위해서 등장한 것이 시그모이드 함수(Sigmoid) 입니다. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:1:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"Sigmoid Function 시그모이드 함수는 기본적으로 $S$ 모양을 그리는 곡선 함수를 통칭하여 부르는 말입니다. 이 중 대표적인 함수는 로지스틱(Logistic) 함수와 하이퍼탄젠트(Hyper tangent, $\\tanh$) 함수가 있습니다. 두 함수의 수식과 그래프를 보며 시그모이드 함수와 계단 함수가 다른 점이 무엇인지 알아보도록 하겠습니다. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"로지스틱 함수(Logistic Function) $$ \\text{Logistic} : \\frac{1}{1+e^{-x}} $$ 이미지 출처 : wikipedia - Logistic function ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:1","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"하이퍼탄젠트 함수(Hypertangent Function) $$ \\text{Hypertangent} : \\frac{e^x-e^{-x}}{e^x+e^{-x}} = \\frac{e^{2x}-1}{e^{2x}+1} $$ 이미지 출처 : mathworld.wolfram.com 두 함수는 모두 연속함수입니다. 계단 함수의 치명적인 단점이었던 불연속을 해결했지요. 계단 함수와 시그모이드 함수의 중요한 공통점은 비선형 함수(Non-linear) 라는 점입니다. 활성화 함수는 비선형 함수를 사용해야 합니다. 활성화 함수가 선형 함수이면 안되는 이유는 무엇일까요? 선형인 활성화 함수 $l(x) = ax + b$ 가 있다고 해보겠습니다. 이 함수를 사용하여 3개의 층을 쌓는다면 최종적인 활성화 함수는 $l(l(l(x))) = l^3(x) = a(a(ax+b)+b)+b = a^3x+a^2b+ab+b$가 됩니다. $a^3 = c, d = a^2b+ab+b$라고 하면 $l^3(x) = cx+d$로 여전히 같은 형태의 함수를 사용하게 됩니다. 이렇듯 층을 아무리 깊게 쌓아도 여러 층을 쌓는 이점을 살리지 못하게 되지요. 여러 층을 쌓을 때의 장점을 살리기 위해 비선형 함수를 사용하게 되는 것이지요. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:2","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"ReLU Function 시그모이드 함수는 불연속이라는 계단 함수의 단점을 해결했습니다. 하지만 시그모이드는 대부분의 점에서 기울기 값이 0이 됩니다. 이 때문에 **기울기 소실(Gradient vanishing)**이라는 문제가 발생합니다. 기울기 소실은 시그모이드 함수를 활성화 함수로 사용하여 층을 깊게 쌓았을 때 학습이 잘 되지 않는 현상입니다. 이런 현상이 왜 발생하는지 알아보겠습니다. 로지스틱 함수 $L(x)$를 미분한 함수 $L^\\prime(x)$ 의 수식은 다음과 같습니다. $$ L^\\prime(x) = \\bigg(\\frac{1}{1+e^{-x}}\\bigg)^\\prime = \\frac{e^x}{(1+e^{-x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 그래프에서 볼 수 있듯 최댓값이 $0.25$ 밖에 되지 않고 $x\u003c-5, x\u003e5$ 범위에서는 거의 $0$ 에 가깝습니다. 역전파(Back propagation) 과정에서는 미분값을 사용하여 학습을 하게 됩니다. 따라서 이 값이 0에 가까워 지면 정보가 유실되면서 학습이 잘 안되게 됩니다. 특히 층을 깊게 쌓을 경우에는 정보가 모두 유실되는 사태가 발생하게 되지요. 그렇다면 하이퍼탄젠트 함수는 어떻게 될까요? 하이퍼탄젠트 함수 $\\tanh$를 미분한 함수의 수식은 다음과 같습니다. $$ \\tanh^\\prime(x) = \\bigg(\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\bigg)^\\prime = \\frac{4e^{2x}}{(1+e^{2x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 하이퍼탄젠트 함수를 미분한 함수의 최댓값은 $1$ 입니다. 최댓값이 $0.25$ 밖에 안되었던 로지스틱 함수 보다는 정보를 잘 전달하게 되지요. 하지만 여전히 $x$ 가 0에서 멀어질수록 원래 함수의 미분값은 0에 가까워집니다. 그래서 하이퍼탄젠트 함수를 활성화 함수로 하더라도 퍼셉트론을 여러 층으로 쌓는다면 학습이 제대로 안되게 되지요. 이렇게 시그모이드 함수를 활성화 함수로 사용할 때 역전파시 학습이 제대로 진행되지 않는 현상을 기울기 소실이라고 합니다. 기울기 소실 문제를 극복하기 위해서 등장한 함수가 바로 ReLU(Rectified Linear Unit)함수입니다. ReLU함수는 입력값이 0보다 작을 경우에는 0을 반환하고, 0보다 클 경우에는 입력값을 그대로 반환합니다. 아래는 ReLU함수의 그래프를 나타낸 것입니다. 이미지 출처 : medium.com ReLU함수는 $x$ 가 $0$ 보다 클 때, 미분값이 항상 $1$ 입니다. 그래서 층이 아무리 깊어져도 손실없이 정보를 전달할 수 있습니다. 미분값이 항상 $0$과 $1$ 이기 때문에 연산이 빠르다는 점도 ReLU함수의 장점입니다. 덕분에 ReLU함수는 은닉층에서 가장 많이 사용되는 활성화 함수가 되었습니다. 물론 ReLU함수에게도 문제가 있습니다. 0이하의 값이 그대로 보존되지 않고 버려진다는 것이지요. 이를 보완하기 위해 Leaky ReLU함수가 고안되어 사용되고 있습니다. 일반적으로는 $a=0.01$을 사용하며 그래프는 다음과 같습니다. 이미지 출처 : medium.com ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:3:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["spring"],"content":"Spring mocking 없이 테스트하려면? 아래 코드를 mocking 없이 테스트하려면 어떻게 해야 할까? package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import java.io.IOException; public class RepositoryRank { public int getPoint(String repositoryName) throws IOException { GitHub github = GitHub.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u003e 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public static void main(String[] args) throws IOException { RepositoryRank repositoryRank = new RepositoryRank(); int point = repositoryRank.getPoint(\"whiteship/live-study\"); System.out.println(point); } } Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입하면 된다. 설명과 코드는 다음과 같다. package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import org.kohsuke.github.GitHubBuilder; import java.io.IOException; public class RepositoryRank { //인터페이스 선언 interface GitHubService { GitHub connect() throws IOException; } //인터페이스를 구현한 클래스 생성하고 모킹하고자 하는 메소드를 오버라이드한다. static class DefaultGitHubService implements GitHubService { @Override public GitHub connect() throws IOException { return new GitHubBuilder().build(); } } private final GitHubService gitHubService; //서비스를 주입받는다. public RepositoryRank(GitHubService gitHubService) { this.gitHubService = gitHubService; } public int getPoint(String repositoryName) throws IOException { GitHub github = gitHubService.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u003e 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public void main(String[] args) throws IOException { GitHubService gitHubService = new DefaultGitHubService(); //Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입 RepositoryRank repositoryRank = new RepositoryRank(gitHubService); int point = repositoryRank.getPoint(\"whiteship/live-study\"); System.out.println(point); } } ","date":"2022-01-01","objectID":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/:1:0","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법","uri":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/"},{"categories":["spring"],"content":"참고 백기선님의 유튜브를 참고했다. https://youtu.be/bJfbPWEMj_c ","date":"2022-01-01","objectID":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/:2:0","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법","uri":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/"}]