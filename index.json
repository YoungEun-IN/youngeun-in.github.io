[{"categories":["web"],"content":"쿠키 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다. 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다. 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다. 클라이언트에 300개까지 쿠키저장 가능하며, 하나의 도메인당 20개의 값만 가질 수 있다. 하나의 쿠키값은 4KB까지 저장한다. Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다. ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:1:0","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"세션 세션은 쿠키에 기반하고 있지만, 사용자 정보를 서버 측에서 관리한다. 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다. 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능 하다. 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다. 즉 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 된다. 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션 ID이다. ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:2:0","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"쿠키 vs 세션 Cookie Session 저장위치 Client Server 저장형식 Text Object 만료시점 쿠키 저장시 설정 (설정 없으면 브라우저 종료 시) 정확한 시점 모름 리소스 클라이언트의 리소스 서버의 리소스 용량제한 한 도메인 당 20개, 한 쿠키당 4KB 제한없음 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:0","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"저장 위치 쿠키 : 클라이언트의 웹 브라우저가 지정하는 메모리 or 하드디스크 세션 : 서버의 메모리에 저장 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:1","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"만료 시점 쿠키 : 저장할 때 expires 속성을 정의해 무효화시키면 삭제될 날짜 정할 수 있음 세션 : 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화 되기 때문에 정확한 시점 알 수 없음 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:2","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"리소스 쿠키 : 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원 사용하지 않음 세션 : 세션은 서버에 저장되고, 서버 메모리로 로딩 되기 때문에 세션이 생길 때마다 리소스를 차지함 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:3","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"용량 제한 쿠키 : 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 걸 막고자 한 도메인당 20개, 하나의 쿠키 당 4KB로 제한해 둠 세션 : 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한 없음 ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:3:4","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["web"],"content":"참고 https://interconnection.tistory.com/74 https://gyoogle.dev/blog/web-knowledge/Cookie%20\u0026%20Session.html ","date":"2022-05-24","objectID":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/:4:0","tags":["cookie","session"],"title":"쿠키 vs 세션","uri":"/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/"},{"categories":["etc"],"content":"1. JPG - Joint Photographic Experts Group(JPEG) JPG와 JPEG에 대해서 간단히 설명하겠다. JPG와 JPEG의 관계를 알기 위해서는 지금은 거의 사용되지 않은 도스(DOS)를 조금 살펴보아야 한다. 도스는 윈도우가 보편화되기 전에 주로 사용되던 프로그램으로 일종의 운영체제이다. 도스에서는 파일명을 최대 8자, 확장자를 최대 3자까지 밖에 사용할 수 없어 기존의 4자리로 된 JPEG를 줄여 JPG로 사용한 게 시초가 되었다. 하지만, 윈도우 macOS 등 다양한 운영체제가 개발되면서 파일명과 확장자를 포함하여 최대 255자까지 사용할 수 있게 되면서, JPEG를 굳이 JPG로 표기할 필요가 없게 되었다. JPG 파일에 대해서 알아보겠다. JPG 파일은 기본적으로 raster-based 이미지(웹, 인쇄 용도로 사용되는 이미지)이다. JPG 형식은 디지털 카메라 파일의 기본 형식인데, 압축과 대부분의 브라우저를 지원하는 이유로 웹에서 널리 사용되고 있는 형식이다. 이런 파일 형식은 파일의 크기가 작고, 품질 손실이 거의 없는 사진 파일을 저장하는데 가장 적합하다. JPG는 손실 압축을 사용하므로 다시 저장할 때마다 품질이 저하된다. JPG 파일을 올바르게 사용하기 위해서는 올바른 크기와 해상도로 저장해야 한다. 그렇지 않으면 흔히 ‘깨져 보이는’ 픽셀화 또는 이미지가 늘어져 보이기 때문이다. 이런 이유로 소셜 미디어 플랫폼 등에서는 이미지의 크기를 사용하여 해상도를 제어한다. 손실 압축 손실 압축이란, 이미지를 저장할 때 데이터를 없애 더 작은 사이즈로 압축하는 방식을 이른다. 그 결과 더 낮은 해상도를 갖게 되지만, 파일 크기와 다운로드 속도가 필수적인 온라인에서는 이상적이다. ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:1:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"2. PNG - Portable Network Graphic PNG는 웹 사용 표준이다. 픽셀 기반이며, 이미지의 크기를 키울 경우, 픽셀화가 일어난다. JPG와 비슷하게, 최종 사용에 적합한 크기로 내보내야한다. 하지만 JPG와 다르게, PNG 파일은 투명한 배경을 지원하며 손실없는 압축으로 그래픽(사진 아님)용 JPG보다 전반적으로 고품질의 이미지를 유지할 수 있다. 즉, 파일을 저장해도 품질이 저하되지 않는다. PNG는 로고, 아이콘, 간단한 일러스트처럼 선명하게 유지해야 하는 색상 간 전환과 색상이 적은 그래픽에 사용하는 것이 더 좋다. 또한, 웹 사이트와 소셜 미디어에서 PNG를 사용하여 디지털 및 모바일 디스플레이에서 더 선명한 이미지를 만들 수 있다. 이런 이유로 고품질을 유지하면서 파일 크기를 최대한 낮게 설정하여 PNG 파일을 사용하는 것은 웹 최적화에 유리하다. 참고로 PNG-24는 PNG-8보다 선명하지만 더 많은 색상으로 이미지를 저장하기 때문에 파일 크기가 훨씬 커질 수 있으므로 사용에 주의가 필요하다. ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:2:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"3. GIF - Graphics Interchange Format GIF는 모든 주요 웹 브라우저와 대부분의 이미지 편집기에서 지원되는 유일한 애니메이션 이미지 형식이다. GIF는 투명도와 애니메이션을 지원하고 파일을 줄이기 위해서 높은 압축률로 압축될 수 있다. GIF는 색상이 거의 필요없는 애니메이션 그래픽에서 자주 사용되는 무손실 raster 형식이다. GIF는 오직 256가지 색만 지원하기 때문에, 사진을 저장하는 경우는 권장하지 않는다. 다른 애니메이션 이미지 파일 형식으로 APNG(Animated Portable Network Graphics), WebP, MNG(Multiple-Image Network Graphics), FLIF(Free Lossless Image Format) 등이 있지만, 널리 사용되지는 않는다. ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:3:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"4. SVG - Scalable Vector Graphic SVG는 World Wide Web Consortium(W3C)에서 개발한 2차원 그래픽을 설명하기 위한 백터 기반의 확장 가능한 마크업 언어(XML)이다. SVG 파일 형식의 가장 큰 특징은 다른 파일 형식과 다르게 픽셀 형식을 사용하지 않는다는 것이다. 픽셀 형식을 사용하지 않아서, 이미지의 크기를 키우는 경우 이미지가 꺠져 흐릿하게 보이는 픽셀화가 일어나지 않는다. SVG 파일은 PNG 및 JPG에 비해 가장 선명한 품질의 그래픽을 제공하기 때문에 로고, 아이콘 및 간단한 일러스트레이션에 적합하다. ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:4:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["etc"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-08-17-various-image-types/ ","date":"2022-05-22","objectID":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/:5:0","tags":["JPG","PNG","GIF","SVG"],"title":"이미지 확장자","uri":"/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/"},{"categories":["system"],"content":"메시지 큐(Message Queue)는 프로세스 또는 프로그램 간에 데이터를 교환할 때 사용하는 통신 방법 중에 하나로, 메시지 지향 미들웨어(Message Oriented Middleware:MOM)를 구현한 시스템을 의미한다. 메시지 지향 미들웨어란 비동기 메시지를 사용하는 응용 프로그램들 사이에서 데이터를 송수신하는 것을 의미한다. 여기서 메시지란 요청, 응답, 오류 메시지 혹은 단순한 정보 등의 작은 데이터가 될 수 있다. 메시지 큐는 메시지를 임시로 저장하는 간단한 버퍼라고 생각하면 된다. 메시지를 전송 및 수신하기 위해 중간에 메시지 큐를 두는 것이다. 메시지 전송 시 생산자(Producer)로 취급되는 컴포넌트가 메시지를 메시지 큐에 추가한다. 해당 메시지는 소비자(Consumer)로 취급되는 또 다른 컴포넌트가 메시지를 검색하고 이를 사용해 어떤 작업을 수행할 때까지 메시지 큐에 저장된다. 각 메시지는 하나의 소비자에 의해 한 번만 처리될 수 있는데, 이러한 이유로 메시지 큐를 이용하는 방식을 일대일 통신이라고 부른다. 메시지 큐는 소비자(Consumer)가 실제로 메시지를 어느 시점에 가져가서 처리하는 지는 보장하지 않는다. 언젠가는 큐에 넣어둔 메시지가 소비되어 처리될 것이라고 믿는 것이다. 이러한 비동기적 특성 때문에 메시지 큐는 실패하면 치명적인 핵심 작업보다는 어플리케이션의 부가적인 기능에 사용하는 것이 적합하다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:0:0","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"메시지 큐를 사용하는 경우 ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:1:0","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"이메일 전송 어떤 웹 사이트의 비밀번호를 잊어버려서 이메일을 통해 임시 비밀번호를 받거나, 새로운 회원가입을 위한 인증 코드를 받아본 경험이 있을 것이다. 우리는 이러한 상황들에서 이메일이 즉각적으로 수신되기를 기대하지는 않는다. 아무리 성격이 급한 사람이라도 몇 분 안에 오겠거니 생각할 것이다. 어느 정도의 응답 지연이 허용되며, 어플리케이션의 핵심 기능은 아닌 경우이므로 메시지 큐는 이런 경우 도움이 될 수 있다. 비밀번호 재설정을 위해 이메일을 발급하는 서비스, 회원가입을 위해 이메일을 발급하는 서비스 등은 메시지(이메일)를 큐에 넣을 수 있다. 이메일 전송 전용 서비스는 이메일이 어느 서비스로부터 생산되었는지와는 관계없이, 메시지 큐의 메시지를 하나씩 소비하고, 그저 이메일이 전송되어야 할 곳으로 이메일을 전송한다. 이와 같은 접근 방식은 메시지 큐에 들어오는 메시지 수가 너무 많아지는 경우 이메일 전송 전용 서비스 인스턴스를 더 둠으로써 확장할 수 있으므로 확장성이 뛰어나다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:1:1","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"블로그 포스팅 모든 블로그 사용자가 웹에 최적화되어 있거나, 용량이 작은 이미지만 업로드하진 않을 것이다. 블로그 사용자가 게시글에 업로드한 이미지의 용량이 매우 큰 경우를 생각해보자. 블로그 서비스의 응답 시간을 저해하지 않으면서 사용자들에게 유연성을 제공하는 방법으로, 사용자가 업로드한 모든 이미지를 게시 과정에서 즉각 처리하는 것이 아닌, 사후처리하며 최적화하는 방법이 있다. 사용자 경험에 약간의 영향을 미칠 수는 있지만, 최적화는 응용 프로그램에서 가장 중요한 것은 아니며 작업을 즉시 수행할 필요도 없다. 메시지 큐는 이러한 상황에서도 사용될 수 있다. 사용자가 고용량의 이미지가 포함된 블로그 포스팅을 한다. 이미지는 저장소에 전송된다. 업로드된 이미지에 대한 정보가 포함된 메시지를 이미지 최적화 서비스의 메시지 큐에 담는다. 이미지 최적화 서비스는 저장소에서 이미지를 가져와 최적화하고, 2번에서 저장해놨던 이미지를 대체한다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:1:2","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"메시지 큐의 이점 ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:0","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"비동기(Asynchronous) 동기화 방식은 많은 메시지(데이터)가 전송될 경우 병목이 생길 수 있고, 뒤에 들어오는 요청에 대한 응답이 지연된다. 메시지 큐는 생산된 메시지의 저장, 전송에 대해 동기화 처리를 진행하지 않고, 큐에 넣어 두기 때문에 나중에 처리할 수 있다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:1","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"낮은 결합도(Decoupling) 생산자 서비스와 소비자 서비스가 독립적으로 행동하게 됨으로써 서비스 간 결합도가 낮아진다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:2","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"확장성(Scalable) 생산자 서비스 혹은 소비자 서비스를 원하는 대로 확장할 수 있기 때문에 확장성이 좋다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:3","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"탄력성(Resilience) 소비자 서비스가 다운되더라도 어플리케이션이 중단되는 것은 아니다. 메시지는 메시지 큐에 남아 있다. 소비자 서비스가 다시 시작될 때마다 추가 설정이나 작업을 수행하지 않고도 메시지 처리를 시작할 수 있다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:4","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"보장성(Guarantees) 메시지 큐는 큐에 보관되는 모든 메시지가 결국 소비자 서비스에게 전달된다는 일반적인 보장을 제공한다. ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:2:5","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["system"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-09-19-message-queue/ ","date":"2022-05-18","objectID":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/:3:0","tags":["message-queue"],"title":"메시지 큐","uri":"/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},{"categories":["java"],"content":"해싱 해싱은 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 찾아가는 검색 방식이다. 키값을 원소 위치로 변환하는 함수를 해시 함수(Hash Function)라 한다. 해시 함수에 의해 계산된 주소에 저장할 값을 저장한 표를 해시 테이블(Hash Table)이라 한다. 해시 테이블은 빠른 검색 속도를 제공하는데 이유는 내부적으로 버킷(배열)을 사용하여 데이터를 저장하기 때문이다. 해시 테이블은 각각의 key 값에 해시 함수를 적용해 배열의 고유한 인덱스를 생성한 후 인덱스를 이용해 값을 저장한다. 실제 값이 저장되는 장소를 버킷이라 한다. 어떤 수업을 듣는 10명의 학생에게 자리를 배정한다고 생각해보자. 이때 자리가 딱 10자리가 있고 10명의 학생은 각각 다른 이름을 가지고 있다. 그리고 좌석 번호를 생성하는 번호 생성기에 이름을 입력하면 좌석 번호가 나오게 된다. 이때 번호 생성기가 해시 함수의 역할을 한다. 그리고 좌석 번호와 학생 정보를 기록한 테이블은 해시 테이블이 된다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:1:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"해시 충돌 앞서 번호 생성기를 통하여 10명의 학생을 각각 자리에 앉혔다. 10명의 학생을 각각의 자리에 안내할 수 있었던 것은 사실 번호 생성기의 성능이 좋아 겹치지 않았다. 하지만 수업의 퀄리티가 좋아져 학생의 수가 갑자기 엄청나게 늘어났다. 기존의 번호 생성기는 0~20까지의 번호밖에 만들지 못했는데 학생의 수가 어느덧 30명이 되었다. 이제 필연적으로 겹치는 번호가 생성될 수밖에 없다. 그럼 이미 좌석 배정이 받은 학생이 있는 자리에 새로운 학생을 배정하게 되는데 이러한 경우가 해시 충돌 상황이다. 이러한 해시 충돌을 해결하는 방법에는 크게 두 가지 방법이 있다. Open Addressing Separate Chaining Open Addressing은 이미 자리에 누군가가 있으면 다른 곳으로 배정하는 방식이다. 다른 곳에 배정하는 방식에 따라 Linear Probing과 Quadratic Probing 등의 방법이 있다. Separate Chaining은 해시 테이블의 구조를 변경하여 하나 이상의 키값을 저장할 수 있도록 하는 방법이다. 이때 주로 사용하는 자료구조로 연결 리스트를 사용한다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:2:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"HashMap 에서의 Separate Chaining HashMap에서 사용하는 충돌기법 방식은 Separate Chaining이다. Java 8 이전에의 HashMap에서는 단순히 연결 리스트를 사용하였다. 하지만 Java 8 이후부터는 데이터의 개수가 많아지면 연결 리스트가 아닌 트리 자료구조를 사용한다. 정확히 말하자면 레드 블랙 트리 자료구조이다. 그렇다면 데이터의 개수가 많아진다는 기준점은 무엇일까? 하나의 해시 버킷에 8개의 키-값 쌍이 모이면 연결 리스트를 트리로 변경하게 된다. 또한 버킷의 데이터를 삭제하여 개수가 6개에 이르면 다시 연결 리스트로 변경한다. 그럼 왜 6과 7 또는 7과 8이 아닌 6과 8이 기준이겠냐는 의문이 생길 수 있다. 이유는 차이가 1일 경우 삽입/삭제가 반복되어 일어나면 불필요하게 트리와 연결 리스트로 변경하는 일이 발생하기 때문이다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:3:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"해시 버킷의 확장 버킷은 결국 배열로 구성되어 있다. 우리가 HashMap을 구현할 때 따로 버킷의 개수를 지정 해주지 않았다면 기본값인 16으로 버킷의 개수가 지정된다. 해시 버킷의 개수가 일정 개수 이상이 되면 버킷의 개수를 2배로 늘리게 된다. 버킷을 늘리면 해시 충돌의 가능성도 낮아져 해시 충돌로 인한 문제를 해결할 수도 있다. 하지만 두 배로 증가할 때마다 새로운 Separate Chaining을 구성해야 하는 문제가 있다. 가장 좋은 것은 버킷의 개수를 예측할 수 있다면 지정하여 HashMap을 생성하는 것이다. 따라서 데이터의 개수가 예측 가능하다면 지정하여 생성자의 인자로 넣어주면 불필요한 Separate Chaining을 줄일 수 있다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:4:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"Load Factor 버킷의 수를 두 배로 늘릴 때 해시 버킷의 개수는 어떻게 정할까? HashMap 클래스에 들어가 load factor 부분을 살펴보면 0.75f이라고 설정된 것을 볼 수 있다. 이 의미는 데이터의 개수가 현재 버킷 개수의 0.75 즉 3/4 이 되었을 때 두 배로 확장한다는 뜻이다. ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:4:1","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-05-hash-hashmap/ ","date":"2022-05-15","objectID":"/hash%EC%99%80-hashmap/:5:0","tags":["hash","hashmap"],"title":"Hash와 HashMap","uri":"/hash%EC%99%80-hashmap/"},{"categories":["system"],"content":"로드 밸런싱이란 서버가 처리해야 할 업무 혹은 요청(Load)을 여러 대의 서버로 나누어(Balancing) 처리하는 것을 의미한다. 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 하는 것이 목적이다. 서비스의 규모가 커지고, 이용자 수가 늘어나게 되면 기존의 서버만으로는 원활한 서비스 동작이 불가능하게 되고, 이에 대처할 수 있는 방법은 크게 두 가지로 나뉜다. 기존의 서버 성능을 확장하는 Scale-up 방식 기존의 서버와 동일하거나 낮은 성능의 서버를 증설하는 Scale-out 방식 이때 Scale-out 방식을 통해 증가한 트래픽에 대처하기로 했다면, 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드 밸런싱이 반드시 필요하다. ","date":"2022-05-12","objectID":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/:0:0","tags":["load-balancing"],"title":"로드밸런싱","uri":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/"},{"categories":["system"],"content":"로드 밸런싱 기법 로드 밸런싱 기법은 여러 가지가 있다. 서버의 능력을 고려하여 분배해야 하기 때문에 서버의 상황에 맞춰 적절한 방법을 선택해야 한다. 라운드로빈 방식(Round Robin Method) 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식이다. 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있고, 서버와의 연결(세션)이 오래 지속되지 않는 경우에 활용하기 적합하다. 가중 라운드로빈 방식(Weighted Round Robin Method) 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분한다. 주로 서버의 트래픽 처리 능력이 상이한 경우 사용되는 부하 분산 방식이다. 예를 들어 A라는 서버가 5라는 가중치를 갖고 B라는 서버가 2라는 가중치를 갖는다면, 로드 밸런서는 라운드로빈 방식으로 A 서버에 5개 B 서버에 2개의 요청을 전달한다. IP 해시 방식(IP Hash Method) 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식이다. 사용자의 IP를 해싱해(Hashing, 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 매핑하는 것, 또는 그러한 함수) 로드를 분배하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장한다. 최소 연결 방식(Least Connection Method) 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분한다. 자주 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합한 방식이다. 최소 응답 시간 방식(Least Response Time Method) 서버의 현재 연결 상태와 응답 시간(Response Time, 서버에 요청을 보내고 최초 응답을 받을 때까지 소요되는 시간)을 모두 고려하여 트래픽을 배분한다. 가장 적은 연결 상태와 가장 짧은 응답 시간을 보이는 서버에 우선적으로 로드를 배분하는 방식이다. ","date":"2022-05-12","objectID":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/:1:0","tags":["load-balancing"],"title":"로드밸런싱","uri":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/"},{"categories":["system"],"content":"L4 로드 밸런싱과 L7 로드 밸런싱 로드 밸런싱에는 L4 로드 밸런싱과 L7 로드 밸런싱이 가장 많이 활용된다. L4, L7은 각각 Layer 4(전송 계층) 프로토콜과 Layer 7(응용 계층) 프로토콜의 헤더를 부하 분산에 이용하기 때문에 붙은 접두사이다. 모든 요청을 L4 혹은 L7 로드 밸런서가 받아 서버들에게 적절히 나누어 준다. L4 로드 밸런서는 네트워크 계층(IP, IPX)이나 전송 계층(TCP, UDP)의 정보(IP주소, 포트번호, MAC주소, 전송 프로토콜)를 바탕으로 로드를 분산한다. L7 로드 밸런서는 애플리케이션 계층(HTTP, FTP, SMTP)에서 로드를 분산하기 때문에 HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능하다. 쉽게 말해 패킷의 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배하는 것이 가능한 것이다. URL에 따라 부하를 분산시키거나, HTTP 헤더의 쿠키 값에 따라 부하를 분산하는 등 클라이언트의 요청을 보다 세분화해 서버에 전달할 수 있다. L7 로드 밸런서의 경우 특정한 패턴을 지닌 바이러스를 감지해 네트워크를 보호할 수 있으며, DoS/DDoS와 같은 비정상적인 트래픽을 필터링할 수 있어 네트워크 보안 분야에서도 활용되고 있다. ","date":"2022-05-12","objectID":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/:2:0","tags":["load-balancing"],"title":"로드밸런싱","uri":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/"},{"categories":["system"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-07-load-balancing/ ","date":"2022-05-12","objectID":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/:3:0","tags":["load-balancing"],"title":"로드밸런싱","uri":"/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/"},{"categories":["DB"],"content":"낙관적 락 낙관적 락은 대부분의 경우 트랜젝션의 충돌이 일어나지 않는다는 낙관적 가정을 하는 기법이다. 낙관적 락은 데이터베이스 자체에서 제공하는 것이 아니라 JPA 즉 어플리케이션에서 제공하는 기능이다. 낙관적 락은 충돌을 가정하지 않기 때문에 커밋이 된 이후에 충돌 여부를 알 수 있다. ","date":"2022-05-08","objectID":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/:1:0","tags":["optimistic-lock","pessimistic-lock"],"title":"낙관적락, 비관적락","uri":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/"},{"categories":["DB"],"content":"JPA에서 낙관적 락 구현 JPA에서 낙관적 락을 사용하기 위해서는 엔티티 클래스에 @Version 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다. @Entity public class Member { @Id private Long id; private String name; @Version private Integer version; } @Version을 명시할때는 다음과 같은 주의사항이 있다. 각 엔티티 클래스에는 하나의 버전 속성 만 있어야 한다. 여러 테이블에 매핑 된 엔티티의 경우 기본 테이블에 배치되어야 한다. 버전에 명시할 타입은 int, Integer, long, Long, short, Short, java.sql.Timestamp 중 하나여야 한다. Note 만약 @Version을 명시한 변수의 타입이 자동으로 지원하는 타입이 아니라면 다음과 같은 오류가 발생한다. class org.hibernate.type.StringType cannot be cast to class org.hibernate.type.VersionType 이때 org.hibernate.type.VersionType를 상속받아 seed(초기값), next(증가하는 로직), getComparator(버전 비교 함수)을 구현하여주면 커스텀하게 버저닝 사용이 가능하다. JPA는 Select시에 트랜잭션 내부에 버전 속성의 값을 보유하고 트랜젝션이 업데이트를 하기 전에 버전 속성을 다시 확인한다. 그 동안에 버전 정보가 변경이 되면 OptimisticLockException이 발생하고 변경되지 않으면 트랜잭션은 버전속성을 증가하는 업데이트 하게 된다. ","date":"2022-05-08","objectID":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/:1:1","tags":["optimistic-lock","pessimistic-lock"],"title":"낙관적락, 비관적락","uri":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/"},{"categories":["DB"],"content":"낙관적 잠금의 LockModeType NONE 별도의 옵션을 사용하지 않아도 Entity에 @Version이 적용된 필드만 있으면 낙관적 잠금이 적용된다. Entity 수정시에 낙관적 잠금이 발생한다. OPTIMISTIC Entity 수정시에만 발생하는 낙관적 잠금이 읽기 시에도 발생하도록 설정한다. 읽기시에도 버전을 체크하고 트랜잭션이 종료될 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다. 이를 통해 dirty read와 non-repeatable read를 방지한다. OPTIMISTIC_FORCE_INCREMENT 낙관적 락을 사용하면서 버전 정보를 강제로 증가시킨다. 엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가시킨다. 이때 데이터베이스의 버전이 엔티티의 버전과 다르면 예외가 발생한다. 추가로 엔티티를 수정하면 수정시 버전 UPDATE 가 발생하여 총 2번의 버전 증가가 나타날 수 있다. 논리적인 단위의 엔티티 묶음을 관리할 수 있다. 예를 들어 게시물과 첨부파일이 일대다, 다대일의 양방향 연관관계이고 첨부파일이 연관관계의 주인일 때, 첨부파일 추가 시 게시물의 버전도 강제로 증가해야 할 때 사용할 수 있다. ","date":"2022-05-08","objectID":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/:1:2","tags":["optimistic-lock","pessimistic-lock"],"title":"낙관적락, 비관적락","uri":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/"},{"categories":["DB"],"content":"비관적 락 비관적 락은 대부분의 경우 트랜젝션에서 충돌이 발생할 것이라 가정하고, 일단 락을 걸고 보는 기법이다. 비관적 락은 데이터베이스의 락 알고리즘을 통해 구현되며, 데이터를 수정하는 즉시 트랜잭션 충돌을 감지한다. ","date":"2022-05-08","objectID":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/:2:0","tags":["optimistic-lock","pessimistic-lock"],"title":"낙관적락, 비관적락","uri":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/"},{"categories":["DB"],"content":"JPA에서 비관적 락 구현 public interface HomeRepository extends JpaRepository\u003cHome, Long\u003e { Home findByName(String name); @Lock(LockModeType.PESSIMISTIC_WRITE) @Query(\"select h from Home h where h.name = :name\") Home findWithNameForUpdate(@Param(\"name\") String name); } @Service @RequiredArgsConstructor @Slf4j public class HomeService { private final HomeRepository homeRepository; @Transactional public int currentPrice(String name) { Home home = homeRepository.findByName(name); return home.getPrice(); } @Transactional public int decreasePrice(String name, int price) { Home home = homeRepository.findWithNameForUpdate(name); home.decreasePrice(price); return home.getPrice(); } } Hibernate:selecthome0_.idxasidx1_0_,home0_.addressasaddress2_0_,home0_.nameasname3_0_,home0_.priceasprice4_0_fromhomehome0_wherehome0_.name=?forupdate ","date":"2022-05-08","objectID":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/:2:1","tags":["optimistic-lock","pessimistic-lock"],"title":"낙관적락, 비관적락","uri":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/"},{"categories":["DB"],"content":"비관적 잠금의 LockModeType PESSIMISTIC_READ shared lock을 얻을 수 있다. 데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용하며, 일반적으로 잘 사용하지 않는다. 데이터베이스 대부분은 방언에 의해 PESSIMISTIC_WRITE로 동작한다. PESSIMISTIC_WRITE exclusive lock을 얻을 수 있다. 데이터베이스에 쓰기 락을 걸 때 사용한다. ","date":"2022-05-08","objectID":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/:2:2","tags":["optimistic-lock","pessimistic-lock"],"title":"낙관적락, 비관적락","uri":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/"},{"categories":["DB"],"content":"참고 https://devjem.tistory.com/28 https://sup2is.github.io/2020/10/22/jpa-optimistic-lock-and-pessimistic-lock.html https://effectivesquid.tistory.com/entry/Optimistic-Lock%EA%B3%BC-Pessimistic-Lock ","date":"2022-05-08","objectID":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/:3:0","tags":["optimistic-lock","pessimistic-lock"],"title":"낙관적락, 비관적락","uri":"/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/"},{"categories":["spring"],"content":"Filter Filter(필터)는 요청과 응답을 거른 뒤 정제하는 역할을 한다. 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러 가지 체크를 수행할 수 있다. 또한 자원의 처리가 끝난 후 응답 내용에 대해서도 변경하는 처리를 할 수가 있다. 즉 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS 방어 등의 요청에 대한 처리로 사용된다. init(): 필터 인스턴스 초기화 doFilter(): 전/후 처리 destroy(): 필터 인스턴스 종료 ","date":"2022-05-07","objectID":"/filter-interceptor-aop/:1:0","tags":["filter","interceptor","aop"],"title":"Filter, Interceptor, AOP","uri":"/filter-interceptor-aop/"},{"categories":["spring"],"content":"Interceptor 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답을 처리한다. 스프링의 모든 빈 객체에 접근할 수 있다. 인터셉터는 여러 개를 사용할 수 있고 로그인 체크, 권한 체크, 프로그램 실행 시간 계산작업 로그 확인 등의 업무처리에 사용한다. preHandler(): 컨트롤러 메소드가 실행되기 전 postHanler(): 컨트롤러 메소드 실행직 후 view 페이지 렌더링 되기 전 afterCompletion(): view 페이지가 렌더링 되고 난 후 ","date":"2022-05-07","objectID":"/filter-interceptor-aop/:2:0","tags":["filter","interceptor","aop"],"title":"Filter, Interceptor, AOP","uri":"/filter-interceptor-aop/"},{"categories":["spring"],"content":"AOP AOP는 OOP를 보완하기 위해 나온 개념이다. 객체 지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다. 주로 ‘로깅’, ‘트랜잭션’, ‘에러 처리’ 등 비즈니스단의 메소드에서 조금 더 세밀하게 조정할 때 사용한다. Interceptor나 Filter와는 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다. Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야 하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다. @Before: 대상 메소드의 수행 전 @After: 대상 메소드의 수행 후 @After-returning: 대상 메소드의 정상적인 수행 후 @After-throwing: 예외발생 후 @Around: 대상 메소드의 수행 전, 후 ","date":"2022-05-07","objectID":"/filter-interceptor-aop/:3:0","tags":["filter","interceptor","aop"],"title":"Filter, Interceptor, AOP","uri":"/filter-interceptor-aop/"},{"categories":["spring"],"content":"참고 https://dejavuhyo.github.io/posts/spring-filter-interceptor-aop-differences/ ","date":"2022-05-07","objectID":"/filter-interceptor-aop/:4:0","tags":["filter","interceptor","aop"],"title":"Filter, Interceptor, AOP","uri":"/filter-interceptor-aop/"},{"categories":["web"],"content":"TCP Keep-Alive 두 종단 간의 연결을 유지하는 것이 목적이다. 연결된 TCP 소켓을 체크할 수 있고 TCP 연결이 여전히 진행중인지 혹은 끊어졌는지를 결정한다. TCP Keepalive는 연결된 세션의 재활용 측면에서만 아니라 좀비 커넥션의 삭제에도 도움을 준다. TCP 연결을 끊으려면 FIN 패킷이 필요하다. 하지만 다양한 이유로 FIN 패킷을 받을 수 없는 상황이 된다면 FIN을 전달할 수 없어 계속 연결된 것처럼 남아있게 된다. TCP Keepalive 옵션을 사용한다면 일정시간이 확인 패킷을 보내는 로직을 통해 일정시간 동안 응답이 없다면 연결을 종료하기 때문에 좀비 커넥션을 방지할 수 있다. ","date":"2022-05-06","objectID":"/keep-alive/:1:0","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"TCP Keep-Alive 파라미터 net.ipv4.tcp_keepalive_time keepalive 소켓의 유지시간 net.ipv4.tcp_keepalive_probes 패킷을 보낼 최대 전송 횟수 네트워크 패킷은 여러 사유로 인해 유실될 수 있으므로 재전송 매커니즘을 넣는다. net.ipv4.tcp_keepalive_intvl 재전송 패킷을 보내는 주기 ","date":"2022-05-06","objectID":"/keep-alive/:1:1","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"TCP Keep-Alive 동작 과정 최초로 세션이 연결된 다음 tcp_keepalive_time초 동안 기다린다. 그리고 확인 패킷을 보내게 된다. 확인 패킷에 대한 응답이 오지 않으면 tcp_keepalive_intvl 간격으로 tcp_keepalive_probes 만큼 패킷을 더 보낸다. tcp_keepalive_probes의 마지막 패킷에 대해서 응답이 오지 않으면 연결을 끊는다. ","date":"2022-05-06","objectID":"/keep-alive/:1:2","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"HTTP Keep-Alive 최대 얼마동안 연결을 유지하도록 하는게 목적이다. HTTP 응답 Header의 예는 다음과 같다. 아래 응답을 받고 10초가 되기 전에 또 요청 했다면 Keep-Alive: timeout=10, max=19가 포함된 응답을 받을 것이다. HTTP/1.1 200 OK Connection: Keep-Alive Content-Type: text/html; charset=UTF-8 Date: Thu, 15 Jan 2015 16:45:29 GMT Content-Length: 1845 Keep-Alive: timeout=10, max=20 ","date":"2022-05-06","objectID":"/keep-alive/:2:0","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"HTTP Keep-Alive 파라미터 2개의 Keep-Alive 파라미터는 콤파(,)분리되어 응답된다. timeout 연결의 유지를 위한 최소한의 시간(초). max 연결을 종료하기 전까지 보낼 수 있는 최대 요청 수. ","date":"2022-05-06","objectID":"/keep-alive/:2:1","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"HTTP Keep-Alive 장점 HTTP/1.1에서 Keep-Alive로 인한 장점은 다음과 같다. 3-way handshake로 인한 지연시간을 줄일 수 있다. CPU 사용량을 줄여준다 : 새로운 TCP 연결을 만들기 위해서는 CPU, 메모리 사용과 같은 많은 리소스가 필요하다. 연결된 커넥션을 재사용하기 때문에 리소스 사용을 줄여준다. ","date":"2022-05-06","objectID":"/keep-alive/:2:2","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"TCP Keep-Alive vs HTTP Keep-Alive HTTP Keep-Alive는 HTTP 프로토콜의 기능이다. Keep-Alive 기능을 구현하는 웹 서버는 마지막 HTTP 응답(해당 HTTP 요청이 있는 경우)을 보낸 이후 시간 범위에 대해 주기적으로(수신 HTTP 요청에 대해) 연결/소켓을 확인해야 한다. 구성된 연결 유지 시간(초)까지 HTTP 요청이 수신되지 않으면 웹 서버는 연결을 닫는다. 웹 서버에서 ‘닫기’를 수행한 후에는 더 이상의 HTTP 요청이 불가능하다. 반면 TCP Keep-Alive는 TCP 계층에서 OS에 의해 관리된다. 작은 패킷을 보내 TCP 연결을 열린 상태로 유지한다. 또한 패킷이 전송될 때 연결이 끊어지는 즉시 발신자에게 알림이 전송되도록 확인하는 역할을 한다. ","date":"2022-05-06","objectID":"/keep-alive/:3:0","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"참고 https://devidea.tistory.com/60 https://eminentstar.tistory.com/50?category=578513 https://stackoverflow.com/questions/9334401/http-keep-alive-and-tcp-keep-alive ","date":"2022-05-06","objectID":"/keep-alive/:4:0","tags":["keep-alive"],"title":"Keep-Alive","uri":"/keep-alive/"},{"categories":["web"],"content":"서버는 로그인하는 시점에 보통 내부적으로 사용자 세션을 생성하고 이를 식별할 수 있는 식별자(세션 키 - 자바 웹 애플리케이션에서는 jsessionid라는 이름을 가진다)를 사용자에 보내는 응답에 포함시킨다. 브라우저는 이를 쿠키 형태로 가지고 있게 되며, 이 세션 키가 서버 입장에서 사용자의 identity를 식별할 수 있는 식별자가 된다. 이 때 누군가가 이 세션 키를 가로채서 알게 되면 마치 그 사람인 척 하고 서버에 요청을 보내도 서버에서는 이게 진짜 사용자가 보냈는지 아닌지를 판단할 수 없다. 이것을 세션 하이재킹이라고 한다. ","date":"2022-05-02","objectID":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/:0:0","tags":["session-hijacking"],"title":"세션 하이재킹","uri":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/"},{"categories":["web"],"content":"세션 하이재킹 방법 세션 하이재킹을 하는 방법에는 크게 4가지가 있다. 보안이 취약한 네트워크를 통해 전송되는 쿠키를 패킷 스니퍼를 사용하여 알아낸다. 예를 들어 해커가 악의적인 목적으로 Wi-Fi AP를 공개하고, 여기에 접속한 사람들이 보내는 패킷을 스니핑할 수 있다. 세션 키를 데이터베이스 등의 저장소를 이용하여 저장하는 경우, 데이터베이스에 몰래 접속하여 정보를 빼낼 수 있다. XSS를 사용한다. 사용자의 PC에 물리적으로 접속한다. ","date":"2022-05-02","objectID":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/:1:0","tags":["session-hijacking"],"title":"세션 하이재킹","uri":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/"},{"categories":["web"],"content":"세션 하이재킹 대응 여기에 대해 아래와 같이 대응할 수 있다. 패킷 스니핑 : 보통 HTTPS를 씌우면 쉽게 해결된다. 데이터베이스 탈취 : 세션 키를 단방향 암호화하여 저장한다. 그러면 데이터베이스가 털리더라도, 원래 세션 키를 알아낼 수는 없다. XSS : 모든 컨텐츠를 escaping 해준다. 사용자 PC 접속 : 한 방에 해결해 주는 방법은 없다. 대신 사용자가 로그아웃할 때 혹은 주기적으로 세션 키를 바꿔주어 위험을 최소화시킬 수 있다. ","date":"2022-05-02","objectID":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/:2:0","tags":["session-hijacking"],"title":"세션 하이재킹","uri":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/"},{"categories":["web"],"content":"참고 https://m.blog.naver.com/PostView.nhn?blogId=muchine98\u0026logNo=220354628727\u0026proxyReferer=https:%2F%2Fwww.google.co.kr%2F ","date":"2022-05-02","objectID":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/:3:0","tags":["session-hijacking"],"title":"세션 하이재킹","uri":"/%EC%84%B8%EC%85%98-%ED%95%98%EC%9D%B4%EC%9E%AC%ED%82%B9/"},{"categories":["web"],"content":"JWT 는 유저를 인증하고 식별하기 위한 토큰(Token)기반 인증이다. RFC 7519 에 자세한 명세가 나와있다. 토큰은 세션과는 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다. JWT 가 가지는 핵심적인 특징이 있다면, 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보가 포함(Self-contained)된다는 것이다. 데이터가 많아지면 토큰이 커질 수 있으며 토큰이 한 번 발급된 이후 사용자의 정보를 바꾸더라도 토큰을 재발급하지 않는 이상 반영되지 않는다. JWT 를 사용하면 RESTful 과 같은 무상태(Stateless)인 환경에서 사용자 데이터를 주고 받을 수 있게된다. 세션(Session)을 사용하게 될 경우에는 쿠키 등을 통해 식별하고 서버에 세션을 저장했지만 JWT 와 같은 토큰을 클라이언트에 저장하고 요청시 단순히 HTTP 헤더에 토큰을 첨부하는 것만으로도 단순하게 데이터를 요청하고 응답을 받아올 수 있다. ","date":"2022-04-30","objectID":"/jwt/:0:0","tags":["jwt"],"title":"JWT","uri":"/jwt/"},{"categories":["web"],"content":"JWT 동작순서 일반적으로 JWT를 사용하면 아래와 같은 순서로 진행된다. 클라이언트 사용자가 아이디, 패스워드를 통해 웹서비스 인증. 서버에서 서명된(Signed) JWT 를 생성하여 클라이언트에 응답으로 돌려주기. 클라이언트가 서버에 데이터를 추가적으로 요구할 때 JWT 를 HTTP Header 에 첨부. 서버에서 클라이언트로부터 온 JWT 를 검증. JWT는 JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화한 것이 포함되며 토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명도 있다. 따라서 사용자가 JWT 를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치게 되며 검증이 완료되면 요청한 응답을 돌려준다. Base64 URL-safe Encode Base64 URL-safe Encode는 일반적인 Base64 Encode 에서 URL 에서 오류없이 사용하도록 ‘+’, ‘/’ 를 각각 ‘-’, ‘_’ 로 표현한 것이다. ","date":"2022-04-30","objectID":"/jwt/:1:0","tags":["jwt"],"title":"JWT","uri":"/jwt/"},{"categories":["web"],"content":"구조 JWT 의 구조를 살펴보자. JWT는 Header, Payload, Signature 로 구성된다. 또한 각 요소는 . 으로 구분된다. Header에는 JWT 에서 사용할 타입과 해시 알고리즘의 종류가 담겨있으며 Payload에는 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨있다. 마지막으로 Signature 에는 Header, Payload 를 Base64 URL-safe Encode를 한 이후 Header에 명시된 해시함수를 적용하고, 개인키(Private Key)로 서명한 전자서명이 담겨있다. 전자서명 알고리즘으로 타원 곡선 암호화(ECDSA)를 사용한다고 가정하면, Sig = ECDSA(SHA256(B64(Header).B64(Payload)), PrivateKey) 전자서명도 Base64 URL-safe Encode로 처리해서 합쳐줄 필요가 있다. 여기서 만든 전자서명은 Header, Payload 가 변조되었는지 확인하기 위해 사용되는 중요 정보이며 JWT 를 신뢰할 수 있는 토큰으로 사용할 수 있는 근거가 된다. 전자서명에는 비대칭 암호화 알고리즘을 사용하므로 암호화를 위한 키와 복호화를 위한 키가 다르다. 암호화(전자서명)에는 개인키를, 복호화(검증)에는 공개키를 사용한다. 이를 JWT 로 표현하려면, 다음과 같다. JWT = B64(Header).B64(Payload).B64(Sig) ","date":"2022-04-30","objectID":"/jwt/:2:0","tags":["jwt"],"title":"JWT","uri":"/jwt/"},{"categories":["web"],"content":"참고 https://pronist.dev/143 ","date":"2022-04-30","objectID":"/jwt/:3:0","tags":["jwt"],"title":"JWT","uri":"/jwt/"},{"categories":["java"],"content":"스레드 모든 자바 어플리케이션은 Main Thread가 main() 메소드를 실행하면서 시작된다. Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 만들어 병렬로 코드를 실행할 수 있다. 싱글 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만, 멀티 스레드는 메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. 프로세스 내부에서의 멀티 스레드는 공유되는 자원이 있어 하나의 스레드에서 예외가 발생한다면 프로세스 자체가 종료될 수 있다. ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:1:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"Thread 생성 ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"Thread 클래스로부터 직접 생성 new를 통해 Thread 클래스 객체를 생성 후 start 메서드를 통해 다른 스레드에서 할 작업을 할당하는 방법이다. Thread객체를 생성할 때는 Runnable 인터페이스를 구현한 클래스 객체를 매개변수로 받는다. public class Task implements Runnable { @Override public void run() { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); } } public static void main(String args[]){ Runnable task = new Task(); Thread subTread1 = new Thread(task); Thread subTread2 = new Thread(task); subTread1.start(); subTread2.start(); } // 결과 (스레드가 끝나는 순서는 랜덥) 0 1 3 6 10 15 21 28 36 45 0 1 3 Thread[Thread-0,5,main]최종 합 : 45 6 10 15 21 28 36 45 Thread[Thread-1,5,main]최종 합 : 45 ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:1","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"익명 객체 생성 public static void main(String args[]){ Runnable task = new Runnable() { public void run() { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); } }; Thread subTread1 = new Thread(task); Thread subTread2 = new Thread(task); subTread1.start(); subTread2.start(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:2","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"람다식을 통해 익명 객체를 구현 public static void main(String args[]){ Runnable task = ()-\u003e { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); }; Thread subTread1 = new Thread(task); Thread subTread2 = new Thread(task); subTread1.start(); subTread2.start(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:3","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"Thread 하위 클래스로부터 생성 스레드가 실행할 작업을 Runable 구현클래스 대신 Thread를 상속한 새로운 클래스를 정의하여 run 메소드를 Overriding 하는 방법이다. 혹은 코드를 단순히 하기 위해 Thead 익명 객체로 작업 스레드 객체를 생성할 수 있다. // Thread클래스를 상속한 클래스 public class CustomThread extends Thread { @Override public void run() { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); } } public static void main(String args[]){ Thread subTread1 = new CustomThread(); // 익명 객체 생성 Thread subTread2 = new Thread() { public void run() { int sum = 0; for (int index = 0; index \u003c 10; index++) { sum += index; System.out.println(sum); } System.out.println( Thread.currentThread() + \"최종 합 : \" + sum); } }; subTread1.start(); subTread2.start(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:2:4","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"동기화 메소드 또는 동기화 블록 멀티스레드 환경에서의 문제는 스레드들이 객체를 공유하며 작업하는 경우가 생기기 때문에 A스레드와 B스레드가 공유하는 객체가 서로의 작업에 영향을 미치면 안 된다. 동기화 메소드와 동기화 블록 방법은 스레드가 사용 중인 객체를 Lock을 걸어 해당 작업을 진행하는 Thread가 작업을 마칠 때까지 다른 쓰레드가 작업을 하지 못하게 하는 방법이다. // 동기화 메소드 public synchronized void setValue( int value ) { this.value = value; try { Thread.sleep(2000); } catch (Exception e) { } System.out.println(Thread.currentThread().getName() + \"의 Value 값은 \" + this.value +\"입니다.\"); } // 동기화 블록 public void setValue( int value ) { synchronized ( this ) { this.value = value; try { Thread.sleep(2000); } catch (Exception e) { } System.out.println(Thread.currentThread().getName() + \"의 Value 값은 \" + this.value +\"입니다.\"); } } 하지만 Synchronized 키워드를 너무 남발하면 오히려 프로그램 성능저하를 일으킬 수 있기 때문에 적재적소에 잘 사용해야 한다. ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:3:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"스레드풀 ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"스레드풀 생성 스레드가 기하급수적으로 늘어난다면 스레드 생성과 스케줄링으로 인해 CPU의 메모리 사용량이 늘어나고 어플리케이션의 성능의 저하가 일어난다. 병렬작업의 급증을 막기 위해서는 특정 스레드 개수만큼 작업 컨베이어 벨트 (작업 큐)를 만들어 놓고 작업을 컨베이어 벨트에 올려놓아 작업이 끝난 스레드가 컨베이어에서 작업을 꺼내 기능을 수행하는 방식으로 작업을 구성할 수 있다. 아무리 작업 처리 요청이 폭주하여도 스레드의 전체 개수가 늘어나지 않기 때문에 어플리케이션의 성능이 급격하게 저하되지 않는다. 자바는 스레드 풀을 생성하고 사용할 수 있도록 java.util.concurrent.ExecutorService 인터페이스와 Executors 클래스 메소드 중 newCachedThreadPool과 newFixedThreadPool 메소드를 제공하고 있다. // 스레드 풀 생성 //1. 자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newCachedThreadPool(); //2. 원하는 개수만큼 생성 ExecutorService executorServiceWithNum = Executors.newFixedThreadPool(2); //3. 최대치로 생성 ExecutorService executorServiceWithMax = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); //4. 완전 수동 // ThreadPoolExecutor( 코어 스레드 수, 최대 스레드 개수, 놀고 있는 시간, 놀고있는 시간 단위, 작업 큐 ) ExecutorService executorServiceWithCustom = new ThreadPoolExecutor(3, 100, 120L, TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e()); ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:1","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"스레드풀 종료 스레드풀의 스레드는 데몬스레드가 아니므로 main이 종료되더라도 작업을 처리하기 위해 계속 실행상태로 남아있다. 때문에 어플리케이션을 종료할 때는 해당 스레드풀을 종료시켜 스레드풀 안의 스레드를 종료상태가 되도록 처리해야 한다. // 1. 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료한다. executorServiceWithCached.shutdown(); // 2. 당장 중지한다. 리턴값은 작업큐에 남아있는 작업의 목록이다. List\u003cRunnable\u003e runable = executorServiceWithCached.shutdownNow(); // 3. 작업은 대기 하지만 모든 작업처리를 특정 시간안에 하지 못하면 작업중인 스레드를 중지하고 false를 리턴한다. 아래는 100초 설정 try { boolean isFinish = executorServiceWithCached.awaitTermination(100, TimeUnit.SECONDS); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:2","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"작업의 생성 Runable 또는 Callable 구현 클래스로 작업을 생성한다. 둘의 차이는 작업이 끝난 후 리턴 값이 있냐 없느냐다. // Runable 구현 객체 (익명객체 사용) Runnable task1 = ()-\u003e { for (int index = 0; index \u003c 10; index++) { System.out.println(\"작업 중입니다.\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } }; // Callable 구현 Callable\u003cBoolean\u003e task2 = () -\u003e{ Boolean isFinish = true; for (int index = 0; index \u003c 10; index++) { System.out.println(\"작업 중입니다. Call\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } return isFinish; }; ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:3","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"작업처리 요청 task를 컨베이어 벨트에 올리는 작업이다. 즉 작업큐에 위 task객체를 넣는 것이다. // 1. 리턴 값이 없는 단순 Runnable를 처리 executorServiceWithCached.execute(task1); // 2. 리턴 가능한 Callable도 넣을 수 있는 메서드 Future\u003cBoolean\u003e returnBoolean = executorServiceWithCached.submit(task2); try { System.out.println(\"종료 : \" + returnBoolean.get()); //작업 반환을 기다려 얻어온다. } catch (Exception e) { } execute와 submit의 차이는 return을 받느냐 못 받느냐의 차이이다. 추가로 execute()는 작업 도중 오류 발생 시 오류가 난 스레드를 스레드풀에서 제거하지만 submit()은 오류가 발생하여도 해당 스레드를 재사용한다. ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:4","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"작업완료 통보 submit()은 task 작업을 작업큐에 넣고 바로 Futrue객체를 리턴한다. 해당 객체의 get()메서드를 호출하면 호출한 순간부터 스레드가 작업을 완료할 때까지 대기하고 있다가 완료된 후 결과를 받아온다. public static void main(String args[]){ // 스레드 풀 생성 //자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newCachedThreadPool(); // Runable 구현 객체 ( 익명구현객체 사용 ) Runnable task1 = ()-\u003e { for (int index = 0; index \u003c 100; index++) { System.out.println(\"작업 중입니다.\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } }; // Callable 구현 Callable\u003cBoolean\u003e task2 = () -\u003e{ Boolean isFinish = true; for (int index = 0; index \u003c 100; index++) { System.out.println(\"작업 중입니다. Call\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } return isFinish; }; // 1. 리턴 값이 없는 단순 Runnable를 처리 executorServiceWithCached.execute(task1); // 2. 리턴 가능한 Callable도 넣을 수 있는 메서드. Future\u003cBoolean\u003e returnBoolean = executorServiceWithCached.submit(task2); // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성 executorServiceWithCached.execute(()-\u003e{ try { if( returnBoolean.get() ) { System.out.println(\"작업이 완벽히 끝났습니다. \"); } else { System.out.println(\"작업이 끝나지 못했습니다.\"); } } catch (Exception e) { } }); // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성 executorServiceWithCached.execute(()-\u003e{ try { // 만약 특정 시간 내에 끝났는지 확인하려는 경우 if( returnBoolean.get(1,TimeUnit.SECONDS) ) { System.out.println(\"작업이 완벽히 끝났습니다. \"); } } catch (Exception e) { System.out.println(\"작업이 시간내에 끝나지 못했습니다.\"); } }); // 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료 executorServiceWithCached.shutdown(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:5","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"작업처리 결과를 외부 객체에 저장 public class FirstThread implements Runnable { ResultShare resultShare; //공유객체 외부에서 주입 public FirstThread ( ResultShare resultShare ) { this.resultShare = resultShare; } @Override public void run() { int result = 0; for (int index = 1; index \u003c= 100; index++) { result += index; try { Thread.sleep(10); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } System.out.println(\"1~100까지의 합은 \" + result +\"입니다.\"); resultShare.sum(result); resultShare.showSum(); } } public class SecondThread implements Runnable { ResultShare resultShare; //공유객체 외부에서 주입 public SecondThread ( ResultShare resultShare ) { this.resultShare = resultShare; } @Override public void run() { int result = 0; for (int index = 101; index \u003c= 200; index++) { result += index; } System.out.println(\"101~200까지의 합은 \" + result +\"입니다.\"); resultShare.sum(result); resultShare.showSum(); } } public class ResultShare { private int result; public int sum( int number ) { return result+=number; } public void showSum() { System.out.println(\" 지금 저장된 값은 : \" + result + \"입니다.\"); } public int getResult() { return result; } } public static void main(String args[]){ // 스레드 풀 생성 //자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newCachedThreadPool(); ResultShare resultShare = new ResultShare(); Runnable task1 = new FirstThread(resultShare); Runnable task2 = new SecondThread(resultShare); // Runable이라도 작업이 끝난 후 Future\u003c리턴 객체\u003e로 무엇을 받을 지 임의로 정할 수 있다. run()의 리턴값으로 아무 값이 없더라도 종료 후에 아무 원하는 객체를 이런 식으로 리턴할 수 있다. Future\u003cResultShare\u003e future1 = executorServiceWithCached.submit( task1, resultShare ); Future\u003cResultShare\u003e future2 = executorServiceWithCached.submit( task2, resultShare ); // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성 executorServiceWithCached.execute(()-\u003e{ try { ResultShare temp = future1.get(); temp = future2.get(); System.out.println(\"쓰레드 합산이 끝났습니다. 최종 결과는 : \" + resultShare.getResult()); } catch (Exception e) { } }); // 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료한다. executorServiceWithCached.shutdown(); } // 실행 결과 101~200까지의 합은 15050입니다. 지금 저장된 값은 : 15050입니다. 1~100까지의 합은 5050입니다. 지금 저장된 값은 : 20100입니다. 쓰레드 합산이 끝났습니다. 최종 결과는 : 20100 ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:6","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"작업 완료 순으로 통보 일반적으로 작업 순서대로 처리가 완료되는 것이 아니기 때문에 끝나는 것은 랜덤이다. 여러 개의 작업이 차례대로 처리될 필요가 없고 처리 결과도 차례대로 이용할 필요가 없다면 CompletionService 인터페이스를 구현한 ExecutorCompletionService 클래스를 사용하면 된다. public static void main(String args[]){ // 스레드 풀 생성 //자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); ResultShare resultShare = new ResultShare(); Runnable task1 = new FirstThread(resultShare); Runnable task2 = new SecondThread(resultShare); Future\u003cResultShare\u003e future1 = executorServiceWithCached.submit( task1, resultShare ); Future\u003cResultShare\u003e future2 = executorServiceWithCached.submit( task2, resultShare ); // 각각의 테스트들의 리턴 결과의 객체를 \u003cResultShare\u003e 안에 입력 CompletionService\u003cResultShare\u003e compliCompletionService = new ExecutorCompletionService\u003cResultShare\u003e(executorServiceWithCached); executorServiceWithCached.submit(()-\u003e{ // 작업 최종 통보가 올때까지 while 문을 통해 대기 while(true) { try { // 작업이 끝난 결과를 받아온다. Future\u003cResultShare\u003e take = compliCompletionService.take(); ResultShare result = take.get(); System.out.println(\"지금 까지의 합산은 \" + result.getResult() + \"입니다.\"); } catch ( Exception e) { break; } } }); // 3초 뒤 스레드 강제 중지 try { Thread.sleep(3000); executorServiceWithCached.shutdownNow(); } catch (InterruptedException e) { } } // 결과 101~200까지의 합은 15050입니다. 지금 저장된 값은 : 15050입니다. 1~100까지의 합은 5050입니다. 지금 저장된 값은 : 20100입니다. ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:7","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"콜백 방식의 통보 public class ResultShare { private int result; //\u003c결과 타입, 첨부타입\u003e private static CompletionHandler\u003cResultShare, String\u003e completionHandler = new CompletionHandler\u003cResultShare, String\u003e() { //실패 시 할 일 @Override public void failed(Throwable exc, String attachment) { System.out.println(\"실패하였습니다.\"); } //성공 시 할 일 @Override public void completed(ResultShare result, String attachment) { System.out.println(\"지금까지의 저장된 합은 \" + result.getResult() + \"입니다.\"); } }; public int sum( int number ) { return result+=number; } public void showSum() { System.out.println(\" 지금 저장된 값은 : \" + result + \"입니다.\"); } public int getResult() { return result; } public static CompletionHandler\u003cResultShare, String\u003e getCompletionHandler() { return completionHandler; } } public class FirstThread implements Runnable { ResultShare resultShare; //공유객체 외부에서 주입. public FirstThread ( ResultShare resultShare ) { this.resultShare = resultShare; } @Override public void run() { int result = 0; for (int index = 1; index \u003c= 100; index++) { result += index; } System.out.println(\"1~100까지의 합은 \" + result +\"입니다.\"); resultShare.sum(result); // 끝난 후 성공 콜백 실행 resultShare.getCompletionHandler().completed(resultShare, null); } } public class SecondThread implements Runnable { ResultShare resultShare; //공유객체 외부에서 주입. public SecondThread ( ResultShare resultShare ) { this.resultShare = resultShare; } @Override public void run() { int result = 0; for (int index = 101; index \u003c= 200; index++) { result += index; } System.out.println(\"101~200까지의 합은 \" + result +\"입니다.\"); resultShare.sum(result); // 끝난 후 콜백 실행 resultShare.getCompletionHandler().completed(resultShare, null); } } public static void main(String args[]){ // 스레드 풀 생성 //자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); ResultShare resultShare = new ResultShare(); Runnable task1 = new FirstThread(resultShare); Runnable task2 = new SecondThread(resultShare); Future\u003cResultShare\u003e future1 = executorServiceWithCached.submit( task1, resultShare ); Future\u003cResultShare\u003e future2 = executorServiceWithCached.submit( task2, resultShare ); executorServiceWithCached.shutdown(); } ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:4:8","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["java"],"content":"참고 https://honbabzone.com/java/java-thread/ ","date":"2022-04-22","objectID":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/:5:0","tags":["thread"],"title":"Java 스레드","uri":"/java-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"categories":["web"],"content":"3-Way Handshake 3-Way Handshake는 TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정이다. 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다. 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다. ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:1:0","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"작동 방식 Step 1 (SYN) 클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다. (seq : x) 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다. PORT 상태 Client : CLOSED- SYN_SENT 로 변함 Server : LISTEN Step 2 (SYN + ACK) 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (seq : y, ACK : x + 1) 접속요청을 받은 Q가 요청을 수락했으며, 접속 요청 프로세스인 P도 포트를 열어달라는 메세지를 전송 (SYN-ACK signal bits set) ACK Number필드를 Sequence Number + 1 로 지정하고 SYN과 ACK 플래그 비트를 1로 설정한 새그먼트 전송 (Seq=y, Ack=x+1, SYN, ACK) PORT 상태 Client : CLOSED Server : SYN_RCV Step 3 (ACK) 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보낸다. 마지막으로 접속 요청 프로세스 P가 수락 확인을 보내 연결을 맺는다. (ACK) 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다. PORT 상태 Client : ESTABLISED Server : SYN_RCV ⇒ ACK ⇒ ESTABLISED ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:1:1","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"4-Way Handshake 4-Way Handshake은 연결을 해제(Connecntion Termination)하는 과정이다. ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:2:0","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"작동방식 (Abrupt) RST(TCP reset) 세그먼트가 전송되면 갑작스러운 연결 해제가 수행되는데, RST 세그먼트는 다음과 같은 경우에 전송된다. 존재하지 않는 TCP 연결에 대해 비SYN 세그먼트가 수신된 경우 열린 커넥션에서 일부 TCP 구현은 잘못된 헤더가 있는 세그먼트가 수신된 경우 RST 세그먼트를 보내, 해당 커넥션을 닫아 공격을 방지한다. 일부 구현에서 기존 TCP 연결을 종료해야 하는 경우 연결을 지원하는 리소스 부족할때 원격 호스트에 연결할 수 없고 응답이 중지되었을때 ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:2:1","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"작동방식 (Graceful) Half-Close 기법 위 그림에서 처음 보내는 종료 요청인 (1) FIN 패킷에 실질적으로 ACK가 포함되어 있는 것을 알 수 있는데, 이는 Half-Close 기법을 사용하기 때문이다. 즉, 연결을 종료하려고 할 때 완전히 종료하지 않고 반만 종료한다. Half-Close 기법을 사용하면 종료 요청자가 처음 보내는 FIN 패킷에 승인 번호를 함께 담아서 보내게 되는데, 이때 승인 번호의 의미는 “일단 연결은 종료할건데 귀는 열어둘게. 이 승인 번호까지 처리했으니까 더 보낼 거 있으면 보내\"가 된다. 이후 수신자가 남은 데이터를 모두 보내고 나면 다시 요청자에게 FIN 패킷을 보냄으로써 모든 데이터가 처리되었다는 신호 FIN를 보낸다. 그럼 요청자는 그때 나머지 반을 닫으면서 좀 더 안전하게 연결을 종료할 수 있다. STEP1 (Client → Server : FIN(+ACK) 서버와 클라이언트가 연결된 상태에서 클라이언트가 close()를 호출하여 접속을 끊는다(끊으려한다). 이때, 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다. 이때 FIN 패킷에는 실질적으로 ACK도 포함되어있다. STEP2 (Server → Client : ACK) 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보내고 자신의 통신이 끝날때까지 기다린다. (이상태가 TIME_WAIT 상태) Server(수신자)는 ACK Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다. 서버는 클라이언트에게 응답을 보내고 CLOSE_WAIT 상태에 들어갑니다. 그리고아직 남은 데이터가 있다면 마저 전송을 마친 후에 close( )를 호출 클라이언트에서는 서버에서 ACK를 받은 후에 서버가 남은 데이터 처리를 끝내고 FIN 패킷을 보낼 때까지 기다린다. (FIN_WAIT_2) STEP3 (Server → Client : FIN) 데이터를 모두 보냈다면, 서버는 연결이 종료에 합의 한다는 의미로 FIN 패킷을 클라이언트에게 보낸 후에, 승인 번호를 보내줄 때까지 기다니는 LAST_ACK 상태로 들어간다. STEP4 (Client → Server : ACK) 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다. (실질적인 종료과정 CLOSED에 들어간다.) 이때 TIME_WAIT 상태는 의도치 않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지 만약 에러로 인해 종료가 지연되다가 타임이 초과되면 CLOSED로 들어간다. ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:2:2","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["web"],"content":"참고 https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3-Way-Handshake4-Way-Handshake ","date":"2022-04-19","objectID":"/3-way-handshake-4-way-handshake/:3:0","tags":["3-way-handshake","4-way-handshake"],"title":"3 way handshake, 4 way handshake","uri":"/3-way-handshake-4-way-handshake/"},{"categories":["system"],"content":"인코딩(encoding)은 파일에 저장된 정보의 형태나 형식을 데이터 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해서 다른 형태로 변환하는 처리 혹은 그 처리 방식을 말한다. 이메일 등의 전송, 동영상이나 이미지 영역에서 많이 사용되며, 반대말은 디코딩(decoding)이다. Base64를 글자 그대로 직역하면 64진법이라는 뜻이다. 컴퓨터 분야에서 쓰이는 Base 64(베이스 육십사)란 8비트 이진 데이터(예를 들어 실행 파일이나, ZIP 파일 등)를 문자 코드에 영향을 받지 않는 공통 ASCII 영역의 문자들로만 이루어진 일련의 문자열로 바꾸는 인코딩 방식을 가리키는 개념이다. 기존 ASCII 코드는 시스템간 데이터를 전달하기에 안전하지 않다. 모든 Binary 데이터가 ASCII 코드에 포함되지 않으므로 제대로 읽지 못한다. 반면 Base64는 ASCII 중 제어문자와 일부 특수문자를 제외한 안전한 출력 문자만 이용하므로 데이터 전달에 더 적합하다. Base64는 어떤 문자와 기호를 쓰느냐에 따라 다양한 변종이 있지만, 대부분 처음 62개는 알파벳 A-Z, a-z와 0-9를 사용하며 마지막 두 개를 어떤 기호를 쓰느냐의 차이만 있다. Base64 표준에서는 마지막 62, 63번 글자가 +, / 이다. 이 문자들을 전송하게 되면 정상적으로 전송되지 않는 문제가 발생한다. 따라서 이러한 원문의 오류를 막기 위해서 등장한것이 RFC 4648의 base64url이다. base64url에서는 62번, 63번 글자가 각각 -, _이다. ","date":"2022-04-17","objectID":"/base64-encoding/:0:0","tags":["base64","ascii"],"title":"Base64 Encoding","uri":"/base64-encoding/"},{"categories":["system"],"content":"Base64 변환과정 base64 인코딩 과정은 먼저 24bit의 buffer를 생성하여 위쪽(MSB)부터 바이트 데이터를 넣은 뒤, 버퍼의 오른쪽부터 6bit 단위로 잘라 Base64 테이블의 ASCII 문자로 변환한다. 다시 말해, 원본 문자열\u003e ASCII binary\u003e 6bit로 cut\u003e base64 encodeing 순서가 된다. 예를 들어, Man이라는 세 글자 단어를 Base64로 인코딩한다면 Man \u003e 77 97 110 \u003e 01001101 01100001 01101110 \u003e TWFu로 변환이 된다. ","date":"2022-04-17","objectID":"/base64-encoding/:1:0","tags":["base64","ascii"],"title":"Base64 Encoding","uri":"/base64-encoding/"},{"categories":["system"],"content":"Base64 사용 이유 Base64로 인코딩을 하게 되면 6bit당 2bit의 Overhead가 발생하여 전송해야 될 데이터의 크기가 약 33% 정도 늘어난다. 33%나 데이터의 크기가 증가하고, 인코딩과 디코딩의 추가 연산까지 필요한데 Base64 인코딩을 사용하는 이유는 통신과정에서 바이너리 데이터의 손실을 막기 위함이다. 플랫폼 독립적으로 Binary Data(이미지나 오디오)를 전송할 필요가 있을 때, ASCII로 Encoding 하여 전송하게 되면 여러 가지 문제가 발생할 수 있다. 대표적인 문제는 다음과 같다. ASCII는 7 bits Encoding인데 나머지 1bit를 처리하는 방식이 시스템 별로 상이하다. 일부 제어 문자 (e.g. Line ending)의 경우 시스템 별로 다른 코드값을 가진다. 위와 같은 문제로 ASCII는 시스템 간 데이터를 전달하기에 안전하지 않다. Base64는 ASCII 중 제어 문자와 일부 특수문자를 제외한 64개의 안전한 출력 문자만 사용한다. (* 안전한 출력 문자란 문자 코드에 영향을 받지 않는 공통 ASCII를 의미) 즉, Base64는 HTML 또는 Email과 같이 문자를 위한 Media에 Binary Data를 포함해야 될 필요가 있을 때, 포함된 Binary Data가 시스템 독립적으로 동일하게 전송 또는 저장되는 걸 보장하기 위해 사용한다. ","date":"2022-04-17","objectID":"/base64-encoding/:2:0","tags":["base64","ascii"],"title":"Base64 Encoding","uri":"/base64-encoding/"},{"categories":["system"],"content":"참고 https://devuna.tistory.com/41 ","date":"2022-04-17","objectID":"/base64-encoding/:3:0","tags":["base64","ascii"],"title":"Base64 Encoding","uri":"/base64-encoding/"},{"categories":["web"],"content":"HTTP와 HTTPS의 가장 큰 차이점은 SSL 인증서이다. SSL인증서는 클라이언트와 서버간의 통신을 공인된 제 3차 업체(CA)가 보증해주는 전자화된 문서이다. SSL 인증서는 사용자가 사이트에서 제공하는 정보를 암호화한다. 암호화되어 전송되는 데이터는 중간에 누가 훔치거나 조작하려해도 암호화 되어있어서 해독할 수 없다. HTTPS 방식은 공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 함께 사용한다. 데이터를 대칭키 방식으로 암복호화하고, 공개키 방식으로 대칭키를 전달한다. ","date":"2022-04-15","objectID":"/https/:0:0","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"HTTPS의 동작과정 ","date":"2022-04-15","objectID":"/https/:1:0","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색 Client Hello : 클라이언트가 서버에게 전송할 데이터 클라이언트 측에서 생성한 랜덤 데이터 클라이언트가 사용할 수 있는 암호화 방식 이전에 이미 Handshaking 기록이 있다면 자원 절약을 위해 기존 세션을 재활용하기 위한 세션 아이디 Server Hello : Client Hello에 대한 응답으로 전송할 데이터 서버 측에서 생성한 랜덤 데이터 서버가 선택한 클라이언트의 암호화 방식 SSL 인증서 Client 인증 확인 서버로부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인하고, 목록에 있다면 CA 공개키로 인증서 복호화 클라이언트, 서버 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭키 암호화에 사용할 키) pre master secret 값을 공개키 방식으로 서버 전달(공개키는 서버로부터 받은 인증서에 포함) Server 인증 확인 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료) Handshaking 종료 ","date":"2022-04-15","objectID":"/https/:1:1","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"데이터 전송 서버와 클라이언트는 session key를 활용해 데이터를 암복호화하여 데이터 송수신 ","date":"2022-04-15","objectID":"/https/:1:2","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"연결 종료 및 session key 폐기 ","date":"2022-04-15","objectID":"/https/:1:3","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["web"],"content":"참고 https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP%EC%99%80-HTTPS-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95 ","date":"2022-04-15","objectID":"/https/:2:0","tags":["https"],"title":"HTTPS","uri":"/https/"},{"categories":["system"],"content":"VM vs 컨테이너 ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:1:0","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["system"],"content":"VM 하드웨어 인프라스트러처 위에 VMWare나 VirtualBox와 같은 HyperVisor 소프트웨어를 이용해서 각각의 가상의 머신을 만들 수 있다. 한 운영체제 위에서 동일한 어플리케이션을 각각의 고립된 다른 환경에서 구동하기 위해서는 가상 머신을 이용해서 어플리케이션을 구동해야 했다. 이 가상 머신은 각각의운영체제를 포함하고 있기 때문에 맥이라는 OS 위에서 가상머신을 이용하면 윈도와 리눅스를 동시에 구동할 수 있다. 고립된 환경에서 애플리케이션을 구동하기 위해서 VM을 사용하면 운영 체제를 포함하고 있기 때문에 굉장히 무겁고 그리고 시작하는 데도 오래 걸리고 또 컴퓨터 운영체제 인프라스트럭처 리소스를 많이 잡아먹는 범인이 될 수도 있다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:1:1","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["system"],"content":"컨테이너 VM에서 조금 경량화된 컨셉이 컨테이너이다. 하드웨어에 설치된 운영체제 즉 호스트 OS에서 컨테이너 엔진이라는 소프트웨어를 설치만 하면 개별적인 컨테이너를 만들어서 이 각각의 어플리케이션을 고립된 환경에서 구동할 수 있게 해준다. 가상 머신은 운영체제를 포함했다면 이 컨테이너는 운영체제를 포함하지 않고 이 컨테이너 엔진의 설치된 호스트 OS를 공유한다. 컨테이너가 구동되기 위해서는 이 컨테이너 엔진이 필요하고 이 컨테이너 엔진이 호스트 OS에 접근해서 필요한 것들을 처리해 준다고 볼 수 있다. 그리고 이 컨테이너 엔진 중에 가장 많이 사랑받고 이용되는 것이 바로 도커이다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:1:2","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["system"],"content":"도커의 구성요소 ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:2:0","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["system"],"content":"도커파일 컨테이너를 만들기 위해서는 먼저 도커 파일을 만들어야 하고 이걸 이용해서 이미지를 만들어서 컨테이너를 구동할 수 있다. 도커 파일은 컨테이너를 어떻게 만들어야 하는지 설명서 또는 요리로 치면 레시피와 같다. 우리 어플리케이션을 구동하기 위해서 꼭 필요한 일들은 무엇이 있는지 어떤 프레임워크나 라이브러리를 설치해야 되는지 외부 의존성에 대해서 명시할 수 있다. 그리고 필요한 환경 변수에 대해서 설정할 수도 있고 어떻게 구동해야하는지 스크립트도 포함 할 수 있다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:2:1","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["system"],"content":"도커이미지 도커 파일을 이용해서 이미지를 만들 수 있다. 이 이미지 안에는 우리 어플리케이션을 실행하는 데 필요한 코드 런타임 환경 시스템, 툴 시스템, 라이브러리 모든 세팅들이 포함되어 있다. 한마디로 얘기하면 실행되고 있는 우리 어플리케이션의 상태를 캡쳐해서 이미지로 만들어 둔다 라고 생각할 수 있다. 이렇게 만들어진 이미지는 변경이 불가능하다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:2:2","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["system"],"content":"컨테이너 컨테이너는 샌드박스 처럼 우리가 잘 캡쳐해 둔 어플리케이션의 이미지를 고립된 환경에서 개별적인 그 파일 시스템 안에서 실행할 수 있는 것을 말한다. 각각의 컨테이너는 만들어진 인스턴스 라고 볼 수 있다. ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:2:3","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["system"],"content":"참고 https://youtu.be/LXJhA3VWXFA ","date":"2022-04-10","objectID":"/%EB%8F%84%EC%BB%A4/:3:0","tags":["VM","container","docker"],"title":"도커","uri":"/%EB%8F%84%EC%BB%A4/"},{"categories":["java"],"content":"랜카드 랜카드는 네트워크를 구성하기 위한 가장 기본적인 장비이다. 랜카드는 유저의 데이터를 케이블에 실어서 허브나 스위치, 혹은 라우터 등으로 전달해주고 자신에게 온 데이터를 CPU에게 전달해주는 역할을 한다. 랜카드라고 하면 ‘랜에 접속하기 위한 카드처럼 생긴 것이다’라고 생각하면 딱 맞다. 랜카드는 데스크톱, 노트북, 프린터 등 네트워크 연결이 필요한 장비에 꽂아서 사용한다. 요즘은 랜카드를 직접 보기 힘든데, 왜냐하면 랜카드는 대부분 컴퓨터 안에 설치되어 제작되기 때문이다. ","date":"2022-04-08","objectID":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/:1:0","tags":["lan-card","hub","switch","router"],"title":"랜카드, 허브, 스위치, 라우터","uri":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/"},{"categories":["java"],"content":"허브 허브(Hub)는 직사각형의 상자에 구멍이 뚫려 있는 모양으로 되어 있다. 랜카드가 설치된 각각의 PC들은 케이블을 타고 허브로 연결된다. 그리고 같은 허브에 연결된 PC 끼리는 서로 통신이 가능하다. 허브는 아무런 세팅이 없어도 통신에 지장이 없다. ","date":"2022-04-08","objectID":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/:2:0","tags":["lan-card","hub","switch","router"],"title":"랜카드, 허브, 스위치, 라우터","uri":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/"},{"categories":["java"],"content":"허브에서의 데이터 전송 예시 1번 PC가 데이터를 허브를 통해 전송하면, 허브는 데이터가 들어온 1번 포트를 제외하고 나머지 포트로 그 데이터를 보내준다. 3~5번 PC들의 랜카드는 들어온 프레임의 목적지 맥 어드레스를 자신의 맥 어드레스와 비교한 후 자신의 것이 아니라면 무시한다. 2번 PC의 랜카드는 들어온 프레임의 목적지 맥 어드레스가 자신의 것과 동일하기 때문에 받아들이고, CPU에게 이 데이터를 처리해 줄 것을 요청한다. ","date":"2022-04-08","objectID":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/:2:1","tags":["lan-card","hub","switch","router"],"title":"랜카드, 허브, 스위치, 라우터","uri":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/"},{"categories":["java"],"content":"스위치 PC들이 데이터를 동시에 보내려다 부딪히는 경우를 충돌(콜리전, Collision)이 발생했다고 한다. 허브에 연결된 PC들은 하나의 콜리전 도메인(Collision Domain)안에 있기 때문에 어느 한 순간에는 한 PC만 데이터를 보낼 수 있다. 콜리전 도메인이 너무 커지게 되면 콜리전에 의해 영향을 받는 PC가 너무 많아지면서 통신의 속도가 점점 떨어지게 된다. 스위치(Switch)는 콜리전 도메인을 작게 분할하여 데이터 전송 시 충돌 가능성을 낮춰주는 장비이다. 스위치는 예를 들어 1번 포트에 연결된 PC가 2번 포트에 연결된 PC와 데이터를 주고 받는 동안에도 3번 포트에 연결된 PC와 4번 포트에 연결된 PC가 서로 데이터를 주고받을 수 있게 한다. 이렇게 포트별로 콜리전 도메인을 나누기때문에, 통신이 일어나면 나머지 모든 PC들은 기다려야 하는 허브와 달리 다른 PC들도 동시 통신이 가능하며, 이것이 스위치와 허브의 가장 큰 차이이다. ","date":"2022-04-08","objectID":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/:3:0","tags":["lan-card","hub","switch","router"],"title":"랜카드, 허브, 스위치, 라우터","uri":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/"},{"categories":["java"],"content":"라우터 허브와 스위치로 장비가 연결되면, 소규모 네트워크 영역에서 통신할 수 있다. 그러면 대규모 네트워크에서 통신할 때는 라우터를 사용할 수 있다. 라우터는 서로 다른 네트워크를 연결해주고 데이터가 가장 빠르고 효율적인 길을 스스로 찾아 안내해주는 장비이다. 가정이나 소형오피스에서 사용하는 공유기도 소형 라우터이다. 인터넷은 여러 네트워크의 연결로 구성되어 있어서 목적지까지 가는 경로가 여럿 있을 수 있다. 라우터는 데이터 패킷이 목적지까지 갈 수 있는 여러 경로를 검사하고 어떤 길로 가는 것이 가장 적합한지를 결정하며, 이러한 행위를 라우팅이라고 한다. 라우터는 경로설정을 할 수 있도록 표 형태로 정보를 관리하는데, 이를 라우팅테이블이라고 한다. 이 테이블에는 목적지 IP주소에 대한 최적의 경로가 나와 있다. ","date":"2022-04-08","objectID":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/:4:0","tags":["lan-card","hub","switch","router"],"title":"랜카드, 허브, 스위치, 라우터","uri":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/"},{"categories":["java"],"content":"참고 개발자가 되기 위해 꼭 알아야 하는 IT 용어, 비제이리퍼블릭 ","date":"2022-04-08","objectID":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/:5:0","tags":["lan-card","hub","switch","router"],"title":"랜카드, 허브, 스위치, 라우터","uri":"/%EB%9E%9C%EC%B9%B4%EB%93%9C-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0/"},{"categories":["system"],"content":"Static Linking (정적 링킹) 정적 링킹이란 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하는 방식을 말한다. 5개의 프로그램에서 A라는 외부 함수를 이용하는데 이때 정적 링킹 방식을 사용하면 5개의 프로그램의 실행 가능한 목적파일 각각에 A의 정보가 담긴다. 즉, 중복이 발생한다. 따라서 정적 링킹으로 만들어진 프로그램은 크기가 크고 메모리 효율이 좋지 않다. 정적 링킹을 이용하면, 동적 링킹 라이브러리를 사용하는 프로그램보다 빠르다. 또한 정적 링킹 프로그램에서 모든 코드는 하나의 실행 모듈에 담기기 때문에 compatibility issues 즉, 불일치에 대한 걱정을 하지 않아도 된다. 그러나 함수에 변화가 생길 경우 그 변화를 적용하기 위해서 다시 컴파일하여 다시 링킹을 해야만 한다. ","date":"2022-04-08","objectID":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/:1:0","tags":["linking"],"title":"정적 링킹, 동적 링킹","uri":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/"},{"categories":["system"],"content":"Dynamic Linking (동적 링킹) 동적 링킹이란 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하지 않고 해당 모듈의 주소만을 가지고 있다가, 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것을 들고 오는 방식이다. 런타임에 운영체제에 의하여 이루어진다. 동적 링킹 방식을 이용하면 5개의 프로그램에서 A라는 외부 함수를 이용한다고 해도 함수의 정보는 하나만 있으면 된다. 즉, 메모리와 디스크 공간을 더 아낄 수 있다. 동적 링킹을 이용하면, A라는 함수에 변화가 생겨도 그 변화를 적용하기 위해 다시 컴파일하여 다시 링킹할 필요가 없다. 실행 가능한 목적파일을 만들 때 A에 관한 정보를 그냥 복사해온 것이 아니라 A가 있는 곳의 주소를 담았기 때문이다. 그저 가리키는 곳을 따라가면 변화된 A가 있다. 정적 링킹이 사용된 프로그램이 실행을 위해 메모리에 로드되는 데 일정한 시간이 걸리는 반면, 동적 링킹 방식이 사용된 프로그램은, 동적 라이브러리가 메모리에 이미 존재하는 경우 로드되는 시간을 단축시킬 수 있다. 하지만 동적 링킹 방식은 정적 링킹 방식보다 느리다. 매번 주소를 따라가야하는 오버헤드가 존재하기 때문이다. 동적 링킹 방식은 compatibility issues 즉, 불일치에 대한 문제를 고려해야 한다. 왜냐하면 동적 링킹 방식은 불일치가 존재할 수 있기 때문이다. 예를 들어 어떤 프로그램에서 A라는 함수를 동적 링킹 방식으로 사용하고 있을 때, A라는 함수가 시스템에서 제거되면 이는 불일치 상황이다. 해당 프로그램의 실행 가능 목적파일에는 A의 주소가 있어서 마치 A가 존재하는 것처럼 움직이지만 실제 A는 시스템에 더이상 존재하지 않기 때문이다. 따라서 이 프로그램은 제대로 실행될 수 없다. ","date":"2022-04-08","objectID":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/:2:0","tags":["linking"],"title":"정적 링킹, 동적 링킹","uri":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/"},{"categories":["system"],"content":"확장자별 라이브러리 구분 .a : 리눅스 / 정적 라이브러리 .so : 리눅스 / 동적 라이브러리 .lib : 윈도우 / 정적 라이브러리 .dll : 윈도우 / 동적 라이브러리 윈도우의 동적 라이브러리 DLL을 구현하고 컴파일하고 나면 Static library와는 다르게 output file이 2개가 생성된다. 하나는 *.lib 파일이고 하나는 *.dll 파일이다. Static library의 *.lib 파일은 라이브러리 전체 코드를 포함하는 바이너리이며, DLL의 *.lib 파일은 DLL이 제공하고자 하는 함수 정보(함수명)을 가지는 정보 파일이다. 링크 단계에서 실행 바이너리의 *.obj 파일들과 DLL의 *.lib 파일을 함께 링크하여 이 정보를 토대로 runtime에 DLL의 함수 코드를 참조한다. 이를 암시적 링킹(implicit linking)이라고 한다. 즉 *.lib 파일은 링크시 필요하고, *.dll 파일은 실행시 필요하다. ","date":"2022-04-08","objectID":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/:3:0","tags":["linking"],"title":"정적 링킹, 동적 링킹","uri":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/"},{"categories":["system"],"content":"참고 https://live-everyday.tistory.com/69 https://goodgid.github.io/Static-VS-Dynamic-Libray/ ","date":"2022-04-08","objectID":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/:4:0","tags":["linking"],"title":"정적 링킹, 동적 링킹","uri":"/%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9/"},{"categories":["DB"],"content":"트랜잭션은 데이터베이스 상태를 변환시키는 하나의 논리적 기능 수행 단위이다. 즉, 한 번에 처리되어야 할 일련의 작업을 말한다. 트랜잭션으로 원하는 작업의 단위를 정하게 되면 작업을 수행하는 도중 문제가 발생하였을 때 이전에 진행되었던 작업이 롤백된다. 모든 작업을 안정적으로 끝마친 후에 실제 데이터베이스에 반영할 수 있다. 트랜잭션의 범위는 커넥션 기준이다. 스프링 프레임워크의 트랜잭션 처리는 메소드 간에 커넥션 객체를 전달하지 않아도 한 트랜잭션으로 묶어서 실행하도록 돕는다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:0:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"트랜잭션의 성질 ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"Atomicity(원자성) 하나의 트랜잭션이 더 작게 나눌 수 없는 최소의 단위라는 뜻이다. 트랜잭션이 모두 반영되거나, 아니면 전혀 반영되지 않아야 하는 특징을 나타낸다. 계좌이체를 하는 경우를 생각해보자. 송금하는 도중에 문제가 발생하여 돈을 받아야 하는 사람에게 제대로 전달되지 않았다. 하지만 돈을 보내는 사람에게서는 이미 돈이 빠져나갔다면 큰 문제가 발생하게 될 것이다. 계좌이체 도중 문제가 발생하게 되면 송금하기 이전상태를 유지하게 되는 것을 원자성이라 볼 수 있다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:1","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"Consistency(일관성) 트랜잭션이 완료된 결과값이 일관적인 데이터베이스 상태를 유지하는 것을 말한다. 사실 이 말만으로는 잘 이해가 되지 않는다. 예를 들면, 고객 정보가 담겨있는 데이터베이스에 새로운 고객이 등록되면 그 데이터베이스를 참조하는 다른 하위 계층의 데이터베이스도 같은 고객의 세부 정보를 가져와야 한다. 또는 모든 계좌의 돈은 0원 이상이어야 한다. 라는 무결성 제약이 있다면 이를 위반하는 트랜잭션은 모두 중단되어야 한다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:2","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"Isolation(독립성) 트랜잭션이 수행되고 있을 때, 다른 트랜잭션의 연산작업이 중간에 끼어들어 기존 작업에 영향을 주지 못하도록 하는 것을 말한다. 독립성이 보장된다면 계좌 이체작업을 진행하고 있는 도중에 계좌의 잔액을 조회한다 거나 하는 작업을 동시에 수행할 수 없게 되는 것이다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:3","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"Durability(지속성) 트랜잭션을 성공한 후 데이터베이스에 반영된 것은 영원히 반영되어야 한다는 것을 의미한다. 시스템에 문제가 발생하거나 종료되더라도 데이터베이스에 반영된 값은 그대로 유지되어야 한다. 은행에 시스템이 마비되었다가 재개되었을 때 계좌의 금액이 바뀌게 된다면 큰 문제가 될 것이다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:1:4","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"트랜잭션 격리 수준 여러 클라이언트가 같은 데이터에 접근할 때 문제가 발생할 수 있다. 이러한 상황을 경쟁상태(Race Condition)라고 한다. 이 때 트랜잭션을 격리해서 다른 트랜재션이 영향을 주지 못하게 해야한다. Isolation Level 설명 Dirty Read Non-Repeatable Read Phantom Read 고립성(안정성) 동시성 Read Uncommitted 커밋되지 않은 데이터도 읽을 수 있다. O O O 낮다 높다 Read Committed 커밋된 정보만 읽는다. X O O 중간 중간 Repeatable Read 하나의 트랜잭션에서는 하나의 스냅샷만 사용한다. X X O 중간 중간 Serializable Read 시에 DML 작업이 동시에 진행될 수 없다. X X X 높다 낮다 ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"READ UNCOMMITTED 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.(Dirty Read) 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장한다. Dirty Read commit되지 않은 정보를 볼 수 있는 현상을 말하는 것으로 Read Uncommitted Isolation Level일 때 발생하는 Read 현상이다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:1","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"READ COMMITTED 커밋되지 않은 데이터 읽기 (dirty read), 커밋되지 않은 데이터 덮어쓰기 (dirty write) 문제를 해결한다. 커밋된 데이터만 읽기: 다른 트랜잭션이 쓰고 있으면 대기 했다가 읽게 됨 커밋된 데이터만 덮어쓰기 : 같은 데이터를 수정한 트랜잭션이 끝날 때까지 대기 하나의 트랜잭션에서 같은 쿼리를 두번 실행하여 데이터를 조회할때 값이 달라질 수 있다.(Non-Repeatable Read) 커밋된 정보를 어떤 제약 없이 읽을 수 있기 때문에 여러 스냅샷 버젼으로 읽는 것이 가능하기 때문이다. Non-Repeatable Read 한 트랜잭션안에서 같은 쿼리를 두번 실행 했을 때, 다른 값이 나오는 Read 현상을 말하는 것으로, 하나의 트랜잭션안에서 여러 스냅샷이 사용되는 경우를 말한다. Read-Committed 이하의 Isolation Level에서 나오는 현상이다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:2","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"REPEATABLE READ 다른 사용자가 커밋 이후에 데이터를 조회할 경우 데이터가 변경되는 문제(read skew)를 해결한다. Undo 공간에 백업해두고 실제 레코드 값을 변경한다. 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제한다. Undo에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다. 하나의 트랜잭션 안에서 하나의 스냅샨 버젼으로만 동작하기 때문에 같은 쿼리를 두번 실행한다 할지라도 동일한 값이 유지된다. Phantom Read를 막지 못한다. Phantom Read 트랜잭션 안에서 첫번째 쿼리 수행 결과와 두번째 쿼리 수행 결과가 다른것을 나타낸다. 영향을 받는 행 자체가 업데이트되지 않았더라도 행이 추가되거나 삭제된 경우 다른 결과를 반환한다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:3","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"SERIALIZABLE 한 트랜잭션의 결과가 다른 트랜잭션의 퀴리 결과에 영향을 주는 문제(같은 데이터를 쓰지 않지만 실제로는 경쟁 상태)를 해결한다. 인덱스 잠금이나 조건 기반 잠금 등을 사용한다. 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준이다. 성능 측면에서는 동시 처리성능이 가장 낮다. 데이터의 안정성에 위배하는 어떤 것도 발생할 수 없을 정도로 높은 고립성을 가지고 있다. 하지만, 그로 인해 동시성이 많이 떨어진다. 그래서, 하나의 데이터영역에 READ가 발생할 때 어떤 DML도 발생할 수 없어서 많은 문제점을 야기시킨다. ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:2:4","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"각 DBMS의 기본 트랜잭션 격리수준 대부분의 RDBMS는 Read Committed나 Repeatable Read로 고립성을 유지하여 트랜잭션을 지원한다. mysql : Repeable-read postgres : Read Committed oracle : Read Committed mongodb : Read uncommitted ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:3:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["DB"],"content":"참고 https://www.youtube.com/watch?v=poyjLx-LOEU https://happy-coding-day.tistory.com/190 https://mysqldba.tistory.com/334 ","date":"2022-04-06","objectID":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/:4:0","tags":["transaction"],"title":"트랜잭션","uri":"/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"categories":["system"],"content":"데드락이란 서로 요청한 자원이 이미 상대방에게 점유되어 다음 명령을 처리 못하는 상태(교착상태)이다. 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다. ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:0:0","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"발생 조건 데드락은 4가지 조건을 모두 만족해야 발생하게 되는데, 하나라도 조건을 만족하지 않으면 문제를 해결할 수 있는 상황이다. 그 조건들은 아래와 같다. 상호 배제 (Mutual Exclusion) 자원은 한 번에 한 프로세스만 사용할 수 있음. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함. 점유 대기 (Hold and wait) 최소한 하나의 자원을 점유한 채로 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함 비선점 (No Preemption) 이미 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 순 없음 순환 대기 (Circular wait) 대기중인 프로세스 집합에서 순환 형태로 자원을 대기하고 있어야 함 ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:1:0","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"데드락을 해결하는 방안 데드락 상황을 해결하기 위한 방안으로는 예방, 회피, 탐지, 회복 이렇게 4가지가 존재한다. 즉, 데드락이 발생하지 않도록 예방하거나, 발생 가능성을 인정하면서도 적절히 회피하거나, 데드락 발생을 완전히 허용하지만 데드락을 탐지하여 회복하는 방안이다. ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:2:0","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"예방 (Prevention) 데드락 발생 조건 중 하나를 제거하며 데드락을 예방하는 방법이다. 상호배제 부정 : 여러 프로세스가 공유 자원 사용 가능 점유대기 부정 : 프로세스 실행 전 모든 자원을 한 번에 요구하고 허용할 때까지 작업 보류 비선점 부정 : 자원을 점유 중인 높은 우선순위의 프로세스가 다른 자원 요구할 때 해당 자원 반납 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구 하지만 이렇게 데드락을 예방하게 되면 시스템의 처리량이나 효율성은 떨어진다. 아래에서 소계하는 데드락 회피법은 예방법보단 조금 덜 제한적인 방법을 활용하여, 예방법의 단점을 일부 해결한다. ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:2:1","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"회피 (Avoidance) 데드락이 발생했을 때 피해나가는 방법이다. 데드락 회피법에서는 안정상태가 핵심 키워드이다. 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례대로 모두에게 할당해줄 수 있는 상태라면 이것을 안정 상태에 있다고 말한다. 그리고 이처럼, 특정한 순서로 프로세스들에게 자원을 할당하고 실행, 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면, 그것을 안전 순서라고 부른다. 반대로 불안정 상태는 안정 상태가 아닌 상황을 이야기하는데, 즉 데드락이 발생할 수 있는 상황인 것이다. 데드락 회피법은, 자원을 할당한 후에도 시스템이 항상 안정 상태에 있을 수 있도록 할당을 허용하는 것이 기본 특징이다. 이러한 특징을 살린 대표적인 알고리즘으로 ‘은행원 알고리즘’이 있다. Note 은행원 알고리즘 (Banker’s Algorithm) 다익스트라가 고안한 알고리즘 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 데드락 회피 안정 상태라면 자원을 할당하고, 아니라면 다른 프로세스들이 자원을 해제할 때까지 대기 ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:2:2","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"탐지 및 회복(Detection and Recovery) 자원 할당 그래프를 통해 데드락을 탐지한다. 즉 자원 요청 시 탐지 알고리즘을 실행시키는 방식으로, 그에 대한 오버헤드가 발생한다. 탐지 기법에 따라 데드락을 발견했다면, 데드락을 일으킨 프로세스를 종료하거나, 할당된 자원을 반납하게끔 하여 데드락 상황을 해결하는 방법이다. 프로세스 종료 방법 데드락 발생한 프로세스 모두 정지하는 방식 : 연산중이던 프로세스들이 모두 중단되기 때문에 부분 연산 결과가 폐기될 수 있다. 데드락이 제거될 때까지 하나씩 프로세스 중지하는 방식 : 데드락이 회복되는 시점까지 이를 반복하기 때문에 시스템적으로 고비용 작업이다. 자원 선점 시 고려할 점 희생자 선택 (selection of a victim) : 최소의 피해를 줄 수 있는 프로세스를 선택한다. 롤백(rollback) : 선점 된 프로세스를 문제 없던 이전 상태로 롤백해야 한다. 보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 것이다. 기아 상태(starvation) : 한 프로세스가 계속 선점되어 기아상태가 되는 것을 방지해야 한다. 한 가지 방법은 우선 순위를 사용하여 선점 될때마다 프로세스 우선순위를 높이는 것이다. ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:2:3","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"참고 https://velog.io/@haero_kim/%EC%82%AC%EB%82%98%EC%9D%B4%EB%93%A4%EC%9D%98-%EC%9E%90%EA%B0%95%EB%91%90%EC%B2%9C-%EB%8D%B0%EB%93%9C%EB%9D%BD-DeadLock https://yoongrammer.tistory.com/67 ","date":"2022-04-01","objectID":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/:3:0","tags":["deadlock"],"title":"데드락 (DeadLock)","uri":"/%EB%8D%B0%EB%93%9C%EB%9D%BD-deadlock/"},{"categories":["system"],"content":"HDD(Hard Disk Drive) HDD는 자성을 띠는 원형 디스크인 플래터(Platter)와 이 플래터 위를 쉴새 없이 움직이는 헤드(Head)로 구성된다. 돌아가는 LP판의 홈을 바늘이 읽는 것처럼, HDD의 헤드는 회전하는 플래터의 데이터를 읽고 쓴다. 물리적으로 돌아가는 모터 방식이기에 소음이 발생한다. 때문에 소비 전력도 높고 발열 문제가 수반된다는 특징이 있다. HDD는 데이터 처리 속도도 상대적으로 느리며, 충격에 의해 헤드 같은 내부 장치가 손상될 수 있어 내구성도 약하다. ","date":"2022-03-28","objectID":"/hdd-vs-ssd/:1:0","tags":["hdd","ssd"],"title":"HDD vs SSD","uri":"/hdd-vs-ssd/"},{"categories":["system"],"content":"SSD(Solid State Drive) SSD는 데이터 저장 장치로 메모리 반도체(낸드플래시)를 채택하며 HDD의 한계를 넘어선다. 가장 큰 차이점은 데이터 읽기/쓰기 속도를 압도적으로 높였다는 점이다. 모터가 없으니 소음도 발생하지 않고, 소비전력과 발열도 적다. 또한 내부에 움직이는 부품이 없기 때문에 외부 충격으로 손상될 가능성이 낮아 데이터를 안전하게 유지할 수 있다는 장점이 있다. 2013년 경에는 종래의 SATA 연결방식에서 탈피한 NVMe 연결방식의 SSD가 등장해 보조기억장치의 새로운 장을 열었다. NVMe 방식 SSD는 읽기 및 쓰기 속도가 보조기억장치(HDD, 종래의 SSD 등) 수준이 아니라 주기억장치(RAM)에 가까울 정도로 빠르며 크기도 아주 작아 SSD의 표준이 되었다. 플래시 메모리 플래시 메모리는 비휘발성 반도체 저장장치다. 전기적으로 자유롭게 재기록이 가능하다. ROM의 일종인 EEPROM으로부터 발전하여 현재의 모습으로 정착했다. 예전에는 한 번만 기록이 가능했던 PROM(Programmable ROM)과 삭제가 가능했던 EPROM(Erasable PROM) 2가지의 메모리 방식들이 있었다. PROM은 내용을 기록할 때 하드웨어적으로 내부의 배선을 끊기 때문에 재기록이 불가능하다. EPROM은 삭제 방식에 따라 자외선을 쬐어야 하는 UV-EPROM과 전기적으로 가능한 EEPROM 등으로 나뉜다. 후자는 전술했듯 플래시 메모리로 발전했고, 전자는 매우 번거롭기 때문에 현재는 거의 안 쓰인다. 과거에는 PROM과 EPROM이 각종 펌웨어를 저장하고 있었지만, 요즘은 거의 플래시 메모리로 대체되고 있으므로 펌웨어 업데이트가 과거에 비해 매우 자유롭다. 롬에서 나온 것이니 롬의 일종으로 봐야 할 것 같지만, 플래시 메모리는 기록된 내용을 보존한다는 측면에서는 ROM과 유사한 특징이 있으면서도 메모리 어드레싱이 아닌 섹터 어드레싱을 한다는 특성으로 인해 주 기억 장치로 분류되는 RAM이 아닌 하드디스크와 유사한 보조 기억 장치로 분류된다. ","date":"2022-03-28","objectID":"/hdd-vs-ssd/:2:0","tags":["hdd","ssd"],"title":"HDD vs SSD","uri":"/hdd-vs-ssd/"},{"categories":["system"],"content":"참고 https://namu.wiki/w/SSD https://namu.wiki/w/%ED%94%8C%EB%9E%98%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC ","date":"2022-03-28","objectID":"/hdd-vs-ssd/:3:0","tags":["hdd","ssd"],"title":"HDD vs SSD","uri":"/hdd-vs-ssd/"},{"categories":["ML"],"content":"선형 회귀는 한 개 이상의 독립 변수 x와 y의 선형 관계를 모델링한다. 가중치 행렬을 W, 편향을 b, 실제값을 y라고 할 때, 선형회귀는 비용함수 MSE를 최소화하는 W와 b를 추정해 나가는 과정이다. ","date":"2022-03-27","objectID":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/:0:0","tags":["linear-regression"],"title":"선형회귀","uri":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/"},{"categories":["ML"],"content":"계산 과정 편차를 $WX_{i}+b-y_{i}$라고 할 때, 비용함수는 다음과 같다. $$cost(W,b) = \\sum_{i=1}^{m} (WX_{i}+b-y_{i})^2 \\cdot \\cfrac{1}{m}$$ $$= \\sum_{i=1}^{m}(X_{i}^2W^2+2X_{i}bW-2by_{i}-2X_{i}y_{i}W+b^2+yi^2) \\cdot \\cfrac{1}{m}$$ 비용함수를 W로 편미분 하면 다음과 같다. $$\\partial{W} = \\cfrac{\\partial{cost(W,b)}} {\\partial{W}} = \\sum_{i=1}^{m}(2X_{i}^2W+2X_{i}b-2X_{i}y_{i})\\cdot \\cfrac{1}{m} $$ $$= 2X_{i}\\sum_{i=1}^{m} (WX_{i}+b-y_{i})\\cdot \\cfrac{1}{m}$$ 비용함수를 b로 편미분 하면 다음과 같다. $$\\partial{b} = \\cfrac{\\partial{cost(W,b)}} {\\partial{b}} = \\sum_{i=1}^{m}(2X_{i}W-2y_{i}+2b)\\cdot \\cfrac{1}{m}$$ $$= 2\\sum_{i=1}^{m} (WX_{i}+b-y_{i})\\cdot \\cfrac{1}{m}$$ W와 b를 Gradient Descent로 추정해나가는 과정은 다음과 같다. $$W:=W-lr\\cfrac{\\partial{cost(W,b)}} {\\partial{W}}$$ $$b:=b-lr\\cfrac{\\partial{cost(W,b)}} {\\partial{b}}$$ ","date":"2022-03-27","objectID":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/:1:0","tags":["linear-regression"],"title":"선형회귀","uri":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/"},{"categories":["ML"],"content":"코드로 구현 import numpy as np xy = np.array([[1., 2., 3., 4., 5., 6.], [3., 6., 9., 12., 15., 18.]]) x_train = xy[0] y_train = xy[1] weight = np.random.rand(1) bias = np.random.rand(1) learning_rate = 0.001 for i in range(10000): pred = weight * x_train + bias error = pred - y_train cost = (error ** 2).mean() weight -= learning_rate * (error * 2 * x_train).mean() bias -= learning_rate * 2 * error.mean() if i % 100 == 0: print('Epoch ({:10d}/1000) error: {:10f}, beta_gd: {:10f}, bias: {:10f}'.format(i, cost, weight.item(), bias.item())) 결과는 다음과 같다. Epoch ( 0/1000) error: 79.680243, beta_gd: 0.628488, bias: 0.666181 Epoch ( 100/1000) error: 0.359263, beta_gd: 2.657885, bias: 1.096474 Epoch ( 200/1000) error: 0.222940, beta_gd: 2.745611, bias: 1.074800 Epoch ( 300/1000) error: 0.207077, beta_gd: 2.757658, bias: 1.036960 Epoch ( 400/1000) error: 0.192499, beta_gd: 2.766458, bias: 0.999819 Epoch ( 500/1000) error: 0.178947, beta_gd: 2.774833, bias: 0.963984 Epoch ( 600/1000) error: 0.166349, beta_gd: 2.782904, bias: 0.929432 Epoch ( 700/1000) error: 0.154637, beta_gd: 2.790685, bias: 0.896118 Epoch ( 800/1000) error: 0.143751, beta_gd: 2.798188, bias: 0.863999 Epoch ( 900/1000) error: 0.133631, beta_gd: 2.805421, bias: 0.833030 Epoch ( 1000/1000) error: 0.124223, beta_gd: 2.812395, bias: 0.803172 Epoch ( 1100/1000) error: 0.115477, beta_gd: 2.819120, bias: 0.774384 Epoch ( 1200/1000) error: 0.107348, beta_gd: 2.825603, bias: 0.746628 Epoch ( 1300/1000) error: 0.099790, beta_gd: 2.831854, bias: 0.719867 Epoch ( 1400/1000) error: 0.092765, beta_gd: 2.837881, bias: 0.694064 Epoch ( 1500/1000) error: 0.086234, beta_gd: 2.843692, bias: 0.669187 Epoch ( 1600/1000) error: 0.080163, beta_gd: 2.849294, bias: 0.645202 Epoch ( 1700/1000) error: 0.074520, beta_gd: 2.854696, bias: 0.622076 Epoch ( 1800/1000) error: 0.069273, beta_gd: 2.859904, bias: 0.599779 Epoch ( 1900/1000) error: 0.064396, beta_gd: 2.864925, bias: 0.578281 Epoch ( 2000/1000) error: 0.059863, beta_gd: 2.869767, bias: 0.557554 Epoch ( 2100/1000) error: 0.055648, beta_gd: 2.874435, bias: 0.537569 Epoch ( 2200/1000) error: 0.051731, beta_gd: 2.878935, bias: 0.518301 Epoch ( 2300/1000) error: 0.048089, beta_gd: 2.883275, bias: 0.499724 Epoch ( 2400/1000) error: 0.044703, beta_gd: 2.887459, bias: 0.481812 Epoch ( 2500/1000) error: 0.041556, beta_gd: 2.891492, bias: 0.464543 Epoch ( 2600/1000) error: 0.038631, beta_gd: 2.895382, bias: 0.447892 Epoch ( 2700/1000) error: 0.035911, beta_gd: 2.899131, bias: 0.431838 Epoch ( 2800/1000) error: 0.033383, beta_gd: 2.902747, bias: 0.416360 Epoch ( 2900/1000) error: 0.031033, beta_gd: 2.906233, bias: 0.401436 Epoch ( 3000/1000) error: 0.028848, beta_gd: 2.909594, bias: 0.387048 Epoch ( 3100/1000) error: 0.026817, beta_gd: 2.912834, bias: 0.373175 Epoch ( 3200/1000) error: 0.024929, beta_gd: 2.915958, bias: 0.359799 Epoch ( 3300/1000) error: 0.023174, beta_gd: 2.918971, bias: 0.346903 Epoch ( 3400/1000) error: 0.021542, beta_gd: 2.921875, bias: 0.334469 Epoch ( 3500/1000) error: 0.020026, beta_gd: 2.924675, bias: 0.322481 Epoch ( 3600/1000) error: 0.018616, beta_gd: 2.927375, bias: 0.310922 Epoch ( 3700/1000) error: 0.017305, beta_gd: 2.929978, bias: 0.299778 Epoch ( 3800/1000) error: 0.016087, beta_gd: 2.932488, bias: 0.289033 Epoch ( 3900/1000) error: 0.014955, beta_gd: 2.934908, bias: 0.278673 Epoch ( 4000/1000) error: 0.013902, beta_gd: 2.937241, bias: 0.268684 Epoch ( 4100/1000) error: 0.012923, beta_gd: 2.939490, bias: 0.259054 Epoch ( 4200/1000) error: 0.012013, beta_gd: 2.941659, bias: 0.249769 Epoch ( 4300/1000) error: 0.011168, beta_gd: 2.943750, bias: 0.240816 Epoch ( 4400/1000) error: 0.010381, beta_gd: 2.945766, bias: 0.232185 Epoch ( 4500/1000) error: 0.009650, beta_gd: 2.947710, bias: 0.223863 Epoch ( 4600/1000) error: 0.008971, beta_gd: 2.949585, bias: 0.215839 Epoch ( 4700/1000) error: 0.008339, beta_gd: 2.951392, bias: 0.208102 Epoch ( 4800/1000) error: 0.007752, beta_gd: 2.953134, bias: 0.200643 Epoch ( 4900/1000) error: 0.007","date":"2022-03-27","objectID":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/:2:0","tags":["linear-regression"],"title":"선형회귀","uri":"/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/"},{"categories":["web"],"content":"OSI는 Open Systems Interconnection의 약자로 개방형 시스템 간의 상호 연결을 의미한다. 국제 표준화 기구인 ISO에서 개발한 모델로 컴퓨터 네트워크의 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:0","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"1계층 - 물리 계층(Physical Layer) 네트워크 OSI 모델에서 가장 낮은 계층으로 하드웨어 전송 기술로 구성된다. 하드웨어 장비로 케이블, 리피터, 허브가 있으며 네트워크에서 물리적으로 데이터를 전송하는 역할을 수행한다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:1","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"2계층 - 데이터 링크 계층(Data Link Layer) 물리 계층을 통해 데이터를 전송하다가 데이터가 제대로 도착하지 못하고 중도 분실되거나 데이터의 내용이 깨져서 변형이 되는 등 물리적인 오류가 발생할 수 있다. 이러한 물리적인 감지하고 제어하여 포인트 투 포인트 간의 신뢰성 있는 전송을 보장한다. 네트워크 장비 중 브릿지나 L2 (Layer 2) 스위치가 이 계층에서 동작한다. 데이터 링크 계층에서 전송되는 데이터의 단위를 프레임이라고 한다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:2","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"3계층 - 네트워크 계층 네트워크 계층의 핵심은 라우팅이다. 데이터가 전송되기 위해 여러 경로를 거쳐서 가야 하는데 이 경로 배정 기능을 바로 라우터가 수행한다. 네트워크 계층에서 전송되는 데이터 단위는 패킷이다. 네트워크 계층에는 IPv4/IPv6, ICMP (Internet Control Message Protocol), IP 주소를 데이터 링크 계층의 MAC 주소로 변환하는 ARP (Address Resolution Protocol) 등 여러 프로토콜이 있다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:3","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"4계층 - 전송 계층(Transport Layer) 데이터를 전송하며 오류 검출 및 복구, 흐름제어, 중복 검사 등을 수행한다. 전송 계층에는 연결형 서비스와 비연결형 서비스가 있다. TCP는 연결형 서비스로 신뢰성 있는 연결을 보장하고, UDP는 비연결형 서비스로 스트리밍 서비스와 같이 데이터를 빠르게 통신할 때 이용된다. TCP에서의 데이터 단위는 세그먼트이고, UDP에서의 데이터 단위는 데이터그램이다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:4","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"5계층 - 세션 계층(Session Layer) 세션 계층은 세션 연결의 설정과 해제의 기능을 하고 서비스 인증 및 허가의 기능을 처리한다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:5","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"6계층 - 표현 계층(Presentation Layer) 인코딩이나 암호화 동작이 이 계층에서 이루어진다. 데이터를 표현하기 위한 문맥 계층이라 불리고 압축 및 데이터 변환이 일어난다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:6","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"7계층 - 응용 계층(Application Layer) 응용 프로세스 간의 기능을 제공한다. OSI 모델 중 가장 상위 계층으로 추상화된 계층이다. 응용 프로세스의 예로 텔넷 등이 있으며 실제로 애플리케이션과 가장 가까운 계층이다. 7계층에는 원격 로그인에 대한 텔넷부터 파일 전송인 FTP (File Transfer Protocol), 전자 메일에 대한 SMTP (Simple Mail Transfer Protocol), DNS 등 여러 프로토콜이 있다. ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:0:7","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["web"],"content":"참고 개발자가 되기 위해 꼭 알아야 하는 IT 용어, 비제이리퍼블릭 ","date":"2022-03-26","objectID":"/osi-7%EA%B3%84%EC%B8%B5/:1:0","tags":["osi-7-layer"],"title":"OSI 7계층","uri":"/osi-7%EA%B3%84%EC%B8%B5/"},{"categories":["system"],"content":"인코딩이란, 사용자가 입력한 문자나 기호를 컴퓨터가 이용할 수 있는 신호로 만드는 것을 말한다. ","date":"2022-03-25","objectID":"/ascii-unicode/:0:0","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["system"],"content":"아스키코드(American Standard Code for Information Interchange) 가장 처음 만들어진 인코딩방식이다. 숫자와 문자를 매칭시키는 국제적 규칙이다. 패리티 비트를 제외하고, 128개의 문자조합을 제공하는 7비트 부호로 구성된다.(패리티 비트는 데이터의 에러를 탐지하기 위해 사용한다. 일곱자리의 이진수에서 ‘1’이 홀수개라면 끝에 1을, ‘1’이 짝수개라면 끝에 0을 덧붙인다. 아주 정밀하진 않지만 패리티 비트를 이용해 어느 정도의 에러를 탐지할 수 있다.) 아스키코드만으로는 영어만 표현 가능하며 각 나라별 언어를 표현할 수 없다는 단점이 있다. ","date":"2022-03-25","objectID":"/ascii-unicode/:1:0","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["system"],"content":"유니코드(Unicode) 전 세계 언어의 문자를 정의하기 위한 국제 표준 코드이다. 사용중인 운영체제, 프로그램, 언어에 관계 없이 문자마다 고유한 코드 값을 제공한다. ","date":"2022-03-25","objectID":"/ascii-unicode/:2:0","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["system"],"content":"UTF-8 (8-bit Unicode Transformation Format) 유니코드를 사용하는 인코딩 방식 중 하나이며 표현범위에 따라 2,3,4바이트를 사용한다. UTF-8은 인코딩 형태를 8비트 단위로 한다는 의미를 가지고 있다. UTF8은 현재 다양한 플랫폼(Windows, Linux, Unix, Mac OS)이 접속하는 인터넷환경에서 de facto standard(사실상의 표준)으로 자리 잡았다. UTF-8의 강점은 아스키방식과 완벽하게 호환(영문 영역에서는 100% 호환) 된다는 것이다. 또한 UTF-8은 endianness 인코딩으로 little endian, big endian의 구분이 없다. 그래서 이 기종간의 데이터 교환을 위해 현재 가장 선호되는 인코딩이다. ","date":"2022-03-25","objectID":"/ascii-unicode/:2:1","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["system"],"content":"UTF-16 (16-bit Unicode Transformation Format) UTF-16은 아스키와 동일한 범위를 표현할 때도 앞에 0으로 채워서 16 비트가 최소로 이용되며 2 또는 4 바이트 단위로만 사용된다. endian 방식에 따라 다르게 읽힌다. ","date":"2022-03-25","objectID":"/ascii-unicode/:2:2","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["system"],"content":"UTF-32 (32-bit Unicode Transformation Format) 데이터 표현시 4바이트단위를 사용한다. 메모리 낭비가 심하다는 단점이 있다. ","date":"2022-03-25","objectID":"/ascii-unicode/:2:3","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["system"],"content":"참고 https://dar0m.tistory.com/212 https://nhj12311.tistory.com/59 ","date":"2022-03-25","objectID":"/ascii-unicode/:3:0","tags":["ascii","unicode"],"title":"ASCII, Unicode","uri":"/ascii-unicode/"},{"categories":["java"],"content":"동기화는 프로세스(스레드)가 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것을 말한다. 이러한 동기화 메커니즘인 상호배제는 하나의 프로세스가 공유자원을 사용할 때 다른 프로세스가 동일한 공유자원에 접근할 수 없도록 통제하는 것을 뜻한다. 상호배제 방법으로는 Mutex, Semaphore 방식이 사용된다. Java 에서는 Monitor 라는 도구를 통해 객체에 Lock을 걸어 상호배제를 할 수 있다. ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:0:0","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["java"],"content":"동기화 메커니즘 ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:1:0","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["java"],"content":"Mutex Mutex는 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 메커니즘이다. 특징을 살펴보면 다음과 같다. Boolean 타입의 Lock 변수를 사용한다. 따라서 1개의 공유자원에 대한 접근을 제한한다. 공유자원을 사용 중인 스레드가 있을 때, 다른 스레드가 공유자원에 접근한다면 Blocking 후 대기 큐로 보낸다. Lock을 건 스레드만 Lock을 해제할 수 있다. ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:1:1","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["java"],"content":"Semaphore Semaphore는 멀티프로그래밍 환경에서 다수의 프로세스나 스레드가 n개의 공유 자원에 대한 접근을 제한하는 방법으로 사용되는 동기화 기법이다. 세마포어 변수를 통해 wait, signal 을 관리한다. 세마포어 변수는 0 이상의 정수형 변수를 갖는다. n 개의 공유자원에 대한 접근을 제한할 수 있으며 이를 계수 세마포어라고 한다. 접근 가능한 공유 자원의 수가 1개일 때는 이진 세마포어로 뮤텍스처럼 사용할 수 있다. 큐에 연결된 스레드를 깨우는 방식에 따라 강성 세마포어(큐에 연결된 스레드를 깨울 때 FIFO 정책), 약성 세마포어(큐에 연결된 스레드를 깨울 때 순서를 특별히 명시하지 않음)로 구분된다. Lock을 걸지 않은 스레드도 Signal을 보내 Lock 을 해제할 수 있다. ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:1:2","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["java"],"content":"Monitor Monitor는 임계 구역을 지켜내기 위한 방법인 상호 배제를 프로그램으로 구현한 것이다. 세마포어는 wait \u0026 signal 연산 순서를 바꿔서 실행하거나 둘 중 하나라도 생략하면 상호배제를 위반하는 상황이나 교착 상태가 발생한다. wait \u0026 signal 연산이 프로그램 전체에 구성되어 있으면 세마포어의 영향이 미치는 곳이 어딘지 파악하기 어렵기 때문에 세마포어를 사용하여 프로그램을 구현하기 어렵다. 이러한 단점을 극복하기 위해 모니터가 등장했다. 모니터는 프로그래밍 언어 수준에서 제공되며, 순차적으로 사용할 수 있는 공유 자원 혹은 공유 자원 그룹을 할당하는 데 사용된다. 모니터는 이진 세마포어만 가능하다. 공유 자원에 점유 중인 프로세스(스레드)는 Lock을 가지고 있다. 공유 자원을 점유 중인 프로세스(스레드)가 있는 상황에서 다른 프로세스(스레드)가 공유 자원에 접근하려고 하면 외부 모니터 준비 큐에서 진입을 wait 한다. Monitor 는 Semaphore 처럼 signal 연산을 보내는 것이 아니라 조건 변수를 사용하여 특정 조건에 대해 대기 큐에 signal 을 보내 작업을 시작시킨다. ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:1:3","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["java"],"content":"자바에서 상호배제 구현 ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:2:0","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["java"],"content":"Synchronized Java 의 synchronized 키워드는 스레드 동기화를 할 때 사용하는 대표적인 기법이다. 자바의 모든 인스턴스는 Monitor 를 가지고 있으며 Monitor 를 통해 Thread 동기화를 수행한다. synchronized 키워드가 붙은 메서드를 사용하려면 Lock을 가지고 있어야 한다. synchronized를 사용하는 방법으로는 메서드 앞에 키워드 명시, 인스턴스로 사용하기가 있다. 동기화가 필요한 메서드 앞에 synchronized 키워드만 붙여주면 편리하게 동기화를 적용할 수 있다. 인스턴스로 사용하려면 메서드 내부에서 synchronized (메서드) { 구현 } 으로 사용할 수 있다. ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:2:1","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["java"],"content":"wait, notify Monitor 에는 Condition Variable 이 있는데 이를 통해 wait(), notify() 메서드가 구현되어 있다. Lock 을 가진 스레드가 다른 스레드에 Lock 을 넘겨준 이후에 대기해야 한다면 wait() 를 사용하면 된다. 그리고 대기 중인 임의의 스레드를 깨우려면 notify() 를 통해 깨울 수 있다. 대기 중인 모든 스레드를 깨우려면 notifyAll() 을 통해 깨울 수 있는데, 이 경우에는 하나의 스레드만 Lock 을 획득하고 나머지 스레드는 다시 대기 상태에 들어간다. ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:3:0","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-10-23-java-synchronize/ ","date":"2022-03-23","objectID":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/:4:0","tags":["mutex","semaphore"],"title":"Java 동기화","uri":"/java-%EB%8F%99%EA%B8%B0%ED%99%94/"},{"categories":["system"],"content":"개념 ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:0","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["system"],"content":"블럭/넌블럭 블럭/넌블럭은 함수호출에서의 이야기. 제어권에 의해 대기가 발생하는지 여부로 구분한다. Block 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return하지 않으면 블럭이다. Non-Block 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return하여 호출한 함수가 다른 일을 진행할 수 있도록 하면 넌블럭이다. ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:1","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["system"],"content":"동기/비동기 동기/비동기는 행위에 대한 이야기. 호출한 함수가 호출된 함수를 신경쓰는지 여부로 구분한다. Synchronous 호출된 함수의 수행 결과 및 종료를 호출된 함수 뿐 아니라 호출한 함수도 함께 신경쓰면 동기이다. Asynchoronous 호출된 함수의 수행 결과 및 종료를 호출된 함수 혼자 직접 신경쓰고 처리하면 비동기이다. ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:1:2","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["system"],"content":"예시 ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:0","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["system"],"content":"동기 \u0026 블로킹 Note 손님: 아메리카 주문 직원: 아메리카노 만드는중 손님: (그 자리에 서서 기다리는중. 결과가 궁금함. 테이블 못가고 서있음.) ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:1","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["system"],"content":"비동기 \u0026 블로킹 블럭 \u0026 비동기는 결국 다른 작업이 끝날 때를 기다려야 하기 때문에 동기 \u0026 비동기와 비슷한 효율이 나온다. Note 손님: 아메리카노 주문 직원 : 아메리카노 만드는중 손님 : (안궁금함. 테이블에 가고싶지만 못가고 서있음.) ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:2","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["system"],"content":"동기 \u0026 논블로킹 논블로킹으로 자신의 작업을 계속하고 있지만 다른 작업과의 동기를 위해 계속해서 다른 작업이 끝났는지 조회한다. 즉, 호출된 함수가 호출한 함수에게 제어권을 바로 return하여 호출한 함수가 다른 업무를 볼 수 있었음(Non-Blocked)에도 불구하고, 여전히 호출된 함수의 업무 결과에만 계속 함께 신경쓰느라(Synchronous) 제 할일을 못하게 되는 현상이 일어난다. 넌블럭 \u0026 동기도 효율이 좋지 않다. Note 손님: 아메리카노 주문 직원 : 아메리카노 만드는중 손님 : 다른 작업하며 계속 확인 ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:3","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["system"],"content":"비동기 \u0026 논블로킹 자원이 충분하다면 효율이 좋다. 자신의 작업이 멈추지도 않고, 다른 주체가 하는 작업의 결과가 나왔을 때 콜백을 설정하기도 한다. 다른 주체에게 작업을 맡겨놓고 자신이 하던 일을 계속할 수 있기 때문에 해야 할 작업이 대규모이고, 동기가 필요하지 않을 때 효과적이다. Note 손님: 아메리카노 주문 직원 : 아메리카노 만드는중 손님 : 자리가서 SNS, 유튜브 시청 직원 : 아메리카노 제작 완료 후 알림 ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:2:4","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["system"],"content":"참고 https://velog.io/@leehyunho2001/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD ","date":"2022-03-19","objectID":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/:3:0","tags":["block","non-block","sync","async"],"title":"블럭, 넌블럭, 동기, 비동기","uri":"/%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD-%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"categories":["java"],"content":"추상클래스 자바에서는 하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 추상 클래스(abstract class)라고 한다. 이러한 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해준다. 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로, 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야 할 경우 사용한다. ","date":"2022-03-17","objectID":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/:1:0","tags":["abstract-class","interface"],"title":"추상클래스 vs 인터페이스","uri":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"categories":["java"],"content":"인터페이스 인터페이스는 객체의 사용 방법을 정의한 타입이다. 인터페이스는 상속 관계를 타고 올라갔을 때 다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다. 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다. 예를 들어 Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데, 구현클래스들 간에 관련성이 없다. ","date":"2022-03-17","objectID":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/:2:0","tags":["abstract-class","interface"],"title":"추상클래스 vs 인터페이스","uri":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"categories":["java"],"content":"사용 예시 추상클래스는 IS - A, 즉 “~이다” 로 표현되는 관계에 사용한다. 인터페이스는 HAS - A, 즉 “~을 할 수 있는\"로 표현되는 관계에 사용된다. 위의 예제에서 인간과 동물은 생명체를 상속하고 각 생명체들은 구분에 따라 인간과 동물을 상속한다. 이러한 관계는 추상클래스로 표현할 수 있다. 그리고 각각 할 수 있는 기능들은 인터페이스로 구현할 수 있다. ","date":"2022-03-17","objectID":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/:3:0","tags":["abstract-class","interface"],"title":"추상클래스 vs 인터페이스","uri":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"categories":["java"],"content":"참고 https://velog.io/@dongvelop/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4 https://myjamong.tistory.com/150 ","date":"2022-03-17","objectID":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/:4:0","tags":["abstract-class","interface"],"title":"추상클래스 vs 인터페이스","uri":"/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"categories":["java"],"content":"제네릭이란 JDK 1.5부터 도입한 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법이다. ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:0:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"제네릭 필요성 : 타입 안전성 다음 예제를 보자. public static void main(String[] args) { List numbers = Arrays.asList(1, 2, 3, 4, 5, 6); int sum = 0; for (Object number : numbers) { sum += (int) number; } } List에 있는 모든 숫자를 더하는 로직이다. List에 타입 지정을 안 했기 때문에 Object로 타입이 지정되고 더하는 부분에서 형 변환을 직접 해줘야 하는 번거로움이 있다. 위 예제에서는 형 변환을 한 번밖에 안 했지만 만약 타입 지정을 안 한 List가 사용되는 곳이 1000군데가 넘는다면 1000군데서 전부 예제처럼 직접 형변환을 해줘야 하는 번거로움이 있다. 아래와 같이 제네릭을 사용한다면 public static void main(String[] args) { List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5, 6); int sum = 0; for (Integer number : numbers) { sum += number; } } 불필요한 형 변환을 안 해도 되고 코드도 더 깔끔해진다. 또한 타입 안전성이 있다. public static void main(String[] args) { List numbers = Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"); int sum = 0; for (Object number : numbers) { sum += (int) number; } } int형으로 형 변환을 해주며 더해주지만 List의 요소가 int형이라는 보장이 없다. 위 예제와 같이 List에 문자열을 넣어주어도 컴파일 에러가 발생하지 않고 런타임에 ClassCastException 이 터지게 된다. 컴파일 시 타입을 체크하고 에러를 찾아낼 수 있는 컴파일 언어의 장점을 발휘하지 못하는 셈이다. 제네릭을 사용했다면 아래와 같이 컴파일 시에 의도하지 않은 타입이 들어오는 걸 막을 수 있다. ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:1:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"제한된 제네릭 제네릭은 원하는 타입이 있을 때도 모든 타입이 들어올 수 있는 문제가 있다. public class Car\u003cT\u003e { private final T name; public Car(T name) { this.name = name; } ... } 위와 같은 Car 클래스 인스턴스 변수 name은 문자 관련 타입 지정되기를 원해도 아래와 같이 아무 타입이나 들어올 수 있다. public static void main(String[] args) { Car\u003cInteger\u003e car = new Car\u003c\u003e(1); } 이럴 때 타입 뒤에 extends 키워드를 사용해 타입을 제한시킬 수 있다. public class Car\u003cT extends CharSequence\u003e { private final T name; public Car(T name) { this.name = name; } ... } CharSequence 인터페이스 하위 객체들만 데이터 타입으로 지정할 수 있게 함으로써 인스턴스 변수 name에 문자열 관련 타입만 지정할 수 있게 되었다. public static void main(String[] args) { Car\u003cString\u003e car = new Car\u003c\u003e(\"sports\"); } Collections.sort에서도 제한된 제네릭을 사용하고 있다. public static \u003cT extends Comparable\u003c? super T\u003e\u003e void sort(List\u003cT\u003e list) { list.sort(null); } 정렬하기 위해서 List에 지정될 타입 T를 Comparable 인터페이스 하위 타입으로 제한시킨 것이다. ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:2:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["java"],"content":"출처 https://tecoble.techcourse.co.kr/post/2020-11-09-generics-basic/ ","date":"2022-03-15","objectID":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/:3:0","tags":["generic"],"title":"자바 제네릭(Generics)","uri":"/%EC%9E%90%EB%B0%94-%EC%A0%9C%EB%84%A4%EB%A6%ADgenerics/"},{"categories":["web"],"content":"포워드 프록시(Forward Proxy) 일반적으로, 프록시 서버라고 하면 포워드 프록시를 의미한다. 포워드 프록시란 클라이언트와 인터넷 사이에 프록시가 위치해서 클라이언트 대신 서버에 요청을 보내주는 형태를 말한다. 포워드프록시를 통해 얻는 이점은 다음과 같다. 로컬 네트워크와 인터넷 사이 오가는 트래픽을 제어할 수 있다. 예를 들어 초등학교 안에서 학생들이 부적절한 콘텐츠를 브라우징하는 것을 막기 위해서 포워드 프록시를 사용할 수 있다. 포워드 프록시는 대개 캐싱 기능이 있으므로 어떤 콘텐츠가 빈번하게 사용된다면 월등한 성능 향상을 가져올 수 있다. 서버의 응답을 캐싱해서 저장해두면 전송 시간이 절약되며, 불필요한 외부 전송을 하지 않아도 된다. 또한 외부 요청이 감소되므로 네트워크 병목 현상을 방지할 수 있다. 보안을 강화할 수 있다. 클라이언트의 요청을 포워드 프록시가 요청한 것처럼 가장함으로써 서버로부터 클라이언트의 정보를 클라이언트의 요청을 숨길 수 있고, 정해진 사이트만 연결하게 설정하는 등 웹 사용 환경을 제한하는 것도 가능하다. 또한 포워드 프록시에서 네트워크 패킷 로깅도 가능하기 때문에 보안이 매우 중요한 기업 환경등에서 많이 사용한다. ","date":"2022-03-13","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/:1:0","tags":["forward-proxy","reverse-proxy"],"title":"프록시 서버","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/"},{"categories":["web"],"content":"리버스 프록시(Reverse Proxy) 리버스 프록시는 서버와 인터넷 사이에 위치해서 서버의 응답을 대신 클라이언트에게 전달해주는 역할을 한다. 리버스 프록시는 포워드 프록시의 가장 큰 차이점은 리버스 프록시는 포워드 프록시와 다르게 인터넷과 서버 사이에 위치한다는 점이다. 리버스 프록시를 통해 얻는 이점은 다음과 같다. 로드밸런싱(Load Balancing) 이 가능하다. 클라이언트의 요청이 많아지면 서버는 과부하로 동작을 멈추게 될 수 있다. 이러한 문제를 방지하기 위해서는 여러대의 서버에게 적절하게 트래픽을 나눠주어야 한다. 이러한 방법을 로드밸런싱이라고 한다. 보안상의 이유로 클라이언트가 직접서버에 접근하는 것을 원하지 않는 경우, 리버스 프록시를 통해 클라이언트가 간접적으로 서버에 접근할 수 있도록 만들 수 있다. 이 경우 리버스 프록시가 방화벽 역할을 한다고도 볼 수 있다. ","date":"2022-03-13","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/:2:0","tags":["forward-proxy","reverse-proxy"],"title":"프록시 서버","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/"},{"categories":["web"],"content":"참고 개발자가 되기 위해 꼭 알아야 하는 IT 용어, 비제이리퍼블릭 ","date":"2022-03-13","objectID":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/:3:0","tags":["forward-proxy","reverse-proxy"],"title":"프록시 서버","uri":"/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/"},{"categories":["개발방법론"],"content":"DIP(Dependency Inversion Principle) 우리가 다루는 모듈은 고수준 모듈과 저수준 모듈로 나눌 수 있다. 고수준 모듈이란 의미있는 단일 기능을 제공하는 모듈이며, 저수준 모듈은 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현인 모듈이다. Layered Architecture 상에서 Application 및 Domain 등의 고수준 모듈은 Infrastructure라는 저수준 모듈을 의존한다. 그 결과, 구현 부분의 변경에 유연하지 못하고 테스트하기 어렵다는 문제점이 발생한다. DIP(Dependency Inversion Principle)이란 의존 관계를 역전시켜서 저수준 모듈이 고수준 모듈에 의존하도록 구현하는 것을 의미한다. 고수준 모듈이 저수준 모듈을 직접 의존하는 것이 아니라, 저수준 모듈이 인터페이스 등 추상을 매개체로 고수준 모듈을 참조하도록 한다. 이를 통해 구현 기술과 관련된 종속성을 쉽게 제거할 수 있다. ","date":"2022-03-09","objectID":"/dependency-inversion-principle/:1:0","tags":["solid"],"title":"Dependency Inversion Principle","uri":"/dependency-inversion-principle/"},{"categories":["개발방법론"],"content":"DIP 예제 public interface PlatformContributionCalculator { Contribution calculate(String accessToken, String username); } @RequiredArgsConstructor @Component public class GithubContributionCalculator implements PlatformContributionCalculator { @Value(\"${github.contribution.url}\") private final String url; public Contribution calculate(String accessToken, String username) { HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.setBearerAuth(accessToken); RequestEntity\u003cVoid\u003e requestEntity = RequestEntity .get(url) .headers(httpHeaders) .build(); RestTemplate restTemplate = new RestTemplate(); return restTemplate.exchange(requestEntity, Contribution.class) .getBody(); } } @RequiredArgsConstructor @Transactional @Service public class UserService { private final UserRepository userRepository; private final PlatformContributionCalculator platformContributionCalculator; public ContributionResponseDto calculateContributions(ContributionRequestDto requestDto) { User user = userRepository.findByName(requestDto.getUsername()) .orElseThrow(InvalidUserException::new); Contribution contribution = platformContributionCalculator .calculate(requestDto.getAccessToken(), user.getName()); return ContributionResponseDto.builder() .starsCount(contribution.getStarsCount()) .commitsCount(contribution.getCommitsCount()) .prsCount(contribution.getPrsCount()) .issuesCount(contribution.getIssuesCount()) .reposCount(contribution.getReposCount()) .build(); } } Application 계층이 Infrastructure 계층의 구현체가 아닌 Domain 계층의 PlatformContributionCalculator 인터페이스를 의존하도록 구현한다. 만약 요구사항 변경으로 인해 저수준 모듈이 GitHub 플랫폼 연동에서 GitLab 플랫폼 연동으로 변경되더라도, 고수준 모듈에서의 변경을 최소화할 수 있게 된다. @Autowired private UserRepository userRepository; private UserService userService; @BeforeEach void setUp() { PlatformContributionCalculator platformContributionCalculator = (accessToken, username) -\u003e { // do something }; userService = new UserService(userRepository, platformContributionCalculator); } 테스트를 진행할 때 PlatformContributionCalculator에 적합한 Mock Object를 주입할 수 있게 된다. 따라서 GitHub 서버가 아닌 Mock 서버로 API 요청을 보내게끔 테스트 대역을 조절함으로써, Access Token으로 인한 문제에서 벗어나 자동화된 테스트를 쉽게 작성할 수 있다. @TestConfiguration public class InfrastructureTestConfiguration { @Bean public PlatformContributionCalculator platformContributionCalculator() { return new MockContributionCalculator(); } } 테스트 클래스에 정의하는 것이 번거롭다면 대역을 테스트용 Bean으로 주입해 여러 통합 테스트에서 사용할 수 있다. ","date":"2022-03-09","objectID":"/dependency-inversion-principle/:2:0","tags":["solid"],"title":"Dependency Inversion Principle","uri":"/dependency-inversion-principle/"},{"categories":["개발방법론"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-21-dip/ ","date":"2022-03-09","objectID":"/dependency-inversion-principle/:3:0","tags":["solid"],"title":"Dependency Inversion Principle","uri":"/dependency-inversion-principle/"},{"categories":["개발방법론"],"content":"디미터의 법칙(Law of Demeter) 디미터의 법칙은 “Object-Oriented Programming: An Objective Sense of Style” 에서 처음으로 소개되었다. Demeter라는 프로젝트를 진행하던 개발자들은 어떤 객체가 다른 객체에 대해 지나치게 많이 알다보니, 결합도가 높아지고 좋지 못한 설계를 야기한다는 것을 발견하였다. 그래서 이를 개선하고자 객체에게 자료를 숨기는 대신 함수를 공개하도록 하였는데, 이것이 바로 디미터의 법칙이다. 즉, 디미터의 법칙은 다른 객체가 어떠한 자료를 갖고 있는지 속사정을 몰라야 한다는 것을 의미하며, 이러한 이유로 Don’t Talk to Strangers(낯선 이에게 말하지 마라) 또는 Principle of least knowledge(최소 지식 원칙) 으로도 알려져 있다. 또는 직관적으로 이해하기 위해 여러 개의 .(도트)을 사용하지 말라는 법칙으로도 많이 알려져 있으며, 디미터의 법칙을 준수함으로써 캡슐화를 높혀 객체의 자율성과 응집도를 높일 수 있다. 객체 지향 프로그래밍에서 가장 중요한 것은 “객체가 어떤 데이터를 가지고 있는가?“가 아니라, “객체가 어떤 메세지를 주고 받는가?\" 이다. 그렇기에 디미터의 법칙은 객체 지향 프로그래밍에서 상당히 중요한 개념인데, 디미터의 법칙이 위배된다는 것은 올바른 객체 지향 프로그래밍을 하지 못하고 있다는 증거이기도 하다. ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:1:0","tags":["oop"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["개발방법론"],"content":"디미터(Demeter)의 법칙 예시 ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:2:0","tags":["oop"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["개발방법론"],"content":"디미터의 법칙을 위반하는 코드 예를 들어 서울에 살고 있는 어떤 사용자에게 알림을 보내주는 함수를 구현한다고 하자. 이를 구현하기 위해 우리는 다음과 같은 User 객체와 Address 객체를 필요로 할 것이고, User객체는 Address라는 주소 객체를 가지고 있을 것이다. @Getter public class User { private String email; private String name; private Address address; } @Getter public class Address { private String region; private String details; } 이제 어떤 사용자가 서울에 살고 있으면 알림을 보내주는 함수를 다음과 같이 구현하였다고 하자. @Service public class NotificationService { public void sendMessageForSeoulUser(final User user) { if (\"서울\".equals(user.getAddress().getRegion())) { sendNotification(user); } } } 위와 같이 구현된 코드는 정말 흔하게 볼 수 있는 코드이지만, 디미터의 법칙을 위반하고 있는 코드이며 객체지향스럽지 못하다. 왜냐하면 우리는 객체에게 메세지를 보내는 것이 아니라 객체가 가지는 자료를 확인하고 있으며, 다른 객체가 어떠한 자료를 갖고 있는지 지나치게 잘 알기 때문이다. 우리는 Getter 메소드를 통해 user객체가 email, name, address를 가지고 있음을 파악할 수 있다. 그렇기에 우리는 위의 코드를 객체 지향스러우며 디미터의 법칙을 준수하도록 수정할 필요가 있다. ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:2:1","tags":["oop"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["개발방법론"],"content":"디미터의 법칙을 준수하는 코드 우리는 Address 객체의 데이터를 통해 사용자의 지역을 파악하는 것이 아니라, Address의 객체에 메세지를 보내서 서울 지역에 사는지 파악하도록 구현해야 한다. public class Address { private String region; private String details; public boolean isSeoulRegion() { return \"서울\".equals(region); } } public class User { private String email; private String name; private Address address; public boolean isSeoulUser() { return address.isSeoulRegion(); } } 위와 같이 객체에게 보내는 메세지를 구현하면 불필요한 @Getter들 역시 지워줄 수 있고, User 객체와 Address 객체가 어떠한 데이터들을 지니고 있는지 모른 채 메세지를 보낼 수 있다. 그리고 기존의 알림을 보내는 로직을 다음과 같이 수정할 수 있다. @Service public class NotificationService { public void sendMessageForSeoulUser(final User user) { if (user.isSeoulUser()) { sendNotification(user); } } } 그리고 새롭게 작성된 코드를 살펴보면, 기존의 user.getAddress().getRegion() 처럼 여러 개의 .(도트)을 사용하여 참조하지 않기 때문에 디미터의 법칙을 잘 준수하고 있다. ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:2:2","tags":["oop"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["개발방법론"],"content":"참고 https://mangkyu.tistory.com/147 ","date":"2022-03-08","objectID":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/:3:0","tags":["oop"],"title":"디미터의 법칙(Law of Demeter)","uri":"/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/"},{"categories":["개발방법론"],"content":"객체지향과 캡슐화 객체는 캡슐화된 상태와 외부에 노출되어 있는 행동을 갖고 있으며, 다른 객체와 메시지를 주고 받으면서 협력한다. 객체는 메시지를 받으면 객체 그에 따른 로직(행동)을 수행하게 되고, 필요하다면 객체 스스로 내부의 상태값도 변경한다. 간단히 말해서 객체지향 프로그래밍은 객체가 스스로 일을 하도록 하는 프로그래밍이다. 상태를 가지는 객체를 추가했다면 객체가 제대로 된 역할을 하도록 구현해야 한다. 즉 객체가 로직을 구현하도록 한다. 상태 데이터를 꺼내 로직을 처리하도록 구현하지 말고 객체에 메시지를 보내 일을 하도록 해야한다. ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:1:0","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["개발방법론"],"content":"캡슐화 예제 ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:2:0","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["개발방법론"],"content":"캡슐화를 위반하는 코드 자동차 경주 게임의 예시 코드를 보자. public class Cars { public static final String DELIMITER = \",\"; public static final int MINIMUM_TEAM = 2; private List\u003cCar\u003e cars; public Cars(String inputNames) { String[] names = inputNames.split(DELIMITER, -1); cars = Arrays.stream(names) .map(name -\u003e new Car(name.trim())) .collect(Collectors.toList()); validateCarNames(); } ... public List\u003cString\u003e findWinners() { final int maximum = cars.stream() .map(car -\u003e car.getPosition()) .max(Integer::compareTo) .get(); return cars.stream() .filter(car -\u003e car.getPosition() == maximum) .map(Car::getName) .collect(Collectors.toList()); } ... } 여러 자동차들 중 position값이 제일 큰 우승 자동차(들)를 구하는 findWinners() 메소드를 살펴보자. Car 객체에서 getPosition() 을 사용해 position 상태값을 직접 꺼내 비교한다. 그러나, Cars에서 position 값을 비교하는 로직을 수행하는 게 맞을까? Car의 접근 제한자가 private인 멤버변수 position 값 끼리 비교하는 로직이다. 따라서 Car 객체에게 position 값을 비교할 또 다른 Car 객체를 넘겨주고 Car끼리 position을 비교해야 한다. Cars가 아니라 Car에서 해야 하는 일인 것이다. ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:2:1","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["개발방법론"],"content":"캡슐화를 준수하는 코드 Car 객체 내에서 같은 자동차끼리 position 값을 비교하고, Car 객체 내에서 maximum 과 일치하는지 비교하도록 Cars의 로직을 Car 안으로 옮기도록 하자. 즉, Car 객체에게 position 값을 비교할 수 있도록 메시지를 보내고, Car 객체에게 maximum 값과 자신의 position 값이 같은지 물어보는 메시지를 보내 getPosition() 을 사용하지 않도록 리팩토링하면 결과는 다음과 같다. public class Car implements Comparable\u003cCar\u003e { ... public boolean isSamePosition(Car other) { return other.position == this.position; } @Override public int compareTo(Car other) { return this.position - other.position; } ... } public class Cars { ... public List\u003cString\u003e findWinners() { final Car maxPositionCar = findMaxPositionCar(); return findSamePositionCars(maxPositionCar); } private Car findMaxPositionCar() { Car maxPositionCar = cars.stream() .max(Car::compareTo) .orElseThrow(() -\u003e new IllegalArgumentException(\"차량 리스트가 비었습니다.\")); } private List\u003cString\u003e findSamePositionCar(Car maxPositionCar) { return cars.stream() .filter(maxPositionCar::isSamePosition) .map(Car::getName) .collect(Collectors.toList()); } } getPosition() 을 없애는 방향으로 리팩토링 한 코드이다. Car에서 Comparable을 상속받아 compareTo()를 구현해 Car내에서 자동차끼리 비교를 해준다. max를 통해 cars 중, 최대 길이의 position을 가진 Car를 찾을 수 있다. 또, isSamePosition()을 구현해 Car 내에서 직접 position 값을 비교할 수 있게 된다. ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:2:2","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["개발방법론"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/ ","date":"2022-03-08","objectID":"/%EC%BA%A1%EC%8A%90%ED%99%94/:3:0","tags":["encapsulation"],"title":"캡슐화","uri":"/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"categories":["java"],"content":"Pure Java, JDK Dynamic Proxy, CGLib Dynamic Proxy를 이용하여 문자열을 대문자로 변환하는 프록시를 구현해보도록 하자. 인터페이스와 타겟 클래스는 다음과 같다. public interface Hello { String sayHello(String name); String sayHi(String name); String sayThankyou(String name); } public class HelloTarget implements Hello { @Override public String sayHello(String name) { return \"Hello \" + name; } @Override public String sayHi(String name) { return \"Hi \" + name; } @Override public String sayThankyou(String name) { return \"Thankyou \" + name; } } 예상 결과는 다음과 같다. HELLO YYOUNGEUN HI YYOUNGEUN THANKYOU YYOUNGEUN ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:0:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Pure Java Proxy public class HelloProxy implements Hello { HelloTarget helloTarget = new HelloTarget(); @Override public String sayHello(String name) { return helloTarget.sayHello(name).toUpperCase(); } @Override public String sayHi(String name) { return helloTarget.sayHi(name).toUpperCase(); } @Override public String sayThankyou(String name) { return helloTarget.sayThankyou(name).toUpperCase(); } } public class Main { public static void main(String[] args) { String name = \"yyoungeun\"; HelloProxy proxy = new HelloProxy(); System.out.println(proxy.sayHello(name)); System.out.println(proxy.sayHi(name)); System.out.println(proxy.sayThankyou(name)); } } 순수 Java Proxy 구현은 인터페이스에 대해서 모든 메서드를 직접 구현해야 하며, 동일한 액션이 있을경우 중복이 발생한다는 문제가 있다. ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:1:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"JDK Dynamic Proxy 다이나믹 프록시는 InvocationHandler를 통해 위의 두 문제를 해결한다. Reflection API를 사용하는 invoke 메서드를 구현 함으로서 proxy를 수행한다. 핵심은 타깃의 인터페이스를 기준으로 Proxy를 생성해준다는 점이다. Spring AOP는 JDK Dynamic Proxy를 기반으로 AOP 기술을 구현하였다. import java.lang.reflect.Proxy; public class Main { public static void main(String[] args) { String name = \"yyoungeun\"; Hello proxy = (Hello) Proxy.newProxyInstance( Main.class.getClassLoader(), new Class[]{Hello.class}, new UpperHandler(new HelloTarget()) ); System.out.println(proxy.sayHello(name)); System.out.println(proxy.sayHi(name)); System.out.println(proxy.sayThankyou(name)); } } 첫 번째 인자: 프록시를 만들 클래스 로더 두 번째 인자: 어떤 인터페이스에 대해 프록시를 만들 것인지 명시 세 번째 인자: InvocationHandler 인터페이스의 구현체 리턴 값: 동적으로 만든 프록시 객체 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; @AllArgsConstructor class UpperHandler implements InvocationHandler { Object target; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object invoke = method.invoke(target, args); if (invoke instanceof String \u0026\u0026 method.getName().startsWith(\"say\")) return ((String) invoke).toUpperCase(); else return invoke; } } InvocationHandler는 invoke()라는 메소드 하나만 가지고 있는 인터페이스이다. invoke() 메소드는 다이나믹하게 생성될 프록시의 메소드가 호출됐을 때 호출되는 메소드로, 여기서 어떤 메소드의 기능을 확장할지 결정할 수 있고, 확장된 기능을 구현할 수 있다. JDK Dynamic Proxy는 Advise 대상이든 아니든 모든 Method Call 마다 reflection API의 invoke를 실시한다는 단점이 있다. 또한 인터페이스 기반의 Proxy이기 때문에 모든 Target Class는 Interface를 implement 하고 있어야 한다는 제약이 있다. ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:2:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"CGLIB(Code Generator Library)을 통한 Dynamic Proxy 실제 바이트 코드를 조작하여 JDK Dynamic Proxy 보다 상대적으로 빠르다. 그러나 final이나 private으로 선언된 경우에는 해당 행위에 대해서 Aspect를 적용할 수 없다. CGLib은 클래스를 상속받아 Proxy를 생성해 주므로 Spring Boot에는 CGLib 방식을 기본 Proxy 생성 방법으로 사용하고 있다. import org.springframework.cglib.proxy.Enhancer; import org.springframework.cglib.proxy.MethodInterceptor; import org.springframework.cglib.proxy.MethodProxy; public class Main { public static void main(String[] args) { String name = \"yyoungeun\"; MethodInterceptor methodInterceptor = new MethodInterceptor() { final HelloTarget helloTarget = new HelloTarget(); @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { Object invoke = method.invoke(helloTarget, args); if (invoke instanceof String \u0026\u0026 method.getName().startsWith(\"say\")) return ((String) invoke).toUpperCase(); else return invoke; } }; Hello proxy = (HelloTarget) Enhancer.create(HelloTarget.class, methodInterceptor); System.out.println(proxy.sayHello(name)); System.out.println(proxy.sayHi(name)); System.out.println(proxy.sayThankyou(name)); } } ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:3:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"참고 https://lob-dev.tistory.com/entry/Java%EC%97%90%EC%84%9C-%EA%B5%AC%ED%98%84%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-Proxy-%EB%93%A4-Pure-JDK-CGLIB https://live-everyday.tistory.com/217 https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html ","date":"2022-03-07","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/:4:0","tags":["dynamic-proxy","cglib"],"title":"자바의 Proxy 구현","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/"},{"categories":["spring"],"content":"Dependency Injection Dependency Injection은 말 그대로 의존성 주입을 말한다. 이는 객체 간의 의존성을 외부에서 주입하여 관리하겠다라는 개념이다. 의존성이 높으면 코드의 재사용성이 떨어지고 변경에 유연하지 못하며 테스트 코드를 작성하기 어려워진다. 외부에서 의존을 주입받으면 의존을 내부에서 정의하지 않기 때문에 객체 간의 의존성을 줄여주고 코드의 재사용성도 증가하며 변화에 민감하지 않을 수 있다. 이때 변화에 민감하다는 말은 객체 자신이 아니라 의존하고 있는 다른 객체의 변경으로부터 민감한 정도를 말한다. 의존의 정도가 작을수록 의존 객체의 변경에 크게 영향을 받지 않는다. 외부에서 의존을 주입받는 방법은 기존에 마치 이전에 내부에서 의존을 관리하는 방법을 뒤바꾼듯한 모양이다. 이를 IoC(Inversion of Control)이라 한다. DI vs IoC IoC는 객체 생명 관리, 흐름 제어를 제 3자에게 위임하는 프로그래밍 모델이다. DI라는 말은 마틴파울러와 그 주변사람들이 객체 주입이라는 의미를 명확히 하기 위해 만들어졌다. 컨테이너차원에서 수많은 객체들에 의존관계를 파악하고 런타임시점에서 다이나믹하게 객체를 주임하여 유연한 프로그래밍을 할 수 있도록 하는 패턴에 더 명확한 이름을 부여하기 위해 토론 끝에 Dependency Injection 이라는 용어를 만들었다. ","date":"2022-03-05","objectID":"/dependency-injection/:1:0","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Dependency Injection의 방법 ","date":"2022-03-05","objectID":"/dependency-injection/:2:0","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Field Injection 가장 흔히 볼 수 있는 Injection 방법으로 사용하기도 간편하고 코드도 읽기 쉽다. @Service public class LineService { @Autowired private LineRepository repository; public LineService() { } } ","date":"2022-03-05","objectID":"/dependency-injection/:2:1","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Setter Injection 이 방식은 Setter/Getter와 같은 접근자 메서드(Accessor)를 최소한으로 해야한다는 원칙과도 어긋나고, 주입받는 객체가 변경될 가능성도 거의 없기에 거의 사용하지 않는다. @Service public class LineService { private LineRepository repository; public LineService() { } @Autowired public void setRepository(LineRepository lineRepository) { this.repository = lineRepository; } } ","date":"2022-03-05","objectID":"/dependency-injection/:2:2","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"Constructor Injection private MemberService memberService; @Autowired public xxxController(MemberService memberService){ ... } 필드가 단 하나뿐이라면 @Autowired 애노테이션이 없어도 자동 주입을 해준다. final 키워드를 활용한 생성자 주입 클래스에 컴포넌트 애노테이션( @Controller, @Service 등도 내부적으로 @Component를 포함하는 메타 애노테이션이다.) 이 있는경우 Bean 등록을 하기 위해서 객체를 생성하는데 final 키워드가 있는 멤버필드가 있다면 생성시점에서 해당 필드들을 모두 주입 해 줘야 하기에 @Autowired 애노테이션이 없더라도 해당 컴포넌트들을 찾아서 주입 해 준다. @Service public class LineService { private final LineRepository repository; public LineService(LineRepository repository) { this.repository = repository; } } ","date":"2022-03-05","objectID":"/dependency-injection/:2:3","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"왜 Constructor Injection을 써야 하는가? 기존에 가장 흔히 사용하는 Field Injection이 아니라 Constructor Injection을 써야 하는 이유는 무엇일까? ","date":"2022-03-05","objectID":"/dependency-injection/:3:0","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"1. 단일 책임의 원칙. Field Injection은 의존성 주입이 너무 쉬우므로 무분별한 의존성을 주입할 수도 있다. 그러면 하나의 클래스에서 지나치게 많은 기능을 하게 될 수 있는 여지가 있고, ‘객체는 그에 맞는 동작만 한다’라는 단일 책임의 원칙이 깨지기 쉽다. Constructor Injection을 사용하면 의존성을 주입해야 하는 대상이 많아질수록 생성자의 인자가 늘어난다. 이는 의존관계의 복잡성을 쉽게 파악할 수 있도록 도와주므로 리팩토링의 실마리를 제공한다. ","date":"2022-03-05","objectID":"/dependency-injection/:3:1","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"2. DI Container와의 낮은 결합도 Field Injection을 사용하면 의존 클래스를 곧바로 인스턴스화 시킬 수 없다. 만약 DI Container 밖의 환경에서 의존성을 주입받는 클래스의 객체를 참조할 때, Dependency를 정의해두는 Reflection을 사용하는 방법 외에는 참조할 방법이 없다. 생성자 또는 Setter가 존재하지 않는다면 의존 객체 필드를 설정할 수 있는 방법이 없기 때문이다. Constructor Injection은 생성자로 의존성을 주입받기 때문에 DI Container에 의존하지 않고 사용할 수 있고, 그 덕분에 테스트에서도 더 용이함을 보인다. ","date":"2022-03-05","objectID":"/dependency-injection/:3:2","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"3. 필드의 불변성 보장 Field Injection은 객체를 생성하고 의존성을 Reflection으로 주입받기 때문에 필드 변수를 Immutable로 선언할 수 없다. Constructor Injection은 필드를 final로 선언할 수 있기 때문에 필드의 변경에 대해 안전하다. 이는 객체의 변경에 따른 비용을 절약할 수 있도록 도와준다. ","date":"2022-03-05","objectID":"/dependency-injection/:3:3","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"4. 순환 의존 방지 Constructor Injection에서는 순환 의존성을 가질 경우 BeanCurrentlyInCreationException이 발생해서 문제 상황을 알 수 있게 해준다. ","date":"2022-03-05","objectID":"/dependency-injection/:3:4","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["spring"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-07-18-di-constuctor-injection/ https://jwchung.github.io/DI%EB%8A%94-IoC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%84%EB%8F%84-%EB%90%9C%EB%8B%A4 ","date":"2022-03-05","objectID":"/dependency-injection/:4:0","tags":["di","ioc"],"title":"Dependency Injection","uri":"/dependency-injection/"},{"categories":["java"],"content":"DTO Data Transfer Object의 약자로 계층(Layer) 간 데이터를 전달하는 객체이다. 조금 더 쉽게 말하면, 데이터를 담아서 전달하는 바구니라고 할 수 있다. Controller는 View와 도메인 Model의 데이터를 주고 받을 때 별도의 DTO 를 주로 사용한다. 도메인 객체를 View에 직접 전달할 수 있지만, 민감한 도메인 비즈니스 기능이 노출될 수 있으며 Model과 View 사이에 의존성이 생기기 때문이다. DTO는 데이터 접근 메서드(Getter, Setter), 생성자 외에 기능을 갖지 않는다. (정렬, 직렬화 등 데이터 표현을 위한 기능은 가질 수 있다.) 데이터의 캡슐화를 통해 유연한 대응이 가능하여 데이터 요청 수의 감소 효과가 있다. ","date":"2022-03-04","objectID":"/dto-vs-vo/:1:0","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"VO Value Object의 약자로 값을 자체로 의미를 갖는 객체이다. 변하지 않는 값을 갖는 객체로 값이 변하지 않음을 보장 하여 코드의 안정성을 높인다. 서로 다른 이름을 가진 VO의 인스턴스가 모든 속성이 같다면 동일한 객체라고 판단한다. 이를 위해 VO 클래스는 equals와 hasCode를 오버라이딩 해야 한다. DTO와 달리 데이터 접근 메서드 이외의 로직을 포함할 수 있다. ","date":"2022-03-04","objectID":"/dto-vs-vo/:2:0","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"공통점과 차이점 ","date":"2022-03-04","objectID":"/dto-vs-vo/:3:0","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"공통점 레이어 간 데이터를 전달할 때 사용 가능하다. ","date":"2022-03-04","objectID":"/dto-vs-vo/:3:1","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"차이점 구분 DTO VO 용도 레이어 간 데이터 전달 값 자체 표현 동등 결정 속성값이 모두 같다고 해서 같은 객체 X 속성값이 모두 같으면 같은 객체 가변/불변 setter존재 시, 가변 setter 비 존재 시 불변 불변 로직 데이터 접근(getter, setter) 이외의 기능을 갖지 않음 데이터 접근 이외의 특정한 비즈니스 로직을 가질 수 있음 ","date":"2022-03-04","objectID":"/dto-vs-vo/:3:2","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"출처 https://backtony.github.io/interview/2021-11-13-interview-3/ ","date":"2022-03-04","objectID":"/dto-vs-vo/:4:0","tags":["dto","vo"],"title":"DTO vs VO","uri":"/dto-vs-vo/"},{"categories":["java"],"content":"volatile란? volatile 키워드는 java 변수를 Main Memory에 저장하겠다라는 것을 명시한다. 즉 매번 변수의 값을 읽을 때마다 CPU cache에 저장된 값이 아닌 Main Memory에서 읽는 것이다. 또한 변수의 값을 쓸 때마다 Main Memory까지 작성한다. ","date":"2022-03-03","objectID":"/volatile/:1:0","tags":["volatile"],"title":"volatile","uri":"/volatile/"},{"categories":["java"],"content":"volatile 키워드의 필요성 멀티쓰레드 어플리케이션에서의 non-volatile 변수에 대한 작업은 성능상의 이유로 CPU 캐시를 이용한다. 둘 이상의 CPU가 탑재된 컴퓨터에서 어플리케이션을 실행한다면, 각 쓰레드는 변수를 각 CPU의 캐시로 복사하여 읽어들인다. 쓰레드가 변경한 값이 메인 메모리에 저장되지 않아서 다른 쓰레드가 이 값을 볼 수 없는 상황을 ‘가시성’ 문제라 한다. 한 쓰레드의 변경(update)이 다른 쓰레드에게 보이지 않는다. 변수에 volatile 키워드를 선언한다면 이 변수에 대한 쓰기 작업은 즉각 메인 메모리로 이루어질 것이고, 읽기 작업 또한 메인 메모리로부터 다이렉트로 이루어질 것이다. 따라서 가시성 문제가 해결된다. ","date":"2022-03-03","objectID":"/volatile/:2:0","tags":["volatile"],"title":"volatile","uri":"/volatile/"},{"categories":["java"],"content":"volatile 사용 시 주의할 점 한 변수를 두고 오직 한 쓰레드만 이 변수에 읽기/쓰기 작업을 하고, 다른 쓰레드들은 읽기 작업만 하는 상황에서라면 이 때는 volatile 선언이 유효하다. 읽기 작업을 수행하는 쓰레드들은 언제나 이 변수의 가장 최근 수정된 값을 봐야하고, volatile 은 이를 보장해준다. 그러나 하나의 Thread가 아닌 여러 Thread가 write하는 상황에서는 적합하지 않다. 여러 Thread가 write하는 상황이라면 synchronized를 통해 변수 read \u0026 write의 원자성(atomic)을 보장해야 한다. volatile 변수의 읽기/쓰기는 메인 메모리를 이용한다. 메인 메모리로부터 데이터를 읽고 쓰는 작업은 CPU 캐시를 이용하는 것 보다 많은 비용이 요구된다. 따라서 변수 값 일치을 보장해야 하는 경우에만 volatile 사용하는 것이 좋다. volatile 선언은 JVM 의 성능 향상을 위한 기술인 코드 재정리를 막기도 한다. 그러므로 volatile 키워드는 변수의 가시성 보장이 반드시 필요한 경우에만 사용되어야 한다. ","date":"2022-03-03","objectID":"/volatile/:3:0","tags":["volatile"],"title":"volatile","uri":"/volatile/"},{"categories":["java"],"content":"출처 https://junghyungil.tistory.com/99 ","date":"2022-03-03","objectID":"/volatile/:4:0","tags":["volatile"],"title":"volatile","uri":"/volatile/"},{"categories":["java"],"content":"싱글톤 패턴은 프로세스(Java에서는 JVM) 내에 1개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역 접근점을 제공하는 패턴이다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:0:0","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Eager Initialization 싱글톤 패턴을 가장 단순하게 구현하는 방법은 외부에서 해당 클래스의 인스턴스를 생성할 수 없도록 private 생성자를 만들고, 1개의 인스턴스만을 초기화(public static final)하여 이에 대한 접근을 제공하는 방식이다. public class SimpleSingleton { //public static final으로 1개의 인스턴스만을 초기화하여 접근점을 제공하고, 2개 이상의 인스턴스를 못 만들게 한다. public static final SimpleSingleton INSTANCE = new SimpleSingleton(); private SimpleSingleton(){ //생성자는 private으로 만들어 외부에서 새로운 인스턴스를 만들 수 없도록 한다. } } static 필드와 메소드를 가지지 않는 Eager Initialization 방식의 Singleton의 경우 Class.forName()과 같은 메소드를 호출하지 않는 한, Eager Initialization 방식을 써도 INSTANCE에 접근하지 않는 한 객체 초기화가 발생하지 않는다. Java에서 Class가 Loading되는 경우는 아래와 같다. new를 통한 초기화 class.forName()과 함께 Reflection을 사용하는 경우 해당 클래스의 static 메소드가 실행된 경우 해당 클래스의 static 필드에 값을 할당 혹은 사용하는 경우(단, static final 제외) Top-Level Class인데, assert 문을 사용하는 경우 이 중 첫번째(new는 private method로 막아두었음)와 마지막 케이스를 제외한 세 가지 경우에 대해 ClassLoading이 발생하고 Singleton 객체가 초기화되는지 확인해보자. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:0","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"class.forName()과 함께 Reflection을 사용하는 경우 Singleton.java public class Singleton { public static final Singleton INSTANCE = new Singleton(); private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Class.forName(\"com.leeyh0216.test.Singleton\"); } } 실행 결과 Hello world Simple singleton instance initialized. 위 Test 클래스에서는 Class.forName 메서드를 통해 강제로 ClassLoading을 유발한다. 따라서 Singleton 객체가 초기화되며 “Simple singleton instance initialized” 메시지가 출력된다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:1","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"해당 클래스의 static 메소드가 실행된 경우 Singleton.java public class Singleton { public static final Singleton INSTANCE = new Singleton(); private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } public static void func() { System.out.println(\"This is static method\"); } public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Singleton.func(); } } 실행 결과 Hello world Simple singleton instance initialized. This is static method 위 Test 클래스에서는 Singleton 클래스의 정적 메소드인 func를 호출한다. 정적 메소드 호출 시에는 ClassLoading이 발생하기 때문에 func 메소드 실행 전에 Singleton 객체가 초기화되며 “Simple singleton instance initialized” 메시지가 호출되는 것을 확인할 수 있다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:2","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"해당 클래스의 static 필드의 값을 할당 혹은 사용하는 경우 Singleton.java public class Singleton { public static final Singleton INSTANCE = new Singleton(); public static int VALUE = 1; private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } } Test.java(할당) public class Test { public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Singleton.VALUE = 2; } } 실행 결과 Hello world Simple singleton instance initialized. Test.java(사용) public class Test { public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); System.out.println(Singleton.VALUE); } } 실행 결과 Hello world Simple singleton instance initialized. 1 위 두 케이스 모두 ClassLoading이 발생한다. 다만, VALUE를 final로 지정하여 상수로 만드는 경우는 ClassLoading이 발생하지 않는다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:1:3","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Lazy Initialization Singleton의 static 필드나 메소드를 사용해야 하지만, 싱글톤 객체는 초기화시키지 않고 싶은 경우가 있을 수 있다. 이러한 경우에는 Lazy Initialization 방식을 사용할 수 있다. Lazy Initialization 방식은 Singleton 객체가 필요한 경우에만 이를 초기화(초기화되어 있지 않은 경우에만)하고, Singleton 객체를 반환받을 수 있는 진입점(static 메소드)를 제공하는 방식이다. Singleton.java public class Singleton { public static Singleton INSTANCE; private Singleton() { System.out.println(\"Simple singleton instance initialized.\"); } public static Singleton getInstance(){ if(INSTANCE == null) INSTANCE = new Singleton(); return INSTANCE; } public static void main(String[] args) throws Exception { System.out.println(\"Hello world\"); Singleton singleton = Singleton.getInstance(); } } 실행 결과 Hello world Simple singleton instance initialized. 명시적으로 getInstance 메소드를 호출하지 않는 이상 Singleton 객체(INSTANCE)가 초기화되지 않기 때문에, Eager Initialization 방식의 단점을 보완할 수 있다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:2:0","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Multi Thread 환경에서의 문제점 Lazy Initialization 방식은 Multi Thread 환경에서의 문제점을 가지고 있다. Multi Thread 환경에서 서로 다른 Thread들이 동시에 getInstance를 호출한다고 생각해보자. 위의 getInstance는 Multi Thread 환경에 대한 고려가 되어 있지 않기 떄문에, if(INSTANCE == null)이 여러번 참인 경우가 발생하여 여러 개의 객체가 생성될 수 있다. Singleton.java public class Singleton { public static final AtomicInteger NUM_INSTANCE = new AtomicInteger(0); private static Singleton INSTANCE; private Singleton() { System.out.println(\"Constructor called\"); } public static Singleton getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton(); NUM_INSTANCE.incrementAndGet(); } return INSTANCE; } public static int getNumberOfInstance() { return NUM_INSTANCE.get(); } public static void main(String[] args) throws Exception { Thread[] threads = new Thread[1000]; for (int i = 0; i \u003c threads.length; i++) { threads[i] = new Thread(new Runnable() { public void run() { Singleton.getInstance(); } }); } for (int i = 0; i \u003c threads.length; i++) { threads[i].start(); } for (int i = 0; i \u003c threads.length; i++) { threads[i].join(); } System.out.println(Singleton.getNumberOfInstance()); } } 실행 결과 Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called Constructor called 24 ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:2:1","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Multi Thread 환경에서 Lazy Initialization 방법 Multi Thread 환경에서 Singleton 객체를 Lazy Initialization하는 몇가지 방법을 소개한다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:3:0","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"정적 팩터리 메서드에 동기화 키워드 사용하기 Singleton 객체를 생성하는 정적 팩터리 메서드 자체에 synchronized를 붙여주거나, 내부 초기화 구문을 synchronized 구문으로 감싸주는 방법이 있다. 정적 팩터리 메서드 자체에 synchronized 붙이기 기존의 public static Singleton getInstance() 를 public static synchronized Singleton getInstance()와 같이 바꾸는 방법이다. 내부 초기화 구문을 synchronized로 감싸주기 초기화에 사용할 Lock 객체를 만들고, Singleton 객체의 초기화 여부 확인 시 동기화하는 방법이다. private static Object lock = new Object(); public static Singleton getInstance() { synchronized (lock) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } return INSTANCE; } 동기화 방식은 Multi Thread 환경에서 객체를 안전하게 1개를 생성할 수 있지만, 객체 획득 시의 병렬성을 잃어버린다는 단점이 존재한다. 또한 초기 호출 이후에는 객체 초기화 확인 구문(if(INSTANCE) == null))이 계속해서 참을 반환하기 때문에 불필요한 Lock을 거는 상황이 발생하게 된다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:3:1","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"DCL(Double-Checked-Locking) 방식 사용하기 Multi Thread 환경에서 병렬성을 확보하기 위해서는 동기화 구문을 필요한 곳에서만 사용해야 한다. DCL 방식은 동기화를 최소화하므로써 위의 방식의 단점(불필요한 Lock을 거는)을 없앤 방식이다. private static Object lock = new Object(); public static Singleton getInstance() { if (INSTANCE == null) { synchronized (lock) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } } return INSTANCE; } 첫번째 if문을 통해 객체가 초기화되었는지 검사할 때는 동기화를 하지 않고, 두번째 if문을 통해 객체가 초기화되었는지 검사할 때는 동기화를 수행한다. getInstance 호출 후 충분한 시간이 지나 동기화가 필요 없을 때는 첫번째 if문만 실행하므로써 동기화에 따른 병렬성 감소를 감소시킬 수 있는 방식이다. 언뜻 보기에는 동기화 문제도 없고 성능적으로 뛰어난 방식이라고 생각할 수 있다. 그러나 위 코드는 문제점을 가지고 있다. 위 DCL 코드의 문제점과 해결 위 DCL 코드는 JVM의 Low-Level 동작 방식때문에 문제가 발생한다. 예를 들어 2개의 Thread(A, B)가 getInstance를 호출했다고 생각해보자. Thread A는 INSTANCE = new Singleton() 구문을 수행하고 있고, 이 때 Thread B는 첫번째 if문에서 INSTANCE의 초기화 여부를 검사(if(INSTANCE == null))하고 있다. 여기서 Thread A가 수행하는 ‘객체 생성’과 ‘변수 할당’ 구문은 한번에 실행되지 않고, 특정 시점에는 INSTANCE에는 일부만 초기화된 객체가 할당되어 있을 수 있다. 이 때 Thread B는 non-null check만 하기 때문에 일부만 초기화된 객체를 가져다 쓰게 되어 Crash가 발생할 수 있다. 이러한 문제점을 해결하기 위해서는 INSTANCE 객체에 volatile 키워드를 붙여주는 것이다. volatile은 원자적으로 동작하기 때문에 첫번째 if문이 완전히 초기화된 객체를 얻거나 아닌 경우 둘 중 하나로 동작하게 된다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:3:2","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"Lazy Holder 방식 사용하기 Multi Thread 환경에서도 잘 동작하고, Lazy Initialization도 가능한 방식이다. public class LazySingletonHolder { public static Singleton getInstance() { return Singleton.INSTANCE; } public static class Singleton { private static final Singleton INSTANCE = new Singleton(); private Singleton() { } } } 위 코드를 보면 ‘Lazy Initialization 방식이 아니지 않은가?’ 라고 생각할 수 있다. LazySingletonHolder의 getInstance에서 Singleton 클래스의 INSTANCE를 그대로 반환하기 때문이다. 그러나 Singleton 클래스의 INSTANCE는 Singleton 클래스의 클래스 로딩이 일어날 때 발생하게 되고, 이는 LazySingletonHolder의 getInstance가 호출되었을 때이다. 또한 INSTANCE는 static final 이기 때문에 클래스 로딩에 의해 1회만 초기화되고, 이로써 Multi Thread 환경에서의 문제점도 없어지게 된다. ","date":"2022-03-03","objectID":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/:3:3","tags":["singleton","volatile"],"title":"싱글톤 패턴 구현","uri":"/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/"},{"categories":["java"],"content":"각 자료구조는 필요에 따라 선택되고 활용된다. Map 인터페이스의 구현체로는 HashMap, HashTable, ConcurrentHashMap 등이 있다. Map 인터페이스를 구현하면, \u003cKey, Value\u003e 형태를 띈다. 그렇다면 이 셋은 무슨 특징을 가지고, 서로 어떤 차이가 있을까? 이번 글에서 해당 구현체를 비교하며 확인해보자. ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:0:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"HashMap key와 value에 null을 허용한다. 동기화를 보장하지 않는다. HashMap은 thread-safe하지 않아, 싱글 쓰레드 환경에서 사용하는 게 좋다. 한편, 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다. 결국 HashTable과 ConcurrentHashMap보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어진다. public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable { ... public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u003e= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:1:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"HashTable key와 value에 null을 허용하지 않는다. 동기화를 보장한다. HashTable은 thread-safe하기 때문에, 멀티 쓰레드 환경에서 사용할 수 있다. 이는 데이터를 다루는 메소드(get(), put(), remove() 등)에 synchronized 키워드가 붙어 있다. 해당 키워드는 메소드를 호출하기 전에 쓰레드간 동기화 락을 건다. 그래서 멀티 쓰레드 환경에서도 데이터의 무결성을 보장한다. 그러나, 쓰레드간 동기화 락은 매우 느린 동작이라는 단점이 있다. public class Hashtable\u003cK,V\u003e extends Dictionary\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, java.io.Serializable { ... public synchronized V put(K key, V value) { if (value == null) { throw new NullPointerException(); } Entry\u003c?,?\u003e tab[] = table; int hash = key.hashCode(); int index = (hash \u0026 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry\u003cK,V\u003e entry = (Entry\u003cK,V\u003e)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) \u0026\u0026 entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } addEntry(hash, key, value, index); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:2:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"ConcurrentHashMap key와 value에 null을 허용하지 않는다. 동기화를 보장한다. ConcurrentHashMap은 thread-safe하기 때문에, 멀티 쓰레드 환경에서 사용할 수 있다. 이 구현체는 HashMap의 동기화 문제를 보완하기 위해 나타났다. 동기화 처리를 할 때, 어떤 Entry를 조작하는 경우에 해당 Entry에 대해서만 락을 건다. 그래서 HashTable보다 데이터를 다루는 속도가 빠르다. 즉, Entry 아이템별로 락을 걸어 멀티 쓰레드 환경에서의 성능을 향상시킨다. public class ConcurrentHashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements ConcurrentMap\u003cK,V\u003e, Serializable { ... public V put(K key, V value) { return putVal(key, value, false); } final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) { throw new NullPointerException(); } int hash = spread(key.hashCode()); int binCount = 0; for (Node\u003cK,V\u003e[] tab = table;;) { Node\u003cK,V\u003e f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) { if (casTabAt(tab, i, null, new Node\u003cK,V\u003e(hash, key, value, null))) break; } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh \u003e= 0) { binCount = 1; for (Node\u003cK,V\u003e e = f;; ++binCount) { K ek; if (e.hash == hash \u0026\u0026 ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node\u003cK,V\u003e pred = e; if ((e = e.next) == null) { pred.next = new Node\u003cK,V\u003e(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { Node\u003cK,V\u003e p; binCount = 2; if ((p = ((TreeBin\u003cK,V\u003e)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { if (binCount \u003e= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null; } ... } ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:3:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"정리 HashMap HashTable ConcurrentHashMap key와 value에 null 허용 O X X 동기화 보장(Thread-safe) X O O 추천 환경 싱글 쓰레드 멀티 쓰레드 멀티 쓰레드 ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:4:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"결론 싱글 쓰레드 환경이면 HashMap을, 멀티 쓰레드 환경이면 HashTable이 아닌 ConcurrentHashMap을 쓰자. 그 이유는 HashTable보다 ConcurrentHashMap이 성능적으로 우수하기 때문이다. 앞에서도 언급했듯이 HashTable은 쓰레드간 락을 걸어 데이터를 다루는 속도가 느리다. 반면, ConcurrentHashMap은 Entry 아이템별로 락을 걸어 데이터를 다루는 속도가 빠르다. ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:5:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-11-26-hashmap-hashtable-concurrenthashmap/ ","date":"2022-03-03","objectID":"/hashmap-vs-hashtable-vs-concurrenthashmap/:6:0","tags":["hashmap","hashtable","concurrent-hashmap"],"title":"HashMap vs HashTable vs ConcurrentHashMap","uri":"/hashmap-vs-hashtable-vs-concurrenthashmap/"},{"categories":["java"],"content":"Reflection API란? 아래와 같이 Car 클래스가 존재한다. public class Car { private final String name; private int position; public Car(String name, int position) { this.name = name; this.position = position; } public void move() { this.position++; } public int getPosition() { return position; } } 자바의 특징 중 하나인 다형성 덕분에 아래와 같이 객체 생성이 가능하다. public static void main(String[] args) { Object obj = new Car(\"foo\", 0); } 자바는 컴파일러를 사용한다. 즉 컴파일 타임에 타입이 결정된다. obj라는 이름의 객체는 컴파일 타임에 Object로 타입이 결정됐기 때문에 Object 클래스의 인스턴스 변수와 메서드만 사용할 수 있다. 따라서 obj라는 이름의 객체는 Car 클래스의 move 메서드를 사용할 수 없다. 그러므로 아래와 같은 코드는 필연적으로 컴파일 에러가 난다. public static void main(String[] args) { Object obj = new Car(\"foo\", 0); obj.move(); // 컴파일 에러 발생 java: cannot find symbol } 생성된 obj라는 객체는 Object 클래스라는 타입만 알 뿐, Car 클래스라는 구체적인 타입은 모른다. 결국 컴파일러가 있는 자바는 구체적인 클래스를 모르면 해당 클래스의 정보에 접근할 수 없다는 것을 알 수 있다. Reflection API는 이렇게 불가능한 일을 마법처럼 가능하게 해준다. 위에서 봤던 예제와 똑같은 상황에서 Reflection API를 활용해 Car 클래스의 move 메서드를 호출해보자. public static void main(String[] args) throws Exception { Object obj = new Car(\"foo\", 0); Class carClass = Car.class; Method move = carClass.getMethod(\"move\"); // move 메서드 실행, invoke(메서드를 실행시킬 객체, 해당 메서드에 넘길 인자) move.invoke(obj, null); Method getPosition = carClass.getMethod(\"getPosition\"); int position = (int)getPosition.invoke(obj, null); System.out.println(position); // 출력 결과: 1 } move 메서드가 실행되고 0으로 초기화했던 Car 클래스 인스턴스 변수 position이 1로 출력되는 걸 확인할 수 있다. 구체적인 클래스 Car 타입을 알지 못해도 Reflection API를 통해 move 메서드에 접근한 것이다. Class carClass2 = Class.forName(\"Car\"); 위의 예제처럼 클래스의 이름만으로도 해당 클래스의 정보를 가져올 수 있다. 다시 말해서 Reflection API를 통해 클래스의 이름만 가지고도 생성자, 필드, 메서드 등등 해당 클래스에 대한 거의 모든 정보를 가져올 수 있다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:1:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Reflection은 어떻게 가능할까? JVM이 실행되면 사용자가 작성한 자바 코드가 컴파일러를 거쳐 바이트 코드로 변환되어 Runtime Data Area에 저장된다. Reflection API는 Runtime Data Area에 저장된 정보를 활용한다. 그래서 클래스 이름만 알고 있다면 언제든 정보를 가져올 수 있는 것이다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:2:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Reflection을 어디에 활용할 수 있을까? 위에서 살펴봤던 예제 코드를 보면 멀쩡한 Car 객체를 Object 타입으로 생성하고 있다. 실제로 우리가 코드를 작성할 때는 예제와 같이 작성하지 않는다. 그러므로 우리가 코드를 작성하면서 Reflection을 활용할 일은 거의 없다. 구체적인 클래스를 모를 일이 거의 없기 때문이다. 게다가 Reflection은 마법 같은 힘을 가지고 있는 만큼 치명적인 단점들을 가지고 있다. 당연히 사용하지 않을 수 있다면 대부분의 경우 사용하지 않는 게 좋다. 치명적인 단점 중 대표적으로 성능 오버헤드가 있다. 컴파일 타임이 아닌 런타임에 동적으로 타입을 분석하고 정보를 가져오므로 JVM을 최적화할 수 없기 때문이다. 뿐만 아니라 직접 접근할 수 없는 private 인스턴스 변수, 메서드에 접근하기 때문에 내부를 노출하면서 추상화가 깨진다. 이로 인해 예기치 못한 부작용이 발생할 수 있다. 결론적으로 Reflection은 애플리케이션 개발보다는 프레임워크나 라이브러리에서 많이 사용된다. 프레임워크나 라이브러리는 사용자가 어떤 클래스를 만들지 예측할 수 없기 때문에 동적으로 해결해주기 위해 Reflection을 사용한다. 실제로 intellij의 자동완성, jackson 라이브러리, Hibernate 등등 많은 프레임워크나 라이브러리에서 Reflection을 사용하고 있다. Spring Framework에서도 Reflection API를 사용하는데 대표적으로 Spring Container의 BeanFactory가 있다. Bean은 애플리케이션이 실행한 후 런타임에 객체가 호출될 때 동적으로 객체의 인스턴스를 생성하는데 이때 Spring Container의 BeanFactory에서 리플렉션을 사용한다. Spring Data JPA 에서 Entity에 기본 생성자가 필요한 이유도 동적으로 객체 생성 시 Reflection API를 활용하기 때문이다. Reflection API로 가져올 수 없는 정보 중 하나가 생성자의 인자 정보이다. 그래서 기본 생성자가 반드시 있어야 객체를 생성할 수 있는 것이다. 기본 생성자로 객체를 생성만 하면 필드 값 등은 Reflection API로 넣어줄 수 있다. ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:3:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-07-16-reflection-api/ ","date":"2022-03-02","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/:4:0","tags":["reflection"],"title":"자바의 Reflection","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/"},{"categories":["java"],"content":"Garbage Collection Garbage Collection, GC는 JVM 상에서 더 이상 사용되지 않는 데이터가 할당되어있는 메모리를 해제시키는 작업이다. JVM에서 자동으로 동작하기 때문에 특별한 경우가 아니면 메모리 관리를 개발자가 직접 해줄 필요가 없다. 참조되고 있는지에 대한 개념을 reachability라고 하고, 유효한 참조를 reachable, 유효하지 않은 참조를 unreachable이라고 한다. Garbace Collector는 unreachable 한 객체들을 garbage라고 인식한다. Heap 영역 내부의 객체들은 Method Area, Stack, Native Stack에서 참조되면 reachable로 판정된다. 이렇게 reachable로 인식되게 만들어주는 JVM Runtime Area들을 root set 이라고 한다. reachable 객체가 이 참조하고 있는 다른 객체는 reachable이 된다. 반면에 root set에의해 참조되고 있지 않은 객체들은 unreachable로 판정이 되어 GC 의 대상이 된다. ","date":"2022-03-01","objectID":"/garbage-collection/:1:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Stop-The-World JVM 은 GC를 통해 여유 메모리를 확보할 수가 있다. 하지만 빈번한 GC는 프로그램의 성능을 저하시킨다. GC가 일어나면 GC를 담당하는 쓰레드를 제외한 모든 쓰레드들은 작동이 일시적으로 정지되게 되며, 이를 Stop-The-World 현상이라고 한다. 따라서 적절한 빈도의 GC가 실행되도록 하여 Stop-The-World 시간을 줄여 쓰레드가 정지되는 시간을 줄이는 것이 중요하다. ","date":"2022-03-01","objectID":"/garbage-collection/:2:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"GC 알고리즘 ","date":"2022-03-01","objectID":"/garbage-collection/:3:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Weak Generational Hypothesis Weak Generational Hypothesis 가설은 대부분의 객체는 빠르게 unreachable 한 상태로 전환이 된다고 본다. 또한, Heap 메모리 영역 기준으로 오래된 영역에서 최신 영역으로의 참조는 적게 존재한다고 가정한다. 실제로 이 가설은 여러 관찰을 통해서 높은 경향성을 가지는 것으로 증명이 되었다. ","date":"2022-03-01","objectID":"/garbage-collection/:3:1","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Mark And Sweep Algorithm 가장 기본적인 알고리즘이다. root set으로부터 출발하여, 참조되는 객체들에 대해서 마크를 한다. 이 단계를 Mark Phase라고 한다. 이후에는 마크되지 않은 객체들을 추적하여 삭제한다. 삭제하는 단계를 Sweep Phase 라고 한다. Mark And Sweep 알고리즘은 메모리가 단편화되는 단점이 있다. 메모리에서의 단편화는 데이터가 정렬되지 않은 조각으로 나뉘어져 절대적인 크기는 충분하지만 추가적으로 메모리 할당이 되기 힘든 상태를 의미한다. ","date":"2022-03-01","objectID":"/garbage-collection/:3:2","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Mark And Compact Algorithm Mark And Compact 알고리즘은 Mark And Sweep 알고리즘처럼 참조되는 객체들에 대해서 마크를 하고, 참조되지 않으면 삭제한다. 이후에 메모리를 정리하여 메모리 단편화를 해결한다. 많은 GC 방식들이 Mark And Compact 알고리즘을 바탕으로 하여 구현되어 있다. ","date":"2022-03-01","objectID":"/garbage-collection/:3:3","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Major GC 와 Minor GC ","date":"2022-03-01","objectID":"/garbage-collection/:4:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Heap의 세부 영역 Heap은 Eden, Survivor0, Survivor1, Old , Perm 으로 나누어진다. Young Gen 이라고 불리는 비교적 신생 데이터 부분은 Eden, Survivor0, Survivor1이다. Eden에는 new 키워드를 통해 새롭게 생성된 인스턴스가 위치하며, 이후에는 Survivor로 이동하게 된다. ","date":"2022-03-01","objectID":"/garbage-collection/:4:1","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Minor GC Minor GC 는 JVM 의 Young 영역에서 일어나는 GC이다. Young 에 위치한 각각의 영역이 가득 차게 되어 더 이상 새로운 객체를 생성할 수 없을 때 마크된 영역이 다음 영역으로 복사가 되면서 이루어진다. 마크가 된 영역만 복사되기 때문에 삭제는 이루어지지 않는다. ","date":"2022-03-01","objectID":"/garbage-collection/:4:2","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Major GC Major GC 는 Old 영역에서 이루어진다. 상당히 긴 시간 Stop-The-World 가 이루어지며, 이는 Java 프로그램에 영향을 준다. 이를 해결하기 위해서 여러 GC 방식들이 선택 및 적용된다. ","date":"2022-03-01","objectID":"/garbage-collection/:4:3","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"G1 GC G1 GC의 핵심은 Heap을 동일한 크기의 Region으로 나누고, 가비지가 많은 Region에 대해 우선적으로 GC를 수행하는 것이다. 그리고 G1 GC도 다른 가비지 컬렉션과 마찬가지로 2가지 GC(Minor GC, Major GC)로 나누어 수행된다. ","date":"2022-03-01","objectID":"/garbage-collection/:5:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Minor GC 한 지역에 객체를 할당하다가 해당 지역이 꽉 차면 다른 지역에 객체를 할당하고, Minor GC가 실행된다. G1 GC는 각 지역을 추적하고 있기 때문에, 가비지가 가장 많은(Garbage First) 지역을 찾아서 Mark and Sweep를 수행한다. Eden 지역에서 GC가 수행되면 살아남은 객체를 식별(Mark)하고, 메모리를 회수(Sweep)한다. 그리고 살아남은 객체를 다른 지역으로 이동시키게 된다. 복제되는 지역이 Available/Unused 지역이면 해당 지역은 이제 Survivor 영역이 되고, Eden 영역은 Available/Unused 지역이 된다. ","date":"2022-03-01","objectID":"/garbage-collection/:5:1","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"Major GC(Full GC) 시스템이 계속 운영되다가 객체가 너무 많아 빠르게 메모리를 회수 할 수 없을 때 Major GC(Full GC)가 실행된다. 그리고 여기서 G1 GC와 다른 GC의 차이점이 두각을 보인다. 기존의 다른 GC 알고리즘은 모든 Heap의 영역에서 GC가 수행되었으며, 그에 따라 처리 시간이 상당히 오래 걸렸다. 하지만 G1 GC는 어느 영역에 가비지가 많은지를 알고 있기 때문에 GC를 수행할 지역을 조합하여 해당 지역에 대해서만 GC를 수행한다. 그리고 이러한 작업은 Concurrent하게 수행되기 때문에 애플리케이션의 지연도 최소화할 수 있다. G1 GC는 어떠한 GC 방식보다 처리 속도가 빠르며 큰 메모리 공간에서 멀티 프로세스 기반으로 운영되는 애플리케이션을 위해 고안되었다. 또한 G1 GC는 다른 GC 방식의 처리속도를 능가하기 때문에 Java9부터 기본 가비지 컬렉터(Default Garbage Collector)로 사용된다. ","date":"2022-03-01","objectID":"/garbage-collection/:5:2","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-08-30-jvm-gc/ ","date":"2022-03-01","objectID":"/garbage-collection/:6:0","tags":["gc"],"title":"Garbage Collection","uri":"/garbage-collection/"},{"categories":["java"],"content":"1. 컴파일 자바 소스 파일(*.java)을 Java Compiler가 JVM이 해석할 수 있는 파일인 Java ByteCode (*.class)파일로 변환한다. Java Compiler는 Java 설치 시 Javac.exe라는 실행 파일 형태로 존재한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:1:0","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"2. Class Loader를 통해 ByteCode를 메모리(Runtime Data Area)에 배치 ClassLoader는 크게 Loading, Linking, 그리고 Initialization 3가지 역할을 한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:0","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"Loading .class 확장자를 가진 클래스 파일은 각 디렉터리에 흩어져 있다. 또한, 기본적인 라이브러리의 클래스 파일들은 $JAVAHOME_ 내부 경로에 존재한다. 각각의 클래스 파일들을 찾아서 JVM 의 메모리에 탑재해주는 역할을 하는 것이 ClassLoader의 역할이다. 클래스 로더는 .class 파일을 읽어 바이트 코드를 Runtime Data Area의 메소드 영역(Method Area)에 저장한다. 각 .class 파일은 JVM에 의해 메소드 영역에 다음의 정보들을 저장한다. 로드된 클래스를 비롯한 그의 부모 클래스의 정보 class 파일이 Class, Interface, Enum와 관련 여부 변수나 메소드의 정보 등 .class 파일이 로딩된 후에는, JVM은 힙 메모리 영역에 이 파일이 나타내는 클래스 유형의 객체를 생성한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:1","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"Linking Linking 은 로드된 클래스 파일들을 검증하고, 사용할 수 있게 준비하는 과정을 의미한다. Verification, Preparation, 그리고 Resolution이라는 세 가지 단계로 이루어진다. Verification : 클래스 파일이 유효한지를 확인하는 과정이다. 클래스 파일이 JVM 의 구동 조건대로 구현되지 않았을 경우에는 VerifyError를 던지게 된다. Preparation : 클래스 및 인터페이스에 필요한 static field 메모리를 할당하고, 이를 기본값으로 초기화한다. 기본값으로 초기화된 static field 값들은 이후 Initialization 과정에서 코드에 작성한 초기값으로 변경된다. Resolution : Symbolic Reference 값을 JVM 의 메모리 구성 요소인 Method Area 의 런타임 환경 풀을 통하여 Direct Reference 라는 메모리 주소 값으로 바꾼다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:2","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"Initialization Initialization 단계에서는 클래스 파일의 코드를 읽고 Java 코드에서의 class와 interface의 값들을 지정한 값들로 초기화한다. 여기에 static field도 포함된다. 이때, JVM 은 멀티 쓰레딩으로 작동을 하며, 같은 시간에 한 번에 초기화를 하는 경우가 있기 때문에 초기화 단계에서도 동시성을 고려해주어야 한다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:2:3","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"3. 실행 시점에 Execution Engine에서 바이트코드를 기계어로 해석 Execution Engine은 Java Native Interface(JNI), Native Method Libraries와 상호작용하며 해석한다. Java Native Interface(JNI) : Native Method Libraries와 상호작용하고 실행에 필요한 네이티브 라이브러리(C, C++)을 제공하는 인터페이스이다. JVM은 C/C++ 라이브러리를 통해 호출할 수 있고, 특정 하드웨어와 관련된 C/C++ 라이브러리로 호출 될 수도 있다. Native Method Libraries : Execution Engine으로 인해 요구되는 네이티브 라이브러리(C,C++)의 모음이다. 해석 방식은 인터프리터 방식 혹은 JIT(Just-In-Time) Compiler 방식이 있다. 인터프리터(Interpreter) : 바이트코드를 한줄씩 해석한다. 단점은 여러번 하나의 메소드를 호출할 경우 매번 해석을 요청해야하기 때문에 비효율적이다. Just-In-Time(JIT) Compiler : 같은 코드를 매번 해석하지 않고 기계어로 번역하면서 캐싱한다. 해당 파일이 다시 기계어로 컴파일 된다면 이전 파일과 비교해서 바뀐 부분은 새롭게 컴파일하고 변동 사항이 없는 부분은 캐싱된 코드를 사용한다. 메소드의 반복 호출을 확인할 때마다 직접 네이티브 코드로 제공함으로써 효율성이 증가된다. ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:3:0","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"참고 https://velog.io/@zayson/%EB%B0%B1%EA%B8%B0%EC%84%A0%EB%8B%98%EA%B3%BC-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-live-study-1%EC%A3%BC%EC%B0%A8-JVM%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80 https://mygumi.tistory.com/115 ","date":"2022-03-01","objectID":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/:4:0","tags":["jvm","class-loader","execution-engine","interpreter","compiler"],"title":"Java 실행 과정","uri":"/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/"},{"categories":["java"],"content":"JVM의 메모리 영역은 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 세분화된다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:0:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"Method Area Method Area 에는 클래스, 인터페이스, 생성자, 메소드, Runtime Constant Pool과 static 변수 등이 저장된다. 이 영역은 JVM 당 하나만 생성이 되며 JVM 의 모든 Thread 들이 Method Area 을 공유한다. JVM 구동 시작 시에 생성이 되며, 종료 시까지 유지된다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:1:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"Heap Heap 영역에는 문자열에 대한 정보를 가진 String Pool 뿐만 아니라 실제 데이터를 가진 인스턴스, 배열 등이 저장된다. JVM 당 하나만 생성이 되고, 해당 영역이 가진 데이터는 모든 Java Stack 영역에서 참조되어 Thread 간 공유가 되므로 동기화를 신경써야 한다. Heap 영역이 가득 차게 되면 OutOfMemoryError이 발생한다. Heap 영역은 GC의 주 대상이다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:2:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"Stack Area 각 Thread 별로 따로 할당되는 영역이다. 각각의 Thread 별로 메모리를 따로 할당하기 때문에 동시성 문제에서 자유롭다. 각 Thread 들은 메소드를 호출할 때마다 Stack에 Frame 이라는 단위를 추가(push)한다. 메소드가 결과를 반환하면 해당 Frame 은 Stack 으로부터 제거(pop)가 된다. Frame 은 메소드에 대한 정보를 가지고 있는 Local Variable, Operand Stack 그리고 Constant Pool Reference로 구성이 되어 있다. Local Variable 은 메소드 안의 지역 변수들을 가지고 있다. Operand Stack은 메소드 내 연산을 위해서, 바이트 코드 명령문들이 들어있는 공간이다. Constant Pool Reference 는 Constant Pool 참조를 위한 공간이다. Java Stack 영역이 가득 차게 되면 StackOverflowError이 발생한다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:3:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"PC(Program Counter) Register Java 에서 Thread 는 각자의 메소드를 실행한다. 이때, Thread 별로 동시에 실행하는 환경이 보장되어야 하므로 최근에 실행한 명령어 주소값을 저장할 공간이 필요한데, 이 부분을 PC Registers 영역이 관리하여 추적한다. Thread 들은 각각 자신만의 PC Registers 를 가지고 있다. 만약 실행했던 메소드가 네이티브하다면 undefined가 기록이 된다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:4:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"Native Method Stack Java 로 작성된 프로그램을 실행하면서, 순수하게 Java 로 구성된 코드만을 사용할 수 없는 시스템의 자원이나 API 가 존재한다. 다른 프로그래밍 언어로 작성된 메소드들을 Native Method 라고 한다. Native Method Stack은 Java로 작성되지 않은 메소드를 다루는 영역이다. C Stacks 라고 부르기도 한다. Native Method가 실행될 경우 Stack에 해당 프레임이 쌓이게 된다. Thread가 생성되면 Native Method Stack도 동일하게 생성된다. ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:5:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["java"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-08-09-jvm-memory/ ","date":"2022-03-01","objectID":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/:6:0","tags":["jvm"],"title":"JVM 의 메모리 영역","uri":"/jvm-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD/"},{"categories":["DB"],"content":"캐시란 cache란 사용자의 입장에서 데이터의 원래 소스보다 더 빠르게 그리고 더 효율적으로 액세스할 수 있는 임시 데이터 저장소를 뜻한다. 대부분의 애플리케이션에서 속도 향상을 위해 cache를 사용하고 있다. 캐시에 데이터나 계산된 결과 값의 복사본을 저장해 둠으로써 전체적인 처리 속도를 향상시킨다. 캐시를 사용하는 경우는 다음과 같다. 데이터에 직접적으로 접근하는 데 걸리는 시간이 오래 걸릴 때 데이터가 잘 변하지 않는 경우 반복적으로 동일한 결과를 돌려주는 경우 (이미지와 썸네일 등) ","date":"2022-02-28","objectID":"/redis/:1:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"Redis란 레디스는 전 세계에서 가장 유명한 caching 솔루션이다. 단순하게 key-value 형태로 저장할 수 있기 때문에 어떤 데이터라도 쉽게 저장할 수 있다. 또한 레디스는 모든 데이터를 메모리에 올려두는 인메모리 데이터 스토어이다. 평균 읽기 및 쓰기 작업 속도가 1밀리 세컨드 미만이니 초당 수백만 건의 작업이 가능하다. ","date":"2022-02-28","objectID":"/redis/:2:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"캐싱 전략 레디스를 cache로 사용할 때 어떻게 배치하는지가 시스템의 성능에 큰 영향을 끼치기 때문에 caching 전략은 데이터의 유형과 해당 데이터에 대한 액세스 패턴을 잘 고려해서 선택해야 한다. ","date":"2022-02-28","objectID":"/redis/:3:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"읽기 전략 Cache-Aside 애플리케이션이 요청을 받으면, 데이터가 캐시에 있는지 먼저 검사를 하며, 그 결과(캐시에 데이터가 로딩되어 있는지 여부)에 따라 다음 액션이 결정된다. 캐시에 데이터가 없다면, 애플리케이션이 캐시에 데이터를 업데이트한다. 캐시에 대한 의존성이 낮으므로, 캐시가 다운되더라도 원천 데이터베이스로 서비스를 계속할 수 있다. 읽기 요청이 많은 경우에 적합하다. Read-Through 캐시 미스 시 데이터베이스와 동기화하는 몫은 캐시에 위임된다. 최초 데이터 로딩은 미스가 나며, 그 때 데이터가 로딩된다. Cache-Aside 전략과 마찬가지로 읽기요청이 많은 경우를 처리하는데 적합하다. 첫 요청의 캐시 미스를 방어해야 한다면 스케쥴 작업 등을 통해 미리 캐시를 warm up시켜놓기도 한다. ","date":"2022-02-28","objectID":"/redis/:3:1","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"쓰기 전략 Write-Around write around 방식은 DB에만 데이터를 저장한다. 일단 모든 데이터는 DB에 저장되고 읽은 데이터만 캐시에 저장된다. 이 경우엔 cahce 내의 데이터와 DB 내의 데이터가 다를 수 있다는 단점이 있다. 데이터가 한 번 쓰여지고, 덜 자주 읽히거나 읽지 않는 상황에서 좋은 성능을 제공한다. 예를들어, 실시간 로그 또는 채팅방 메시지가 있다. Write-Through write-through 전략은 DB에 데이터를 저장할 때 cache에도 함께 저장하는 방법이다. cache는 항상 최신 정보를 가지고 있다는 장점이 있지만 저장할 때마다 두 단계 스텝을 거쳐야 하기 때문에 상대적으로 느리다고 볼 수 있다. 그리고 저장하는 데이터가 재사용되지 않을 수도 있는데 무조건 캐시에 넣어버리기 때문에 이는 일종의 리소스 낭비라고도 볼 수 있다. 따라서 이렇게 데이터를 저장할 때는 몇 분 혹은 몇 시간 동안만 데이터를 보관하겠다는 의미인 expire time을 설정해 주는 것이 좋다. ","date":"2022-02-28","objectID":"/redis/:3:2","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"참고 https://wnsgml972.github.io/database/2020/12/13/Caching/ https://youtu.be/92NizoBL4uA ","date":"2022-02-28","objectID":"/redis/:4:0","tags":["cache"],"title":"Redis","uri":"/redis/"},{"categories":["DB"],"content":"인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 기술이다. 인덱스는 테이블 내 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다. 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:0:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"인덱스 자료구조 ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"Hash Table 해시 테이블은 Key-Value로 이루어진 데이터를 저장하는데 특화된 자료 구조이다. 해시 테이블 기반의 DB Index는 특정 컬럼의 값과 데이터의 위치를 Key-Value로 사용한다. 해시 테이블은 내부에 버켓이라고 하는 배열이 존재한다. 해시 함수를 통해 Key를 고유한 해시 값으로 변환시키는데, 이를 버켓 배열의 인덱스로 사용하며 해당 인덱스에 Value를 저장한다. Key 값으로 Value가 저장되어 있는 위치(주소)를 바로 산출할 수 있기 때문에, 해시 테이블의 평균적인 시간 복잡도는 O(1) 이다. 하지만 해시 함수를 제대로 정의하지 않으면 해시 함수를 통해 산출한 해시 값이 중복되는 해시 충돌이 발생한다. 너무 많은 해시 충돌이 발생하면 검색 성능이 하락해 시간 복잡도가 O(N)에 수렴할 수 있다. Index 자료 구조로 해시 테이블을 사용하는 경우는 매우 제한적이다. 해시 함수는 Key가 조금이라도 다르면 완전히 다른 해시 값을 생성한다. 이러한 해시 테이블을 사용하는 Index의 경우 WHERE 조건의 등호(=) 연산에는 효율이 좋지만, 부등호 연산(\u003e, \u003c)은 부적합하다. 해시 테이블은 내부 데이터들이 정렬되어 있지 않아 탐색이 효율적이지 않다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:1","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"B-Tree B-Tree란 자식 노드가 2개 이상인 트리를 의미한다. 이진검색 트리처럼 각 Key의 왼쪽 자식은 항상 Key보다 작은 값을, 오른쪽 자식은 큰 값을 가진다. B-Tree 기반의 DB Index는 특정 컬럼의 값(Key)에 해당하는 노드에 데이터의 위치(Value)를 저장한다. 각 Node에는 여러개의 Key를 갖고 있고 각 Key에 대응하는 Data도 함께 갖고 있다. Key는 Binary Search와 유사한 형태로 정렬되어 각 Node에 배치된다. Binary Search에서 오른쪽 Child Node의 Key는 자신보다 작고 왼쪽 Child Node의 Key는 자신보다 큰데, B-Tree에서도 각 Key에 대해서 유사한 규칙이 적용된다. B-Tree의 Key-Value 값들은 항상 Key를 기준으로 오름차순 정렬이다. 이로 인해 부등호 연산(\u003e, \u003c)에 대해 해시 테이블보다 효율적인 데이터 탐색이 가능하다. 또한 B-Tree는 균형 트리(Balanced Tree)로서, **최상위 루트 노드에서 리프 노드까지의 거리가 모두 동일하기 때문에 평균 시간 복잡도는 O(logN)**이다. 하나의 Node에 여러개의 Key를 갖는 특성 때문에 용량이 큰 Block 단위로 Data를 Read/Write하는 Disk 환경에서는 Binary Search Tree보다 B-Tree를 이용하는 것이 유리하다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:2","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"B+Tree B+ Tree는 B-Tree를 개량한 자료구조 이다. B-tree처럼 모든 Leaf Node는 동일한 Depth를 갖는다. B-Tree와의 가장 큰 차이점은 Inner Node에는 Key만 저장이 되고 Leaf Node에 Key와 Data를 함께 저장한다는 점이다. Leaf Node에만 Data가 저장되기 때문에 Leaf Node 사이를 Link (Pointer)로 연결하여 B-Tree에 비하여 쉬운 순회가 가능하도록 만든점도 B+ Tree의 특징이다. DB Index 컬럼은 부등호(\u003e, \u003c)를 이용한 순차 검색 연산이 자주 발생한다. B-Tree가 해시 테이블보다 부등호를 이용한 검색 연산 성능이 좋지만, 순차 검색의 경우 중위 순회를 하기 때문에 효율이 좋지 않다. 따라서 MySQL 엔진인 InnoDB는 B-Tree를 확장 및 개선한 B+Tree를 Index의 자료 구조로 사용한다. B+Tree에서 말단의 리프 노드들끼리는 LinkedList 구조로 서로를 참조하고 있다. 따라서 부등호(\u003e, \u003c)를 이용한 순차 검색 연산을 하는 경우, 많은 노드를 방문해야 하는 B-Tree에 비해 B+Tree는 말단 리프 노드를 저장한 LinkedList를 한 번만 탐색하는 등 속도 이점이 있다. B+ Tree의 Inner Node는 Data가 없기 때문에 B-Tree의 Inner Node에 비하여 용량작다. 하나의 Disk Block에 더 많은 Inner Node를 배치 할 수 있게 되어, Key 탐색시 B-Tree에 비하여 상대적으로 적은 Disk Block만 읽어도 된다. 이러한 이점 때문에 일반적으로 B+ Tree는 Key 탐색시 B-Tree보다 좀더 나은 성능을 보여준다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:1:3","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"인덱스의 종류 ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:2:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"클러스터형 인덱스(Clustered Index) 영어 사전처럼 책의 내용 자체가 순서대로 정렬되어 있어서 인덱스 자체가 책의 내용과 같은 것 테이블 당 한 개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하는지에 따라서 시스템의 성능이 달라질 수 있다. 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 신중하게 생각해야 한다. 보조 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:2:1","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"보조 인덱스(Secondary Index) \u003c찾아보기\u003e가 별도로 있고, \u003c찾아보기\u003e를 찾은 후에 그 옆에 표시된 페이지로 가야 실제 찾는 내용이 있는 것 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다. 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소값이다. 클러스터형 인덱스보다 검색 속도는 더 느리지만 입력/수정/삭제는 덜 느리다. 테이블 당 여러 개를 생성할 수 있다. 하지만 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있으므로 꼭 필요한 열에만 생성하는 것이 좋다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:2:2","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"MYSQL 인덱스의 특징 PRIMARY KEY로 지정한 열은 클러스터형 인덱스가 생성된다. UNIQUE NOT NULL로 지정한 열은 클러스터형 인덱스가 생성된다. UNIQUE(또는 UNIQUE NULL)로 지정한 열은 보조 인덱스가 생성된다. PRIMARY KEY와 UNIQUE NOT NULL이 있으면 PRIMARY KEY로 지정한 열에 우선 클러스터형 인덱스가 생성된다. PRIMARY KEY로 지정한 열로 데이터가 오름차순 정렬된다. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:3:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"인덱스를 생성할 때 고려할 점 테이블 조회 시에 WHERE 절의 조건에 해당 열이 나오는 경우에만 인덱스를 사용한다. WHERE절에 사용되더라도 자주 사용해야 가치가 있다. 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다. 외래 키를 지정한 열에는 자동으로 외래 키 인데스가 생성된다. JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다. 사용하지 않는 인덱스는 제거하자. ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:4:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["DB"],"content":"참고 https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/ https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree ","date":"2022-02-25","objectID":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/:5:0","tags":["index"],"title":"DB 인덱스","uri":"/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"categories":["개발방법론"],"content":"AOP는 기능을 핵심 비즈니스 로직과 공통 모듈로 구분하고 핵심 로직에 영향을 미치지 않고 사이사이에 공통 모듈을 효과적으로 잘 끼워 넣어 중복성을 감소시킬 수 있는 개발 방법이다. ","date":"2022-02-24","objectID":"/aop/:0:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"AOP 용어 용어 설명 Advice Joinpoint에서 실행되어야 하는 프로그램 코드 독립된 클래스의 메소드로 작성함 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체 BEFORE, AROUND, AFTER의 실행 위치 지정 Joinpoint 메소드를 호출하는 ‘시점’, 예외가 발생하는 ‘시점’과 같이 애플리케이션을 실행할 때 특정 작업이 실행되는 ‘시점’ 을 의미 Advice를 적용할 수 있는 후보 지점 혹은 호출 이벤트 관심사를 구현한 코드를 끼워 넣을 수 있는 프로그램의 이벤트를 말하며, 예로는 call events, execution events, initialization events 등이 있음 Pointcut 여러 Joinpoint의 집합체로 언제 Advice를 실행할지를 정의 Target 클래스와 Advice가 결합(Weaving)될 때 둘 사이의 결합규칙을 정의 Target 실질적인 비지니스 로직을 구현하고 있는 코드 JoinPoint에서 실제 Advice가 적용될 지점 Weaving PointCut에 Advice 메서드가 삽입되는 과정 ","date":"2022-02-24","objectID":"/aop/:1:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"AOP 구현 implementation 'org.springframework.boot:spring-boot-starter-aop' // @EnableAspectJAutoProxy 생략 가능 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } } @Service public class AuthServiceImpl { public void businessLogicMethod(){ System.out.println(\"businessLogicMethod process!\"); } } ","date":"2022-02-24","objectID":"/aop/:2:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"일반적인 구현 import org.aspectj.lang.ProceedingJoinPoint; @Aspect @Configuration public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"execution(* com.demo.study.service.AuthServiceImpl.*(..))\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"execution(* com.demo.study.service.AuthServiceImpl.*(..))\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } ","date":"2022-02-24","objectID":"/aop/:2:1","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"어노테이션으로 구현 @Target(ElementType.METHOD) @Retention(RetentionPolicy.CLASS) public @interface PerformanceCheck { } @Service public class AuthServiceImpl { @PerformanceCheck public void businessLogicMethod(){ System.out.println(\"businessLogicMethod process!\"); } } import org.aspectj.lang.ProceedingJoinPoint; @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"@annotation(com.demo.study.annotation.PerformanceCheck)\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"@annotation(com.demo.study.annotation.PerformanceCheck)\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } 어노테이션과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다. ","date":"2022-02-24","objectID":"/aop/:2:2","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"빈으로 구현 import org.aspectj.lang.ProceedingJoinPoint; @Aspect @Component public class UselessAspect { Logger log = LoggerFactory.getLogger(UselessAdvisor.class); @Around(\"bean(com.demo.study.service.AuthServiceImpl)\") public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); try { stopWatch.start(); return joinPoint.proceed(); } finally { stopWatch.stop(); log.info(\"request spent {} ms\", stopWatch.getLastTaskTimeMillis()); } } /** * @Before * @AfterReturning * @AfterThrowing */ @After(\"bean(com.demo.study.service.AuthServiceImpl)\") public void After() throws Throwable { log.info(\"After 어드바이스\"); } } 빈과 Aspect가 동일 위치면 어노테이션만 적어도 된다. 패키지가 다르면 FQCN(Fully qualified Class Name)을 다 입력해주어야 한다. ","date":"2022-02-24","objectID":"/aop/:2:3","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"AOP PointCut 설정 execution(* com.springbook.biz..*Impl.get*(..))\" * : 리턴값 com.springbook.biz.. : 패키지 *Impl: 클래스 이름 get* : 메서드 이름 (..) : 매개변수 중간마다의 . : 구분점 ","date":"2022-02-24","objectID":"/aop/:3:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"execution 포인트 컷 리턴 표현식 설명 * 모든 리턴타입 허용 void 리턴타입이 void인 메서드 선택 !void 리턴타입이 void가 아닌 메서드 선택 ","date":"2022-02-24","objectID":"/aop/:3:1","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"execution 포인트 컷 패키지 표현식 설명 com.springbook.biz 정학하게 해당 패키지만 선택 com.springbook.biz.. 해당 패키지 및 모든 하위 패키지 선택 com.springbook..impl ..앞 패키지로 시작하면서 마지막 패키지 이름이 ..뒤로 끝나는 패키지 선택 ","date":"2022-02-24","objectID":"/aop/:3:2","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"execution 포인트 컷 클래스 표현식 설명 BoardServiceImpl 정학하게 해당 클래스만 선택 *Impl 클래스 이름이 *뒷 글자로 끝나는 클래스만 선택 BoardService+ 해당 클래스는 물론 파생된 모든 자식 클래스도 선택 가능 variable+ 해당 인터페이스를 구현한 모든 클래스 선택 가능 ","date":"2022-02-24","objectID":"/aop/:3:3","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"execution execution 포인트 컷 메서드 표현식 설명 *(..) 가장 기본 설정으로 모든 메서드 선택 get*(..) 메서드 이름이 get으로 시작하는 모든 메서드 선택 매서드이름(..) 특정 메서드 이름을 가진 메서드 선택 execution 포인트 컷 매개변수 표현식 설명 (..) 가장 기본 설정으로서 매개변수 타입의 제한이 없음을 의미 (*) 반드시 1개의 매개변수를 가지는 메서드만 허용한다는 의미 (com.spring.user.User) 해당 패키지의 클래스를 가지는 메서드만 허용한다는 의미 (!com.spring.user.User) 해당 패키지의 클래스를 가지지 않는 메서드만 허용한다는 의미 (Integer, ..) 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용 (Integer, *) 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 integer인 메서드만 허용 ","date":"2022-02-24","objectID":"/aop/:3:4","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"AOP 구현체 SpringAOP AspectJ 목표 간단한 AOP 제공 완벽한 AOP 제공 join point 메서드 레벨만 지원 생성자, 필드, 메서드 등 다양하게 지원 weaving 런타임 시에만 가능 런타임은 제공하지 않음, compile-time, post-compile, load-time 제공 대상 Spring Container가 관리하는 Bean에만 가능 모든 JAVA Object에 가능 ","date":"2022-02-24","objectID":"/aop/:4:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["개발방법론"],"content":"참고 https://github.com/kwj1270/TIL_Seminar/blob/master/AOP.md https://swingswing.tistory.com/m/272 ","date":"2022-02-24","objectID":"/aop/:5:0","tags":["aop"],"title":"AOP","uri":"/aop/"},{"categories":["java"],"content":"서블릿 컨테이너 서블릿 컨테이너는 서블릿을 담아 관리한다. 서블릿은 싱글톤으로 관리된다. ","date":"2022-02-23","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:1:0","tags":["servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"서블릿이 호출되는 과정 Servlet Request / Servlet Response 객체 생성 설정 파일을 참고하여 매핑할 Servlet을 확인 \u003cservlet\u003e \u003cservlet-name\u003eMyServlet\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.jsp.web.MyServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eMyServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 해당 서블릿 인스턴스 존재를 유무를 확인하여 없으면 생성(init()) Servlet Container에 스레드를 생성하고, res req를 인자로 service 실행 ","date":"2022-02-23","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:2:0","tags":["servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"참고 https://youtu.be/calGCwG_B4Y ","date":"2022-02-23","objectID":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/:3:0","tags":["servlet-container"],"title":"Servlet 동작 방식","uri":"/servlet-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다. Nested Class의 구조는 다음과 같다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:1:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다. Static 선언이 갖는 특성이 반영된 클래스이다. 따라서 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 static 네스티드 클래스의 인스턴스 생성이 가능하다. 클래스 내부에서만 공유하고자 하는 변수가 있을 때 private static 키워드로 선언하고 static nest class로 선언하여 캡슐화할 수 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:2:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Member Class 인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다. 클래스의 정의를 감추어야 할 때 사용된다. 반복자는 멤버클래스이다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:3:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Local Class 중괄호 내에, 특히 메소드 내에 정의 ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:4:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"Anonymous Class 해당 클래스를 객체로 선언하기 위해서는 생성자 혹은 메소드 내부에서 생성자를 호출하고, 이 때 중괄호를 만들어 그 내부에 해당 클래스를 정의하여 구현한다. 익명 클래스는 런타임 시, JVM이 읽어야 하는 클래스 파일이 줄어 실행 속도가 향상될 수 있다는 장점이 있지만, 남발할 경우 코드 가독성과 유지보수가 어렵다는 단점이 있다. ","date":"2022-02-17","objectID":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/:5:0","tags":["nested-class"],"title":"자바의 Nested Class","uri":"/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/"},{"categories":["java"],"content":"equals와 hashCode는 왜 같이 재정의해야 할까? hash 값을 사용하는 Collection(HashMap, HashSet, HashTable)은 객체가 논리적으로 같은지 비교할 때 아래 그림과 같은 과정을 거친다. hashCode 메소드의 반환값을 이용해서 검색의 범위를 확 줄여버리고, 해당 부류 내에 존재하는 데이터의 내용 비교는 equals 메소드를 통해서 진행한다. Object 클래스의 hashCode 메소드는 인스턴스가 다르면 구성 내용에 상관없이 전혀 다른 해시값을 반환하도록 정의되어 있다. equals 메소드도 내용 비교가 아닌, 참조값만 비교하도록 정의되어 있다. 따라서 이 두 메소드를 적절히 오버라이딩해야 두 개의 인스턴스를 동일한 인스턴스로 인식시킬 수 있다. ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:1:0","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"equals와 hashCode 재정의 예시 ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:2:0","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"String String 클래스에 정의된 hashCode 메소드는 다음과 같다. public int hashCode() { int h = this.hash; if (h == 0 \u0026\u0026 this.value.length \u003e 0) { this.hash = h = this.isLatin1() ? StringLatin1.hashCode(this.value) : StringUTF16.hashCode(this.value); } return h; } String 클래스에 정의된 equals 메소드는 다음과 같다. public boolean equals(Object anObject) { if (this == anObject) { return true; } else { if (anObject instanceof String) { String aString = (String)anObject; if (this.coder() == aString.coder()) { return this.isLatin1() ? StringLatin1.equals(this.value, aString.value) : StringUTF16.equals(this.value, aString.value); } } return false; } } ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:2:1","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"Arrays Arrays 클래스에 정의된 hashCode 메소드는 다음과 같다. public static int hashCode(Object a[]) { if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; } public static boolean equals(int[] a, int[] a2) { if (a == a2) { return true; } else if (a != null \u0026\u0026 a2 != null) { int length = a.length; if (a2.length != length) { return false; } else { return ArraysSupport.mismatch(a, a2, length) \u003c 0; } } else { return false; } } ","date":"2022-02-16","objectID":"/equals%EC%99%80-hashcode/:2:2","tags":["equals","hashcode"],"title":"equals와 hashCode","uri":"/equals%EC%99%80-hashcode/"},{"categories":["java"],"content":"Iterable 인터페이스 Collection 인터페이스의 상위 인터페이스는 Iterable 이다. package java.lang; public interface Iterable\u003cT\u003e { /** * Returns an iterator over elements of type {@code T}. * * @return an Iterator. */ Iterator\u003cT\u003e iterator(); /** * Performs the given action for each element of the {@code Iterable} * until all elements have been processed or the action throws an * exception. Actions are performed in the order of iteration, if that * order is specified. Exceptions thrown by the action are relayed to the * caller. * \u003cp\u003e * The behavior of this method is unspecified if the action performs * side-effects that modify the underlying source of elements, unless an * overriding class has specified a concurrent modification policy. * * @implSpec * \u003cp\u003eThe default implementation behaves as if: * \u003cpre\u003e{@code * for (T t : this) * action.accept(t); * }\u003c/pre\u003e * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */ default void forEach(Consumer\u003c? super T\u003e action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } } Iterable 인터페이스 안에는 iterator 메소드가 추상메소드로 선언이 되어있다. 이렇게 때문에 Collection 인터페이스 계층구조에서 List, Set, Queue를 구현하는 클래스들은 다 iterator 메소드를 가지고 있다. 따라서 Iterable 인터페이스는 iterator() 메소드를 하위 클래스에서 구현하도록 강제하기 위해 사용한다. ","date":"2022-02-15","objectID":"/iterable-and-iterator/:1:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"Iterator 인터페이스 Iterator 인터페이스는 Collection과는 별개로 존재하는 인터페이스이다. package java.util; public interface Iterator\u003cE\u003e { /** * Returns {@code true} if the iteration has more elements. * (In other words, returns {@code true} if {@link #next} would * return an element rather than throwing an exception.) * * @return {@code true} if the iteration has more elements */ boolean hasNext(); /** * Returns the next element in the iteration. * * @return the next element in the iteration * @throws NoSuchElementException if the iteration has no more elements */ E next(); /** * Removes from the underlying collection the last element returned * by this iterator (optional operation). This method can be called * only once per call to {@link #next}. * \u003cp\u003e * The behavior of an iterator is unspecified if the underlying collection * is modified while the iteration is in progress in any way other than by * calling this method, unless an overriding class has specified a * concurrent modification policy. * \u003cp\u003e * The behavior of an iterator is unspecified if this method is called * after a call to the {@link #forEachRemaining forEachRemaining} method. * * @implSpec * The default implementation throws an instance of * {@link UnsupportedOperationException} and performs no other action. * * @throws UnsupportedOperationException if the {@code remove} * operation is not supported by this iterator * * @throws IllegalStateException if the {@code next} method has not * yet been called, or the {@code remove} method has already * been called after the last call to the {@code next} * method */ default void remove() { throw new UnsupportedOperationException(\"remove\"); } } Iterator 인터페이스를 구현함으로써 hasNext(), next(), remove() 등의 메소드를 이용할 수 있다. 따라서 Iterable 인터페이스는 hasNext()와 next() 메소드를 하위 클래스에서 구현하도록 강제하기 위해 사용한다. import java.util.Iterator; import java.util.LinkedList; public class Test { public static void main(String[] args) { LinkedList\u003cString\u003e list = new LinkedList\u003c\u003e(); list.add(\"Lee\"); list.add(\"ekk\"); list.add(\"eww\"); Iterator it = list.iterator(); while (it.hasNext()) { System.out.print(it.next() + \" \"); } } } 이처럼 인터페이스를 사용하면 표준을 정의하고 구현을 강제함으로써 코드의 일관성을 유지할 수 있다. ","date":"2022-02-15","objectID":"/iterable-and-iterator/:2:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"참고 https://devlog-wjdrbs96.tistory.com/84 ","date":"2022-02-15","objectID":"/iterable-and-iterator/:3:0","tags":["iterable","iterator"],"title":"Iterable 인터페이스와 Iterator 인터페이스","uri":"/iterable-and-iterator/"},{"categories":["java"],"content":"Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다. public interface Comparable\u003cT\u003e { int compareTo(T obj); } 사용 예시는 다음과 같다. import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable\u003cPerson\u003e { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void showData() { System.out.printf(\"%s %d \\n\", name, age); } public int compareTo(Person p) { if (age \u003e p.age) return 1; else if (age \u003c p.age) return -1; else return 0; } } class ComparablePerson { public static void main(String[] args) { TreeSet\u003cPerson\u003e sTree = new TreeSet\u003cPerson\u003e(); sTree.add(new Person(\"Lee\", 24)); sTree.add(new Person(\"Hong\", 29)); sTree.add(new Person(\"Choi\", 21)); Iterator\u003cPerson\u003e itr = sTree.iterator(); while (itr.hasNext()) itr.next().showData(); } } ","date":"2022-02-15","objectID":"/comparable-and-comparator/:1:0","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이","uri":"/comparable-and-comparator/"},{"categories":["java"],"content":"Comparator 인터페이스 String 클래스는 이미 compareTo 메소드를 구현하고 있다. 이 때 정령기준을 변경하기 위해서 String 클래스를 상속하는 클래스를 새로 정의하는 것은 번거롭다 따라서 새로운 정렬 기준을 파라미터로 넘길 수 있도록 정의된 것이 Comparator 인터페이스이다. public interface Comparator\u003cT\u003e { int compare(T o1, T o2); } 사용 예시는 다음과 같다. import java.util.TreeSet; import java.util.Iterator; import java.util.Comparator; class StrLenComparator implements Comparator\u003cString\u003e { public int compare(String str1, String str2) { if (str1.length() \u003e str2.length()) return 1; else if (str1.length() \u003c str2.length()) return -1; else return 0; /* * return str1.length()-str2.length(); */ } } class IntroComparator { public static void main(String[] args) { TreeSet\u003cString\u003e tSet = new TreeSet\u003cString\u003e(new StrLenComparator()); tSet.add(\"Orange\"); tSet.add(\"Apple\"); tSet.add(\"Dog\"); tSet.add(\"Individual\"); Iterator\u003cString\u003e itr = tSet.iterator(); while (itr.hasNext()) System.out.println(itr.next()); } } ","date":"2022-02-15","objectID":"/comparable-and-comparator/:2:0","tags":["comparable","comparator"],"title":"Comparable 인터페이스와 Comparator 인터페이스의 차이","uri":"/comparable-and-comparator/"},{"categories":["spring"],"content":"Spring의 대표적인 핵심가치 3가지로 IoC, AOP, PSA가 있다. ","date":"2022-02-15","objectID":"/spring-psa/:0:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"PSA (Portable Service Abstraction) @Transactional 어노테이션을 선언하는 것 만으로 별도의 코드 추가 없이 트랜잭션 서비스를 사용할 수 있다. 내부적으로 트랜잭션 코드가 추상화되어 숨겨져 있는 것이다. 이렇게 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이며, 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다. ","date":"2022-02-15","objectID":"/spring-psa/:1:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["spring"],"content":"PSA의 원리 트랜잭션을 예로 들어 설명하겠다. 위 그림처럼 Spring의 @Transactional은 각 TransactionManager를 각각 구현하고 있는 것이 아니라 최상위 PlatformTransactionManager를 이용하고 필요한 TransactionManager를 DI로 주입받아 사용하고 있다. PlatformTransactionManager 인터페이스의 소스코드는 다음과 같다. public interface PlatformTransactionManager extends TransactionManager { TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException; } ","date":"2022-02-15","objectID":"/spring-psa/:2:0","tags":["PSA"],"title":"Spring PSA","uri":"/spring-psa/"},{"categories":["java"],"content":"String의 초기화 방식 String 클래스의 경우 다른 참조 자료형과 달리 불변의 원칙이 적용되며, 참조 클래스 중 유일하게 + 연산을 수행할 수 있다. Java에서 String을 생성하는 방식은 두가지가 있다. 생성자를 이용하는 방법 String str = new String(“Hello”); 리터럴을 이용하는 방법 String str = “Hello”; String a = \"apple\"; String b = new String(\"apple\"); String c = \"apple\"; String d = new String(\"apple\"); System.out.println(a==b); // false System.out.prrintln(a==c); // true 첫 번째 줄에서 String a가 생성될 때, ‘apple’은 리터럴 문자열이므로 Heap영역 중에서 String pool에 위치하게 된다. 두 번째 줄에서 String b는 new연산자를 통해 객체를 생성한다. Heap영역에 위치하지만 String pool이 아닌 다른 주소값을 참조한다. ‘==‘연산자는 같은 메모리를 참조하는가를 비교한다. 때문에 a와 b의 비교(a==b)는 false를 반환하게 된다. 세번째 줄에서 c가 가리키는 ‘apple’을 String pool에 넣으려고 보니 이미 ‘apple’이 존재한다. 그러면 c는 a와 같은 String pool의 ‘apple’을 가리키게 된다. a와 c가 같은 값을 참조하므로 a==c는 true를 반환한다. 이를 그림으로 표현해보면 다음과 같다. ","date":"2022-02-14","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:1:0","tags":["string-pool","intern()"],"title":"Java에서 String을 초기화하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"생성자로 초기화하는 방식 String 클래스는 생성자를 통해서 초기화하면 Heap 메모리에 해당 값을 할당한다 생성자를 통해 초기화된 String 변수들은 똑같은 문자열이라고 해도, Heap 메모리에 할당된 영역이 각 변수마다 다르기 때문에 동등비교연산자(==)로 비교했을 때 false가 리턴된다. 즉, 똑같은 문자열이 Heap 메모리에 여러 개 있다는 의미이다. 이는 동등비교연산자가 객체를 비교할 때 객체의 메모리 주소를 비교하기 때문인데, 문자열 자체를 비교하기 위해서는 String 클래스에서 재정의된 equals() 메소드를 호출 해야한다. ","date":"2022-02-14","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:1:1","tags":["string-pool","intern()"],"title":"Java에서 String을 초기화하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"리터럴로 초기화하는 방식 String을 리터럴로 선언할 경우 내부적으로 String의 intern()메서드가 호출되게 된다. intern() 메서드는 주어진 문자열이 String pool에 존재하는지 검색하고 있다면 그 주소값을 반환, 없다면 문자열을 String pool에 넣고 그 주소값을 반환한다. Heap 영역은 GC의 대상이기 때문에 String Constant Pool에서 참조를 잃은 문자열 객체들은 다시 메모리로 반환된다. String a = \"apple\"; String b = new String(\"apple\"); String c = b.intern() System.out.println(a==b); // false System.out.prrintln(a==c); // true c의 경우 b의 값인 ‘apple’이 String pool에 이미 존재하는가를 찾고, 이미 존재하므로 해당 문자열을 반환해 c=‘apple’이 된다. a와 c는 결국 같은 주소를 참조하게 되어 a==c는 true가 된다. ","date":"2022-02-14","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:1:2","tags":["string-pool","intern()"],"title":"Java에서 String을 초기화하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"참고 https://simple-ing.tistory.com/3 https://tecoble.techcourse.co.kr/post/2020-09-07-dive-into-java-string/ ","date":"2022-02-14","objectID":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/:2:0","tags":["string-pool","intern()"],"title":"Java에서 String을 초기화하는 방식","uri":"/java%EC%97%90%EC%84%9C-string%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D/"},{"categories":["java"],"content":"데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다. 결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다. 이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다. public enum PayType { ACCOUNT_TRANSFER(\"계좌이체\"), REMITTANCE(\"무통장입금\"), ON_SITE_PAYMENT(\"현장결제\"), TOSS(\"토스\"), PAYCO(\"페이코\"), CARD(\"신용카드\"), KAKAO_PAY(\"카카오페이\"), BAEMIN_PAY(\"배민페이\"), POINT(\"포인트\"), COUPON(\"쿠폰\"); private final String title; PayType(String title) { this.title = title; } public String getTitle() { return title; } } import lombok.Getter; import java.util.Arrays; import java.util.Collections; import java.util.List; @Getter public enum PayGroup { CASH(\"현금\", Arrays.asList(PayType.ACCOUNT_TRANSFER, PayType.REMITTANCE, PayType.ON_SITE_PAYMENT, PayType.TOSS)), CARD(\"카드\", Arrays.asList(PayType.PAYCO, PayType.CARD, PayType.KAKAO_PAY, PayType.BAEMIN_PAY)), ETC(\"기타\", Arrays.asList(PayType.POINT, PayType.COUPON)), EMPTY(\"없음\", Collections.EMPTY_LIST); private final String title; private final List\u003cPayType\u003e payList; PayGroup(String title, List\u003cPayType\u003e payList) { this.title = title; this.payList = payList; } public static PayGroup findByPayType(PayType payType){ return Arrays.stream(PayGroup.values()) .filter(payGroup -\u003e payGroup.hasPayType(payType)) .findAny() .orElse(EMPTY); } private boolean hasPayType(PayType payType){ return payList.stream() .anyMatch(pay -\u003e pay == payType); } } import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PayGroupTest { @Test public void PayGroup에게_직접_결제종류_물어보기_PayType () { PayType payType = selectPayType(); PayGroup payGroup = PayGroup.findByPayType(payType); assertEquals(payGroup.name(), \"CARD\"); assertEquals(payGroup.getTitle(), \"카드\"); } private PayType selectPayType(){ return PayType.BAEMIN_PAY; } } DB 혹은 API에서 PayType으로 데이터를 받아, 타입 안전성까지 확보하여 PayGroup 관련된 처리를 진행할 수 있게 되었다. ","date":"2022-02-04","objectID":"/enum-usage-2/:1:0","tags":["enum"],"title":"Enum 사용 (활용)","uri":"/enum-usage-2/"},{"categories":["java"],"content":"참고 https://github.com/jojoldu/blog-code/tree/master/enum-settler ","date":"2022-02-04","objectID":"/enum-usage-2/:2:0","tags":["enum"],"title":"Enum 사용 (활용)","uri":"/enum-usage-2/"},{"categories":["java"],"content":"상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 “CALC_A\"일 경우엔 값 그대로, “CALC_B\"일 경우엔 10 한 값을, “CALC_C\"일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 “DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.“는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다. import java.util.function.Function; public enum CalculatorType { CALC_A(value -\u003e value), CALC_B(value -\u003e value * 10), CALC_C(value -\u003e value * 30), CALC_ETC(value -\u003e 0L); private Function\u003cLong, Long\u003e expression; CalculatorType(Function\u003cLong, Long\u003e expression) { this.expression = expression; } public long calculate(long value) { return expression.apply(value); } } import javax.persistence.Column; import javax.persistence.EnumType; import javax.persistence.Enumerated; public class Entity { @Column //@Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다. @Enumerated(EnumType.STRING) private CalculatorType calculatorType; } import org.testng.annotations.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTypeTest { private CalculatorType selectType() { return CalculatorType.CALC_B; } @Test public void 코드에_따라_서로다른_계산하기_Enum() { CalculatorType code = selectType(); long originValue = 10000L; long result = code.calculate(originValue); assertEquals(result, 100000L); } } 값(상태)과 메소드(행위)가 어떤 관계가 있는지에 대해 더이상 다른 곳을 찾을 필요가 없게 되었다. 코드내에 전부 표현되어 있고, Enum 상수에게 직접 물어보면 되기 때문이다. ","date":"2022-02-03","objectID":"/enum-usage-1/:1:0","tags":["enum"],"title":"Enum 사용 (개념)","uri":"/enum-usage-1/"},{"categories":["spring"],"content":"@RequestBody 클라이언트가 body에 JSON 또는 XML 형태로 값(보통 객체)을 담아 전송하면, body의 내용을 다시 Java Object(객체)로 변환해주는 역할을 수행한다. 이 데이터는 Spring에서 관리하는 MessageConverter들 중 하나인 Jackson2HttpMessageConverter를 통해 Java 객체로 변환된다. ","date":"2022-01-20","objectID":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/:1:0","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam 비교","uri":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/"},{"categories":["spring"],"content":"@Request Body 사용 시 DTO에 @NoArgsConstructor가 필요한 이유 RestController에서 @RequestBody의 바인딩은 Jackson라이브러리의 ObjectMapper가 해준다. ObjectMapper는 @RequestBody가 Property로 구현되어 있거나 생성을 위임한 경우가 아니라면 기본 생성자로 생성한다. 따라서 두 상황이 아니라면 기본 생성자는 꼭 필요하다. ","date":"2022-01-20","objectID":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/:1:1","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam 비교","uri":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/"},{"categories":["spring"],"content":"@Request Body에서는 Setter가 필요없는 이유 ObjectMapper는 Setter 또는 Getter로 DTO의 필드를 가져온다. 그리고 setter를 사용하지 않는 경우에는 reflection을 사용해서 필드 값들을 넣어준다. ","date":"2022-01-20","objectID":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/:1:2","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam 비교","uri":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/"},{"categories":["spring"],"content":"@ModelAttribute 클라이언트가 전송하는 HTTP parameter(URL 끝에 추가하는 파라미터), HTTP Body 내용을 1:1로 객체에 데이터를 바인딩한다. 객체 바인딩 시 별다른 설정이 없다면 Spring 에서는 WebDataBinder의 기본 값 할당 방법인 Java Bean 방식을 사용하니 Setter가 없으면 작동하지 않는다. HTTP Body 내용은 multipart/form-data 형태이다. 따라서 Form 안에 input 값을 담아 보낼 때 유용하게 사용된다. ","date":"2022-01-20","objectID":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/:2:0","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam 비교","uri":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/"},{"categories":["spring"],"content":"@RequestParam HTTP 요청 parameter를 변수로 1대 1로 Mapping 해준다. default는 required = true 이다. 잘못된 파라미터값이 들어오면 400 BadRequest를 발생시킨다. ","date":"2022-01-20","objectID":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/:3:0","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam 비교","uri":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/"},{"categories":["spring"],"content":"참고 https://parkadd.tistory.com/70 ","date":"2022-01-20","objectID":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/:4:0","tags":["request-body","model-attribute","request-param"],"title":"RequestBody, ModelAttribute, RequestParam 비교","uri":"/requestbody-modelattribute-requestparam-%EB%B9%84%EA%B5%90/"},{"categories":["ML"],"content":"Step Function 활성화 함수는 신경망의 행동을 결정하는 중요한 역할을 합니다. 가장 간단한 형태의 활성화 함수는 계단 함수(Step function) 라고 합니다. 계단 함수는 입력값의 합이 임계값을 넘으면 $0$ 을, 넘지 못하면 $1$ 을 출력하게 됩니다. 계단 함수의 그래프는 다음과 같이 생겼습니다. 이미지 출처 : wikipedia - Heaviside step function 계단 함수는 활성화 함수의 조건을 가장 잘 만족하는 함수이고 직관적으로도 이해하기 쉽습니다. 하지만 불연속 함수라는 단점 때문에 실제 신경망에 사용되지는 않습니다. 그래프를 보면 알 수 있듯 임계값 지점에서 불연속점을 갖게 되는데 이 점에서 미분이 불가능하기 때문에 학습이 필요한 신경망에 사용할 수 없습니다. 이런 문제점을 해결하기 위해서 등장한 것이 시그모이드 함수(Sigmoid) 입니다. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:1:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"Sigmoid Function 시그모이드 함수는 기본적으로 $S$ 모양을 그리는 곡선 함수를 통칭하여 부르는 말입니다. 이 중 대표적인 함수는 로지스틱(Logistic) 함수와 하이퍼탄젠트(Hyper tangent, $\\tanh$) 함수가 있습니다. 두 함수의 수식과 그래프를 보며 시그모이드 함수와 계단 함수가 다른 점이 무엇인지 알아보도록 하겠습니다. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"로지스틱 함수(Logistic Function) $$ \\text{Logistic} : \\frac{1}{1+e^{-x}} $$ 이미지 출처 : wikipedia - Logistic function ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:1","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"하이퍼탄젠트 함수(Hypertangent Function) $$ \\text{Hypertangent} : \\frac{e^x-e^{-x}}{e^x+e^{-x}} = \\frac{e^{2x}-1}{e^{2x}+1} $$ 이미지 출처 : mathworld.wolfram.com 두 함수는 모두 연속함수입니다. 계단 함수의 치명적인 단점이었던 불연속을 해결했지요. 계단 함수와 시그모이드 함수의 중요한 공통점은 비선형 함수(Non-linear) 라는 점입니다. 활성화 함수는 비선형 함수를 사용해야 합니다. 활성화 함수가 선형 함수이면 안되는 이유는 무엇일까요? 선형인 활성화 함수 $l(x) = ax + b$ 가 있다고 해보겠습니다. 이 함수를 사용하여 3개의 층을 쌓는다면 최종적인 활성화 함수는 $l(l(l(x))) = l^3(x) = a(a(ax+b)+b)+b = a^3x+a^2b+ab+b$가 됩니다. $a^3 = c, d = a^2b+ab+b$라고 하면 $l^3(x) = cx+d$로 여전히 같은 형태의 함수를 사용하게 됩니다. 이렇듯 층을 아무리 깊게 쌓아도 여러 층을 쌓는 이점을 살리지 못하게 되지요. 여러 층을 쌓을 때의 장점을 살리기 위해 비선형 함수를 사용하게 되는 것이지요. ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:2:2","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["ML"],"content":"ReLU Function 시그모이드 함수는 불연속이라는 계단 함수의 단점을 해결했습니다. 하지만 시그모이드는 대부분의 점에서 기울기 값이 0이 됩니다. 이 때문에 **기울기 소실(Gradient vanishing)**이라는 문제가 발생합니다. 기울기 소실은 시그모이드 함수를 활성화 함수로 사용하여 층을 깊게 쌓았을 때 학습이 잘 되지 않는 현상입니다. 이런 현상이 왜 발생하는지 알아보겠습니다. 로지스틱 함수 $L(x)$를 미분한 함수 $L^\\prime(x)$ 의 수식은 다음과 같습니다. $$ L^\\prime(x) = \\bigg(\\frac{1}{1+e^{-x}}\\bigg)^\\prime = \\frac{e^x}{(1+e^{-x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 그래프에서 볼 수 있듯 최댓값이 $0.25$ 밖에 되지 않고 $x\u003c-5, x\u003e5$ 범위에서는 거의 $0$ 에 가깝습니다. 역전파(Back propagation) 과정에서는 미분값을 사용하여 학습을 하게 됩니다. 따라서 이 값이 0에 가까워 지면 정보가 유실되면서 학습이 잘 안되게 됩니다. 특히 층을 깊게 쌓을 경우에는 정보가 모두 유실되는 사태가 발생하게 되지요. 그렇다면 하이퍼탄젠트 함수는 어떻게 될까요? 하이퍼탄젠트 함수 $\\tanh$를 미분한 함수의 수식은 다음과 같습니다. $$ \\tanh^\\prime(x) = \\bigg(\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\bigg)^\\prime = \\frac{4e^{2x}}{(1+e^{2x})^2} $$ 위 함수의 그래프는 아래와 같이 생겼습니다. 하이퍼탄젠트 함수를 미분한 함수의 최댓값은 $1$ 입니다. 최댓값이 $0.25$ 밖에 안되었던 로지스틱 함수 보다는 정보를 잘 전달하게 되지요. 하지만 여전히 $x$ 가 0에서 멀어질수록 원래 함수의 미분값은 0에 가까워집니다. 그래서 하이퍼탄젠트 함수를 활성화 함수로 하더라도 퍼셉트론을 여러 층으로 쌓는다면 학습이 제대로 안되게 되지요. 이렇게 시그모이드 함수를 활성화 함수로 사용할 때 역전파시 학습이 제대로 진행되지 않는 현상을 기울기 소실이라고 합니다. 기울기 소실 문제를 극복하기 위해서 등장한 함수가 바로 ReLU(Rectified Linear Unit)함수입니다. ReLU함수는 입력값이 0보다 작을 경우에는 0을 반환하고, 0보다 클 경우에는 입력값을 그대로 반환합니다. 아래는 ReLU함수의 그래프를 나타낸 것입니다. 이미지 출처 : medium.com ReLU함수는 $x$ 가 $0$ 보다 클 때, 미분값이 항상 $1$ 입니다. 그래서 층이 아무리 깊어져도 손실없이 정보를 전달할 수 있습니다. 미분값이 항상 $0$과 $1$ 이기 때문에 연산이 빠르다는 점도 ReLU함수의 장점입니다. 덕분에 ReLU함수는 은닉층에서 가장 많이 사용되는 활성화 함수가 되었습니다. 물론 ReLU함수에게도 문제가 있습니다. 0이하의 값이 그대로 보존되지 않고 버려진다는 것이지요. 이를 보완하기 위해 Leaky ReLU함수가 고안되어 사용되고 있습니다. 일반적으로는 $a=0.01$을 사용하며 그래프는 다음과 같습니다. 이미지 출처 : medium.com ","date":"2022-01-11","objectID":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/:3:0","tags":["step-function","sigmoid","relu"],"title":"활성화 함수","uri":"/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/"},{"categories":["web"],"content":"SOP SOP(Same Origin Policy)는 다른 Origin으로 요청을 보낼 수 없도록 금지하는 브라우저의 기본적인 보안 정책이다. 즉, 동일한 Origin으로만 요청을 보낼 수 있게 하는 것이다. 실제로 아주 옛날에는 이것이 절대적인 규칙이었기 때문에, 다른 Origin으로 요청을 보내는 건 애초에 불가능하였다. 그러나 기술이 발달하면서 서로 다른 Origin끼리 데이터를 주고받아야 하는 일이 많아졌고, 이로 인해 SOP는 별도의 예외 사항을 두게 되었다. 즉, 몇 가지 예외 상황에 대해서는 다른 Origin으로도 요청을 보낼 수 있게 하는 것이다. 의미 Origin은 URL에서 프로토콜, 도메인, 포트 번호를 합친 부분을 의미한다. 예를 들어, 다음과 URL이 https://youngeun-in.github.io/posts/ 일 때, 도메인은 https://youngeun-in.github.io:80 이다. RFC 6454에서는 SOP의 예외 상황을 다음과 같이 정의하고 있다. Generally, reading information from another origin is forbidden. However, an origin is permitted to use some kinds of resources retrieved from other origins. For example, an origin is permitted to execute script, render images, and apply style sheets from any origin. Likewise, an origin can display content from another origin, such as an HTML document in an HTML frame. Network resources can also opt into letting other origins read their information, for example, using Cross-Origin Resource Sharing. 해석해보면, 다음과 같다. \u003cscript\u003e 태그로 JavaScript를 실행하는 경우, 이미지를 렌더링 하는 경우 \u003clink\u003e 태그로 스타일 시트 파일을 불러오는 경우 HTML 문서를 화면에 보여주는 경우 CORS 정책을 지키는 요청의 경우 ","date":"2022-01-07","objectID":"/cors/:1:0","tags":["cors"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"CORS CORS(Cross Origin Resource Sharing)는 다른 Origin으로 요청을 보내기 위해 지켜야 하는 정책으로, 원래대로라면 SOP에 의해 막히게 될 요청을 풀어주는 정책이다. 여기서 주목할 만한 점은, CORS는 ‘브라우저’의 정책이라는 것이다. 즉, 서버는 평소처럼 요청이 오면 응답을 해줄 뿐이고, 브라우저가 자신이 보낸 요청 및 서버로부터 받은 응답의 데이터가 CORS 정책을 지키는지 검사하여 안전한 요청을 보낸 건지 검사하는 것이다. 따라서 서버가 정상적으로 응답을 해줬더라도, 알고 보니 안전한 요청이 아니라고 판단되면 해당 응답을 버린다. 참고로, 위에서 언급한 예외 상황 중 CORS 요청을 제외한 나머지 경우는 요청 시 Sec-Fetch-Mode 헤더의 값을 no-cors로 설정한다. 이는 서버가 보내준 응답에 대해 CORS 정책을 검사하지 않게 하는 대신, 해당 응답을 JavaScript 단에서 읽을 수 없도록 한다. ","date":"2022-01-07","objectID":"/cors/:2:0","tags":["cors"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"CORS의 필요성 CORS는 CSRF 공격을 막는다. CSRF 공격의 예시는 다음과 같다. 악의적인 마음을 품은 해커가 자신의 웹사이트를 구축해놓고, 이 웹사이트를 가리키는 링크를 담은 메일을 사용자에게 보내는 것이다. 그리고 이 사용자는 A라는 웹사이트에 로그인이 되어 있어서 브라우저 단에 인증 정보가 존재한다고 해보자. 만약 그 사용자가 실수로 해당 링크를 클릭하여 해커의 웹사이트에 접속하면, 해커가 심어둔 JavaScript 코드가 실행되어 자기도 모르게 A 웹사이트로 개인 정보를 조회하는 API 요청을 보낼 것이다. 이 사용자의 브라우저 단에는 인증 정보가 존재하기 때문에, 이것이 해당 요청에 함께 실어서 전송되면 서버는 인증된 요청이라 생각하여 개인 정보를 응답해줄 것이다. 그러고 나면 그 개인 정보를 해커가 빼돌릴 수 있게 된다. 만약 다른 Origin으로의 요청을 막는 정책, 즉 SOP가 존재한다면 문제를 어느 정도 예방할 수 있다. 해커가 구축한 웹사이트와 A 웹사이트는 당연히 Origin이 다르기 때문에, 해커의 웹사이트에서 A 웹사이트로 API 요청을 보낼 수 없기 때문이다. 따라서 SOP는 브라우저의 아주 기본적인 보안 정책으로서 기능한다. ","date":"2022-01-07","objectID":"/cors/:3:0","tags":["cors"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"CORS 동작 원리 CORS 요청은 다음과 같이 세 가지 유형으로 나눠서 생각해볼 수 있다. ","date":"2022-01-07","objectID":"/cors/:4:0","tags":["cors"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"단순 요청 (Simple Request) 단순 요청이 되기 위한 조건은 대략 다음과 같다. 메소드가 GET, HEAD, POST 중 하나여야 한다. User Agent가 자동으로 설정한 헤더를 제외하면, 아래와 같은 헤더들만 사용할 수 있다. Accept Accept-Language Content-Language Content-Type DPR Downlink (en-US) Save-Data Viewport-Width Width Content-Type 헤더에는 아래와 같은 값들만 설정할 수 있다. application/x-www-form-urlencode multipart/form-data text/plain 위와 같은 조건을 만족하는 단순 요청은 안전한 요청으로 취급되어, 단 한 번의 요청만을 전송한다. 브라우저는 다른 Origin으로 요청을 보낼 때 Origin 헤더에 자신의 Origin을 설정하고, 서버로부터 응답을 받으면 응답의 Allow-Control-Allow-Origin 헤더에 설정된 Origin의 목록에 요청의 Origin 헤더 값이 포함되는지 검사한다. CORS허용을 위해서는 서버에서 응답의 Allow-Control-Allow-Origin 헤더에 허용되는 Origin의 목록 혹은 와일드카드(*)를 설정해주면 된다. ","date":"2022-01-07","objectID":"/cors/:4:1","tags":["cors"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"프리플라이트 요청 (Preflight Request) 단순 요청의 조건에 벗어나는(= 안전하지 않은) 요청의 경우, 서버에 실제 요청을 보내기 전에 예비 요청에 해당하는 프리플라이트 요청(Preflight Request)을 먼저 보내서 실제 요청이 전송하기에 안전한지 확인한다. 만약 안전한 요청이라고 확인이 된다면, 그때서야 실제 요청을 서버에게 보낸다. 따라서 총 두 번의 요청을 전송한다. 프리플라이트 요청의 특징은 다음과 같다. 메소드로 OPTIONS를 사용한다. Origin 헤더에 자신의 Origin을 설정한다. Access-Control-Request-Method 헤더에 실제 요청에 사용할 메소드를 설정한다. Access-Control-Request-Headers 헤더에 실제 요청에 사용할 헤더들을 설정한다. 서버는 이러한 프리플라이트 요청에 대해 다음과 같은 특징을 가진 응답을 제공해야 한다. Access-Control-Allow-Origin 헤더에 허용되는 Origin들의 목록 혹은 와일드카드(*)를 설정한다. Access-Control-Allow-Methods 헤더에 허용되는 메소드들의 목록 혹은 와일드카드(*)를 설정한다. Access-Control-Allow-Headers 헤더에 허용되는 헤더들의 목록 혹은 와일드카드(*)를 설정한다. Access-Control-Max-Age 헤더에 해당 프리플라이트 요청이 브라우저에 캐시 될 수 있는 시간을 초 단위로 설정한다. 이러한 응답을 받고 나면 브라우저는 이 응답의 정보를 자신이 전송한 요청의 정보와 비교하여 실제 요청의 안전성을 검사한다. 만약 이 안전성 검사에 통과하게 된다면, 그때서야 실제 요청을 서버에게 보낸다. ","date":"2022-01-07","objectID":"/cors/:4:2","tags":["cors"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"인증 정보를 포함한 요청 (Credentialed Request) 인증 정보(Credential)란 쿠키(Cookie) 혹은 Authorization 헤더에 설정하는 토큰 값 등을 일컫는다. 만약 이러한 인증 정보를 함께 보내야 하는 요청(Credentialed Request)이라면, 별도로 따라줘야 하는 CORS 정책이 존재한다. 쿠키 등의 인증 정보를 보내기 위해서는 클라이언트 단에서 요청 시 별도의 설정이 필요하다. 이는 Ajax 요청을 위해 어떠한 도구를 사용하느냐에 따라 달라진다. 만약 XMLHttpRequest, jQuery의 ajax, 또는 axios를 사용한다면 withCredentials 옵션을 true로 설정해줘야 한다. 반면, fetch API를 사용한다면 credentials 옵션을 include로 설정해줘야 한다. 이러한 별도의 설정을 해주지 않으면 쿠키 등의 인증 정보는 절대로 자동으로 서버에게 전송되지 않는다. 위와 같은 설정을 통해 인증 정보를 요청에 포함시켰다면, 이 요청은 이제 인증 정보를 포함한 요청이 된다. 그리고 서버는 이러한 요청에 대해 일반적인 CORS 요청과는 다르게 대응해줘야 한다. 응답의 Allow-Control-Allow-Origin 헤더가 와일드카드(*)가 아닌 분명한 Origin으로 설정되어야 하고, Allow-Control-Allow-Credentials 헤더는 true로 설정되어야 한다. 그렇지 않으면 브라우저에 의해 응답이 거부된다. ","date":"2022-01-07","objectID":"/cors/:4:3","tags":["cors"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"참고 https://it-eldorado.tistory.com/163 ","date":"2022-01-07","objectID":"/cors/:5:0","tags":["cors"],"title":"CORS","uri":"/cors/"},{"categories":["web"],"content":"ETag(entity tag)는 웹 서버가 주어진 URL의 콘텐츠가 변경되었는지 알려주고 이를 반환하는 HTTP 응답 헤더이다. 캐시를 사용하면 불필요한 요청을 줄이면서 서버의 부하를 줄일 수 있고, 미리 캐시에 저장해 놓은 값을 사용함으로써 빠른 응답을 할 수 있다. ETag는 사용하는 캐시가 유효한지 검증하기 위해 사용한다. Static file(js, css, image) 뿐만 아니라 API와 같은 Dynamic content에도 간단하게 Cache기능을 사용하게 설정하면 API속도도 증가되고 유저 입장에서는 네트웍 트래픽을 줄일 수 있다. API와 같이 언제 바뀔지 모르는 데이터의 Cache는 쉽지 않은데, Etag를 이용하면 서버에서 새로운 데이터를 먼저 확인하고 줄 수 있기 때문에 API에도 충분히 적용가능하다. ","date":"2022-01-06","objectID":"/etag/:0:0","tags":["http-cache","etag"],"title":"ETag","uri":"/etag/"},{"categories":["web"],"content":"ETag를 사용한 요청과 응답 예시 클라이언트가 요청을 보낸다. curl -H \"Accept: application/json\" -i http://localhost:8080/spring-boot-rest/foos/1 서버는 ETag를 응답 header에 담아서 보낸다. HTTP/1.1 200 OK ETag: \"f88dd058fe004909615a64f01be66a7\" Content-Type: application/json;charset=UTF-8 Content-Length: 52 클라이언트는 재요청할 때 ETag를 header의 If-None-Match에 담아 요청을 보낸다. Note ETag를 사용할 때 Conditional headers로 If-None-Match와 If-Match가 있다. If-None-Match - 클라이언트에서 캐싱된 ETag와 서버의 ETag가 다를 때 요청을 처리한다. If-Match - 클라이언트에서 캐싱된 ETag와 서버의 ETag가 같을 때 요청을 처리한다. curl -H \"Accept: application/json\" -H 'If-None-Match: \"f88dd058fe004909615a64f01be66a7\"' -i http://localhost:8080/spring-boot-rest/foos/1 리소스가 바뀌지 않았기 때문에 서버는 304 Not Modified를 응답한다. ETag는 이전 요청에 대한 응답과 같다. HTTP/1.1 304 Not Modified ETag: \"f88dd058fe004909615a64f01be66a7\" 클라이언트의 요청에 대해 다른 응답을 하도록 서버의 데이터를 바꾼다. 클라이언트는 같은 요청을 다시 한다. 요청을 다시 할 때는 마지막으로 가지고 있던 ETag를 담아서 보낼 것이다. curl -H \"Accept: application/json\" -H 'If-None-Match: \"f88dd058fe004909615a64f01be66a7\"' -i http://localhost:8080/spring-boot-rest/foos/1 클라이언트에서 보낸 ETag와 서버의 ETag가 다르기 때문에 서버는 요청을 처리한다. 리소스가 바뀌었으니 새로운 ETag를 header에 담아 보낸다. 새로운 요청을 처리했기 때문에 서버는 200 OK를 응답한다. HTTP/1.1 200 OK ETag: \"03cb37ca667706c68c0aad4cb04c3a211\" Content-Type: application/json;charset=UTF-8 Content-Length: 56 ","date":"2022-01-06","objectID":"/etag/:1:0","tags":["http-cache","etag"],"title":"ETag","uri":"/etag/"},{"categories":["web"],"content":"ETag를 사용하지 않은 API vs 사용한 API ETag 사용 예시와 ETag를 사용한 API와 사용하지 않은 API를 비교를 설명하기 위해 간단하게 Controller를 작성해 보았다. @RequestMapping(\"/posts\") @RestController public class PostController { // ... @GetMapping(\"/no-etag\") public ResponseEntity\u003cList\u003cPostResponse\u003e\u003e findAllWhenNoETag() { return ResponseEntity.ok().body(postService.findAll()); } @GetMapping(\"/etag\") public ResponseEntity\u003cList\u003cPostResponse\u003e\u003e findAllWhenETag() { return ResponseEntity.ok().body(postService.findAll()); } // ... } 그리고 ETag 설정으로 ShallowEtagHeaderFilter를 Bean으로 등록해준다. @Configuration public class ETagHeaderFilter { @Bean public ShallowEtagHeaderFilter shallowEtagHeaderFilter() { return new ShallowEtagHeaderFilter(); } } 추가 필터를 구성할 필요 없다면 위의 코드와 같이 작성해도 된다. 하지만 ETag를 사용한 API와 사용하지 않은 API를 비교하기 위해 필터를 사용했다. 추가 필터 구성을 하고 싶다면 다음과 같이 설정해주면 된다. @Configuration public class ETagHeaderFilter { @Bean public FilterRegistrationBean\u003cShallowEtagHeaderFilter\u003e shallowEtagHeaderFilter() { FilterRegistrationBean\u003cShallowEtagHeaderFilter\u003e filterRegistrationBean = new FilterRegistrationBean\u003c\u003e( new ShallowEtagHeaderFilter()); filterRegistrationBean.addUrlPatterns(\"/posts/etag\"); filterRegistrationBean.setName(\"PostAPIFilter\"); return filterRegistrationBean; } } 현재 PostController에서 /posts/etag만 etag를 사용한다는 설정이다. 만약 /post/에 대해 전부 ETag를 설정하고 싶다면 filterRegistrationBean.addUrlPatterns(\"/posts/*\") 이렇게 설정하면 된다. 그럼 이제 /no-etag와 /etag를 호출해 보자. 얼핏 보면 둘의 차이가 안 보인다. 하지만 Response Headers를 보면 차이를 볼 수 있다. 두 응답의 차이를 볼 수 있는 곳은 ETag일 것이다. /etag는 ETag를 사용하고 있기 때문에 응답으로 ETag를 header에 해시값으로 보내준다. 이는 재요청할 때 header의 If-None-Match의 값으로 보내 줄 것이다. If-None-Match: \"0fad8e1b47f45fa4ce7fef400e87c9289\" 이렇게 ETag를 /etag 요청 header의 If-None-Match에 담아 재요청해 보겠다. etag를 보면 앞서 설명했듯이 같은 요청에 대해서 304 상태 코드를 응답한다. 이는 서버에서 캐시 유효성 검사를 한 결과 변경되지 않았기 때문이다. 여기서 봐야 할 것은 사이즈다. no-etag는 재요청에 대해서 796B -\u003e 796B인 반면에 etag는 820B -\u003e 145B이다. 이유는 ETag를 사용하지 않으면 했던 일을 똑같이 또 하지만, ETag를 사용하면 같은 요청에 대해서 변경된 리소스가 없다면 304 상태 코드와 ETag를 header에 담아 보내줄 뿐 요청에 대한 리소스를 또 보내지 않는다. ","date":"2022-01-06","objectID":"/etag/:2:0","tags":["http-cache","etag"],"title":"ETag","uri":"/etag/"},{"categories":["web"],"content":"참고 https://tecoble.techcourse.co.kr/post/2020-09-30-ETag-with-Spring/ ","date":"2022-01-06","objectID":"/etag/:3:0","tags":["http-cache","etag"],"title":"ETag","uri":"/etag/"},{"categories":["spring"],"content":"Spring mocking 없이 테스트하려면? 아래 코드를 mocking 없이 테스트하려면 어떻게 해야 할까? package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import java.io.IOException; public class RepositoryRank { public int getPoint(String repositoryName) throws IOException { GitHub github = GitHub.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u003e 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public static void main(String[] args) throws IOException { RepositoryRank repositoryRank = new RepositoryRank(); int point = repositoryRank.getPoint(\"whiteship/live-study\"); System.out.println(point); } } Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입하면 된다. 설명과 코드는 다음과 같다. package com.example.demo; import org.kohsuke.github.GHIssueState; import org.kohsuke.github.GHRepository; import org.kohsuke.github.GitHub; import org.kohsuke.github.GitHubBuilder; import java.io.IOException; public class RepositoryRank { //인터페이스 선언 interface GitHubService { GitHub connect() throws IOException; } //인터페이스를 구현한 클래스 생성하고 모킹하고자 하는 메소드를 오버라이드한다. static class DefaultGitHubService implements GitHubService { @Override public GitHub connect() throws IOException { return new GitHubBuilder().build(); } } private final GitHubService gitHubService; //서비스를 주입받는다. public RepositoryRank(GitHubService gitHubService) { this.gitHubService = gitHubService; } public int getPoint(String repositoryName) throws IOException { GitHub github = gitHubService.connect(); GHRepository repository = github.getRepository(repositoryName); int points = 0; if (repository.hasIssues()) { points += 1; } if (repository.getPullRequests(GHIssueState.CLOSED).size() \u003e 0) { points += 1; } points += repository.getStargazersCount(); points += repository.getForksCount(); return points; } public void main(String[] args) throws IOException { GitHubService gitHubService = new DefaultGitHubService(); //Repository 인스턴스를 생성 시에 외부에서 생성한 GitHubService 인스턴스를 주입 RepositoryRank repositoryRank = new RepositoryRank(gitHubService); int point = repositoryRank.getPoint(\"whiteship/live-study\"); System.out.println(point); } } ","date":"2022-01-01","objectID":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/:1:0","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법","uri":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/"},{"categories":["spring"],"content":"참고 백기선님의 유튜브를 참고했다. https://youtu.be/bJfbPWEMj_c ","date":"2022-01-01","objectID":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/:2:0","tags":["test","psa"],"title":"Spring mocking 없이 테스트하는법","uri":"/spring-mocking-%EC%97%86%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%8A%94%EB%B2%95/"}]