<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title/><link>https://youngeun-in.github.io/</link><description>About LoveIt Theme</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 12 Oct 2023 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>쿠버네티스 컴포넌트</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</link><pubDate>Thu, 12 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</guid><description>쿠버네티스 클러스터의 전체 구조 마스터에는 etcd, kube-apiserver, kube-scheduler, kube-controller-manager,kubelet, kube-proxy, docker 등의 컴포넌트가 실행된다. 컴포넌트 각각이 다른 마스터나 노드 서버에서 별개로 실행되어도 실제 쿠버네티스 클러스터를 운영하는 데 이상은 없다. 하지만 마스터가 서버 1대라면 방금 소개한 프로세스 한 묶음을 해당 서버에서 같이 실행하는 것이 일반적인 구성이다.
마스터는 보통 고가용성을 만족하고자 서버 3대 정도 구성해서 운영한다. 평소 실제 클러스터를 관리하는 리더 마스터는 1대고 나머지 2대는 대기한다. 리더 마스터에 장애가 발생하면자연스럽게 나머지 2대 중 1대가 리더 역할을 맡다.</description></item><item><title>쿠버네티스 관리 도구</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/</link><pubDate>Wed, 11 Oct 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC/</guid><description>쿠버네티스를 제대로 활용하려면 여러 대 서버를 클러스터로 구성해 사용해야 한다. 서버 자원에 쿠버네티스 클러스터를 직접 구성할 때 활용하는 도구는 Kubeadm, Kubespray가 있다.
Kubeadm Kubeadm은 쿠버네티스에서 공식 제공하는 클러스터 생성/관리 도구이다. 여러 대 서버를 쿠버네티스 클러스터로 손쉽게 구성할 수 있다.
특징은 다음과 같다.
쿠버네티스에서 직접 제공하는 클러스터 생성 tool 클러스터 생성을 위해 필요한 기초 생성, 관리 명령어들이 포함된다. 클러스터를 관리하기 위한 것이므로 개별 node 에 대한 container runtime, kublet, cni 등은 알아서 설치가 필요하다.</description></item><item><title>쿠버네티스와 클라우드 네이티브</title><link>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/</link><pubDate>Mon, 25 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/</guid><description>클라우드 네이티브 클라우드 네이티브란 클라우드의 장점을 최대한 활용하여 정보 시스템을 구축 및 실행하는 환경이다.
클라우드 네이티브 기술은 조직이 퍼블릭, 프라이빗, 그리고 하이브리드 클라우드와 같은 현대적이고 동적인 환경에서 확장 가능한 애플리케이션을 개발하고 실행할 수 있게 해준다. 컨테이너, 서비스 메쉬, 마이크로서비스, 불변(Immutable) 인프라, 그리고 선언형(Declarative) API가 이러한 접근 방식의 예시들이다.
이 기술은 회복성, 관리 편의성, 가시성을 갖춘 느슨하게 결합된 시스템을 가능하게 한다. 견고한 자동화 기능을 함께 사용하면 엔지니어는 영향이 큰 변경을 최소한의 노력으로 예측 가능하게 수행할 수 있다.</description></item><item><title>하드링크, 심볼릭링크</title><link>https://youngeun-in.github.io/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/</link><pubDate>Mon, 11 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%95%98%EB%93%9C%EB%A7%81%ED%81%AC-%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC/</guid><description>inode 리눅스에는 inode 라는 개념이 있다. inode는 유닉스 계통의 파일 시스템에서 사용하는 자료 구조이다.
모든 파일과 디렉토리는 inode를 하나씩 가지고 있다. 그리고 여기에는 해당 파일의 허가권, 소유권, 파일의 실제 위치 등 중요한 정보들이 들어있다.
inode는 실제 파일의 내용을 갖고 있지는 않다. inode는 데이터의 우편번호 역할을 한다고 볼 수 있다. 즉, 파일의 내용을 갖고 있는 주소를 포함할 뿐이다.
리눅스 파일 링크 종류 하드 링크 (Hard link) 하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킨다.</description></item><item><title>HTTP</title><link>https://youngeun-in.github.io/http/</link><pubDate>Wed, 06 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/http/</guid><description>HTTP HTTP는 HyperText Transfer Protocol의 약자로, HTML, text, image, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터를 전송 가능한 프로토콜이다.
HTTP 특징 클라이언트-서버 구조 클라이언트는 서버에 요청을 보내고, 응답을 대기한다. 서버는 요청에 대한 결과를 만들어서 응답한다.
무상태 프로토콜(Stateless)) 서버가 클라이언트의 상태를 보존하지 않는다.
장점: 서버 확장성 높음(스케일 아웃) 단점: 클라이언트가 추가 데이터 전송 모든 것을 무상태로 설계 할 수 없는 경우에는 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지를 함으로써 무상태 프로토콜의 한계를 극복할 수 있다.</description></item><item><title>URI, URL, URN</title><link>https://youngeun-in.github.io/uri-url-urn/</link><pubDate>Tue, 05 Sep 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/uri-url-urn/</guid><description>URI URI는 로케이터(locator), 이름(name)을 포함한 개념이다.
URI는 다음과 같이 풀이할 수 있다.
Uniform: 리소스 식별하는 통일된 방식 Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음) Identifier: 다른 항목과 구분하는데 필요한 정보 URL, URN URL, URN은 다음과 같이 풀이할 수 있다.
URL: Uniform Resource Locator : 리소스가 있는 위치를 지정 URN: Uniform Resource Name : 리소스에 이름을 부여 URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않아, 잘 사용하지 않는다.</description></item><item><title>페치 조인</title><link>https://youngeun-in.github.io/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/</link><pubDate>Sun, 30 Jul 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%8E%98%EC%B9%98-%EC%A1%B0%EC%9D%B8/</guid><description>페치 조인 (Fetch Join) 페치 조인은 JPQL에서 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능을 한다.
사용 문법은 다음과 같다.
1 페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로 페치 조인은 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화할 수 있다.
페치 조인은 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선한다. 실무에서는 글로벌 로딩 전략은 모두 지연 로딩이므로, 최적화가 필요한 곳은 페치 조인을 적용하면 효과적이다.</description></item><item><title>상속관계 매핑</title><link>https://youngeun-in.github.io/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</link><pubDate>Sat, 29 Jul 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</guid><description>상속관계 매핑 객체는 상속관계가 존재하지만, 관계형 데이터베이스는 상속 관계가 없다. 그나마 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다. 상속관계 매핑이라는 것은 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑하는 것이다.
DB의 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법은 세가지 있다. DB입장에서 세가지로 구현하지만 JPA에서는 어떤 방식을 선택하던 매핑이 가능하다.
주요 어노테이션 @Inheritance(strategy=InheritanceType.XXX) JPA가 DB의 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 세가지 방식과 매핑하려면 @Inheritance(strategy=InheritanceType.XXX)의 stategy를 설정해주면 된다.</description></item><item><title>연관관계 매핑</title><link>https://youngeun-in.github.io/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</link><pubDate>Fri, 28 Jul 2023 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</guid><description>양방향 연관관계 양방향 매핑은 단방향 매핑에서 반대 방향으로 객체 조회(객체 그래프 탐색) 기능이 추가된 매핑 방법이다.
아래와 같은 연관 관계가 있다고 가정하자.
예제 시나리오 회원과 팀이 있다 회원은 하나의 팀에만 소속될 수 있다. 회원과 팀은 다대일 관계다. 위의 시나리오를 구현하기 위해서 Member(=회원), Team Entity를 작성해보자.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package hello.</description></item><item><title>영속성 컨텍스트</title><link>https://youngeun-in.github.io/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/</link><pubDate>Thu, 27 Jul 2023 00:01:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/</guid><description>영속성 컨텍스트 처음 생성된 엔티티 매니저 팩토리는 클라이언트의 요청에 따라 엔티티 매니저를 생성한다. 그리고 엔티티 매니저는 DB Connection Pool에 있는 Connection을 이용해서 DB에 접근한다.
영속성 컨텍스트란 엔티티를 영구 저장하는 환경이다. 영속성 컨텍스트는 논리적인 개념이며, 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.
엔티티의 생명주기 비영속(new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태. 객체를 단순히 생성한 상태 영속(managed) 영속성 컨텍스트에 의해 관리되는 상태 객체를 생성한 뒤 엔티티 매니저를 통해 persist 해주면 영속 상태가 된다.</description></item></channel></rss>