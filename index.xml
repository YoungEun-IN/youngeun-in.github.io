<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title/><link>https://youngeun-in.github.io/</link><description>About LoveIt Theme</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 30 May 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Bean Scope</title><link>https://youngeun-in.github.io/bean-scope/</link><pubDate>Mon, 30 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/bean-scope/</guid><description>Bean은 스프링에서 사용하는 POJO 기반 객체다. 상황과 필요에 따라 Bean을 사용할 때 하나만 만들어야 할 수도 있고, 여러개가 필요할 때도 있고, 어떤 한 시점에서만 사용해야할 때가 있을 수 있다. 이를 위해 Scope를 설정해서 Bean의 사용 범위를 개발자가 설정할 수 있다.
우선 따로 설정을 해주지 않으면, Spring에서 Bean은 Singleton으로 생성된다. 특정 타입의 Bean을 딱 하나만 만들고 모두 공유해서 사용하기 위함이다. 보통은 Bean을 이렇게 하나만 만들어 사용하는 경우가 대부분이지만, 요구사항이나 구현에 따라 아닐 수도 있을 것이다.</description></item><item><title>CSRF, XSS</title><link>https://youngeun-in.github.io/csrf-xss/</link><pubDate>Sat, 28 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/csrf-xss/</guid><description>CSRF (Cross Site Request Forgery) 웹 어플리케이션 취약점 중 하나로, 인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위 (modify, delete, register 등)를 특정한 웹사이트에 request하도록 만드는 공격을 말한다.
주로 해커들이 많이 이용하는 것으로, 유저의 권한을 도용해 중요한 기능을 실행하도록 한다.
우리가 실생활에서 CSRF 공격을 볼 수 있는 건, 해커가 사용자의 SNS 계정으로 광고성 글을 올리는 것이다.
정확히 말하면, CSRF는 해커가 사용자 컴퓨터를 감염시거나 서버를 해킹해서 공격하는 것이 아니다. CSRF 공격은 아래와 같은 조건이 만족할 때 실행된다.</description></item><item><title>쿠키 vs 세션</title><link>https://youngeun-in.github.io/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/</link><pubDate>Tue, 24 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BF%A0%ED%82%A4-vs-%EC%84%B8%EC%85%98/</guid><description>쿠키 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다. 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다. 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.
클라이언트에 300개까지 쿠키저장 가능하며, 하나의 도메인당 20개의 값만 가질 수 있다. 하나의 쿠키값은 4KB까지 저장한다. Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다.</description></item><item><title>이미지 확장자</title><link>https://youngeun-in.github.io/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/</link><pubDate>Sun, 22 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%99%95%EC%9E%A5%EC%9E%90/</guid><description>1. JPG - Joint Photographic Experts Group(JPEG) JPG와 JPEG에 대해서 간단히 설명하겠다. JPG와 JPEG의 관계를 알기 위해서는 지금은 거의 사용되지 않은 도스(DOS)를 조금 살펴보아야 한다. 도스는 윈도우가 보편화되기 전에 주로 사용되던 프로그램으로 일종의 운영체제이다. 도스에서는 파일명을 최대 8자, 확장자를 최대 3자까지 밖에 사용할 수 없어 기존의 4자리로 된 JPEG를 줄여 JPG로 사용한 게 시초가 되었다. 하지만, 윈도우 macOS 등 다양한 운영체제가 개발되면서 파일명과 확장자를 포함하여 최대 255자까지 사용할 수 있게 되면서, JPEG를 굳이 JPG로 표기할 필요가 없게 되었다.</description></item><item><title>메시지 큐</title><link>https://youngeun-in.github.io/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/</link><pubDate>Wed, 18 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/</guid><description>메시지 큐(Message Queue)는 프로세스 또는 프로그램 간에 데이터를 교환할 때 사용하는 통신 방법 중에 하나로, 메시지 지향 미들웨어(Message Oriented Middleware:MOM)를 구현한 시스템을 의미한다. 메시지 지향 미들웨어란 비동기 메시지를 사용하는 응용 프로그램들 사이에서 데이터를 송수신하는 것을 의미한다. 여기서 메시지란 요청, 응답, 오류 메시지 혹은 단순한 정보 등의 작은 데이터가 될 수 있다.
메시지 큐는 메시지를 임시로 저장하는 간단한 버퍼라고 생각하면 된다. 메시지를 전송 및 수신하기 위해 중간에 메시지 큐를 두는 것이다.</description></item><item><title>Hash와 HashMap</title><link>https://youngeun-in.github.io/hash%EC%99%80-hashmap/</link><pubDate>Sun, 15 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/hash%EC%99%80-hashmap/</guid><description>해싱 해싱은 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 찾아가는 검색 방식이다. 키값을 원소 위치로 변환하는 함수를 해시 함수(Hash Function)라 한다. 해시 함수에 의해 계산된 주소에 저장할 값을 저장한 표를 해시 테이블(Hash Table)이라 한다. 해시 테이블은 빠른 검색 속도를 제공하는데 이유는 내부적으로 버킷(배열)을 사용하여 데이터를 저장하기 때문이다. 해시 테이블은 각각의 key 값에 해시 함수를 적용해 배열의 고유한 인덱스를 생성한 후 인덱스를 이용해 값을 저장한다. 실제 값이 저장되는 장소를 버킷이라 한다.</description></item><item><title>로드밸런싱</title><link>https://youngeun-in.github.io/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/</link><pubDate>Thu, 12 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1/</guid><description>로드 밸런싱이란 서버가 처리해야 할 업무 혹은 요청(Load)을 여러 대의 서버로 나누어(Balancing) 처리하는 것을 의미한다. 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 하는 것이 목적이다.
서비스의 규모가 커지고, 이용자 수가 늘어나게 되면 기존의 서버만으로는 원활한 서비스 동작이 불가능하게 되고, 이에 대처할 수 있는 방법은 크게 두 가지로 나뉜다.
기존의 서버 성능을 확장하는 Scale-up 방식 기존의 서버와 동일하거나 낮은 성능의 서버를 증설하는 Scale-out 방식 이때 Scale-out 방식을 통해 증가한 트래픽에 대처하기로 했다면, 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드 밸런싱이 반드시 필요하다.</description></item><item><title>낙관적락, 비관적락</title><link>https://youngeun-in.github.io/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/</link><pubDate>Sun, 08 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD/</guid><description>낙관적 락 낙관적 락은 대부분의 경우 트랜젝션의 충돌이 일어나지 않는다는 낙관적 가정을 하는 기법이다. 낙관적 락은 데이터베이스 자체에서 제공하는 것이 아니라 JPA 즉 어플리케이션에서 제공하는 기능이다. 낙관적 락은 충돌을 가정하지 않기 때문에 커밋이 된 이후에 충돌 여부를 알 수 있다.
JPA에서 낙관적 락 구현 JPA에서 낙관적 락을 사용하기 위해서는 엔티티 클래스에 @Version 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다.
1 2 3 4 5 6 7 8 9 10 @Entity public class Member { @Id private Long id; private String name; @Version private Integer version; } @Version을 명시할때는 다음과 같은 주의사항이 있다.</description></item><item><title>Filter, Interceptor, AOP</title><link>https://youngeun-in.github.io/filter-interceptor-aop/</link><pubDate>Sat, 07 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/filter-interceptor-aop/</guid><description>Filter Filter(필터)는 요청과 응답을 거른 뒤 정제하는 역할을 한다. 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러 가지 체크를 수행할 수 있다. 또한 자원의 처리가 끝난 후 응답 내용에 대해서도 변경하는 처리를 할 수가 있다. 즉 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS 방어 등의 요청에 대한 처리로 사용된다.
init(): 필터 인스턴스 초기화 doFilter(): 전/후 처리 destroy(): 필터 인스턴스 종료 Interceptor 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답을 처리한다.</description></item><item><title>Keep-Alive</title><link>https://youngeun-in.github.io/keep-alive/</link><pubDate>Fri, 06 May 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/keep-alive/</guid><description>TCP Keep-Alive 두 종단 간의 연결을 유지하는 것이 목적이다. 연결된 TCP 소켓을 체크할 수 있고 TCP 연결이 여전히 진행중인지 혹은 끊어졌는지를 결정한다.
TCP Keepalive는 연결된 세션의 재활용 측면에서만 아니라 좀비 커넥션의 삭제에도 도움을 준다. TCP 연결을 끊으려면 FIN 패킷이 필요하다. 하지만 다양한 이유로 FIN 패킷을 받을 수 없는 상황이 된다면 FIN을 전달할 수 없어 계속 연결된 것처럼 남아있게 된다. TCP Keepalive 옵션을 사용한다면 일정시간이 확인 패킷을 보내는 로직을 통해 일정시간 동안 응답이 없다면 연결을 종료하기 때문에 좀비 커넥션을 방지할 수 있다.</description></item></channel></rss>