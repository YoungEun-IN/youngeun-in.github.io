<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title/><link>https://youngeun-in.github.io/</link><description>About LoveIt Theme</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 24 Feb 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>AOP</title><link>https://youngeun-in.github.io/aop/</link><pubDate>Thu, 24 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/aop/</guid><description>📕 AOP Aspect-Oriented Programming | 관점 지향 프로그래밍
OOP 객체지향 프로그램 AOP 관점지향 프로그램 AOP는 OOP를 더욱 OOP답게 프로그래밍 할 수 있게 도와주는 것으로 애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법이다.
실제로 Spring doc document 에서는 아래와 같이 말하고 있다.
1 2 3 4 5 Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by providing another way of thinking about program structure AOP는 프로그램 구조에 대한 다른 생각의 방향을 제공해주면서 OOP를 보완하고 있다.</description></item><item><title>Array &amp; ArrayList</title><link>https://youngeun-in.github.io/array-arraylist/</link><pubDate>Thu, 17 Feb 2022 18:36:46 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/array-arraylist/</guid><description>Array 와 Cache Locality Array 는 같은 타입을 가진 여러 요소들은 한 곳에 저장하기 위해서 고안되었다. Array 는 할당하는 크기 만큼이 메모리에 연속적으로 할당 되는데 이로 인해 cache locality 을 이용한 빠른 접근이 가능하다.
위 사진을 보면 array 내에 있는 각 element 들이 가지는 메모리 주소가 연속적으로 할당되어 있는 것을 볼 수 있다. 캐시 메모리에 대한 간단한 설명을 읽어보면 이해하는데 도움이 된다.
캐시 메모리는 데이터 지역성(Locality)의 원리를 사용한다. 데이터 지역성은 대표적으로 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉘는데, 시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다.</description></item><item><title>자바의 Nested Class</title><link>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/</link><pubDate>Thu, 17 Feb 2022 10:36:46 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-nested-class/</guid><description>Nested Class? 클래스 내부에 선언한 클래스로 Static Nested 클래스와 Inner 클래스로 나뉜다. 내부 클래스는 또 멤버클래스, 지역 클래스와 익명 클래스로 나뉜다. 내부 클래스는 클래스 내부에서만 사용되는 경우 논리적으로 묶기 위해서 사용되거나 캡슐화를 통해 구현되어야 할 때 사용된다. 이와 같은 이유로 내부 클래스는 캡술화의 특징을 가지게 되는데, 클래스 내부를 숨기거나 은닉하는데 유용하며, 주로 Java GUI에서 사용된다.
Nested Class의 구조는 다음과 같다.
Static Nested Inner Class 클래스 내부에 구현된 클래스에 static 예약어를 붙여 논리적으로 내부 클래스와 내부 클래스를 구현한 클래스 관계를 묶어준다.</description></item><item><title>equals와 hashCode</title><link>https://youngeun-in.github.io/equals%EC%99%80-hashcode/</link><pubDate>Wed, 16 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/equals%EC%99%80-hashcode/</guid><description>equals 메소드 Object 클래스에 정의된 equals 메소드는 다음과 같다.
1 2 3 public boolean equals(Object obj) { return (this == obj); } 단순히 Object의 ==로 비교하는 것을 확인할 수 있다.
두 객체의 내용이 같은지 확인하려면 equals 메소드를 Override하면 된다.
1 2 3 4 5 6 7 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AttachFile that = (AttachFile) o; return Objects.</description></item><item><title>Comparable 인터페이스와 Comparator 인터페이스의 차이</title><link>https://youngeun-in.github.io/comparable-and-comparator/</link><pubDate>Tue, 15 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/comparable-and-comparator/</guid><description><![CDATA[Comparable 인터페이스 JAVA에서는 아래의 인터페이스 구현을 통해 정렬의 기준을 프로그래머가 직접 정의할 것을 요구하고 있다.
1 2 3  public interface Comparable&lt;T&gt; { int compareTo(T obj); }   사용 예시는 다음과 같다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import java.util.Iterator; import java.util.TreeSet; class Person implements Comparable&lt;Person&gt; { String name; int age; public Person(String name, int age) { this.]]></description></item><item><title>Spring PSA</title><link>https://youngeun-in.github.io/spring-psa/</link><pubDate>Tue, 15 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/spring-psa/</guid><description>Spring의 대표적인 핵심가치 3가지로 IoC, AOP, PSA가 있다.
PSA (Portable Service Abstraction) @Transactional 어노테이션을 선언하는 것 만으로 별도의 코드 추가 없이 트랜잭션 서비스를 사용할 수 있다. 내부적으로 트랜잭션 코드가 추상화되어 숨겨져 있는 것이다. 이렇게 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)이며, 하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 Portable Service Abstraction이라고 한다.
PSA의 원리 트랜잭션을 예로 들어 설명하겠다.
위 그림처럼 Spring의 @Transactional은 각 TransactionManager를 각각 구현하고 있는 것이 아니라 최상위 PlatformTransactionManager를 이용하고 필요한 TransactionManager를 DI로 주입받아 사용하고 있다.</description></item><item><title>프록시 패턴</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</link><pubDate>Sun, 06 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</guid><description>프록시 패턴 Proxy는 우리말로 대리자, 대변인 이라는 뜻이다. 대리자, 대변인은 다른 누군가를 대신해서 그 역할을 수행하는 존재를 말한다. 프록시는 타겟의 기능을 확장하거나 타깃에 대한 접근을 제어하기 위한 목적으로 사용된다.
상속을 사용한 구현 아래와 같은 타겟 클래스가 있다고 하자.
1 2 3 4 5 public class GameService { public void startGame() { System.out.println(&amp;#34;Hello&amp;#34;); } } 다음과 같이 프록시 클래스가 타겟 클래스를 상속받도록 만든다.
1 2 3 4 5 6 7 8 9 public class GameServiceProxy extends GameService { @Override public void startGame() { long before = System.</description></item><item><title>Enum 사용 (활용)</title><link>https://youngeun-in.github.io/enum-usage-2/</link><pubDate>Fri, 04 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/enum-usage-2/</guid><description>데이터 그룹관리 결제를 예로 들어 Enum의 활용법을 알아보고자 한다. 결제라는 데이터는 결제 종류와 결제 수단이라는 2가지 형태로 표현된다. 예를 들어 신용카드 결제는 신용카드 결제라는 결제 수단이며, 카드라는 결제 종류에 포함된다. 이 카드 결제는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다.
결제종류, 결제수단등의 관계를 명확히 표현하며, 각 타입은 본인이 수행해야할 기능과 책임만 가질 수 있도록 하기 위해 Enum을 사용할 수 있다.
이 때 DB 테이블의 결제수단 컬럼에 잘못된 값을 등록하거나, 파라미터로 전달된 값이 잘못되었을 경우에도 관리할 수 있도록 결제수단 역시 Enum으로 등록할 수 있다.</description></item><item><title>Enum 사용 (개념)</title><link>https://youngeun-in.github.io/enum-usage-1/</link><pubDate>Thu, 03 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/enum-usage-1/</guid><description><![CDATA[상태와 행위를 한곳에서 관리 예를 들어 DB에 저장된 code의 값이 &ldquo;CALC_A&quot;일 경우엔 값 그대로, &ldquo;CALC_B&quot;일 경우엔 10 한 값을, &ldquo;CALC_C&quot;일 경우엔 3을 계산하여 전달하는 경우를 생각해보자. 이 때 &ldquo;DB의 테이블에서 뽑은 특정 값은 지정된 메소드와 관계가 있다.&ldquo;는 사실을 코드로 나타내기 위해 Enum을 사용할 수 있다. 즉 JAVA에서 Enum을 통해 상태와 행위를 한곳에서 관리할 수 있다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import java.]]></description></item><item><title>활성화 함수</title><link>https://youngeun-in.github.io/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/</link><pubDate>Tue, 11 Jan 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98/</guid><description>Step Function 활성화 함수는 신경망의 행동을 결정하는 중요한 역할을 합니다. 가장 간단한 형태의 활성화 함수는 계단 함수(Step function) 라고 합니다. 계단 함수는 입력값의 합이 임계값을 넘으면 $0$ 을, 넘지 못하면 $1$ 을 출력하게 됩니다. 계단 함수의 그래프는 다음과 같이 생겼습니다.
이미지 출처 : wikipedia - Heaviside step function
계단 함수는 활성화 함수의 조건을 가장 잘 만족하는 함수이고 직관적으로도 이해하기 쉽습니다. 하지만 불연속 함수라는 단점 때문에 실제 신경망에 사용되지는 않습니다. 그래프를 보면 알 수 있듯 임계값 지점에서 불연속점을 갖게 되는데 이 점에서 미분이 불가능하기 때문에 학습이 필요한 신경망에 사용할 수 없습니다.</description></item></channel></rss>