<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title/><link>https://youngeun-in.github.io/</link><description>About LoveIt Theme</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 23 Mar 2022 15:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 동기화</title><link>https://youngeun-in.github.io/java-%EB%8F%99%EA%B8%B0%ED%99%94/</link><pubDate>Wed, 23 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-%EB%8F%99%EA%B8%B0%ED%99%94/</guid><description>동기화는 프로세스(스레드)가 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것을 말한다. 이러한 동기화 메커니즘인 상호배제는 하나의 프로세스가 공유자원을 사용할 때 다른 프로세스가 동일한 공유자원에 접근할 수 없도록 통제하는 것을 뜻한다. 상호배제 방법으로는 Mutex, Semaphore 방식이 사용된다. Java 에서는 Monitor 라는 도구를 통해 객체에 Lock을 걸어 상호배제를 할 수 있다.
동기화 메커니즘 Mutex Mutex는 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 메커니즘이다. 특징을 살펴보면 다음과 같다.</description></item><item><title>추상클래스 vs 인터페이스</title><link>https://youngeun-in.github.io/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</link><pubDate>Thu, 17 Mar 2022 18:36:46 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</guid><description>추상클래스 자바에서는 하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 추상 클래스(abstract class)라고 한다. 이러한 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해준다. 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로, 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야 할 경우 사용한다.
인터페이스 인터페이스는 객체의 사용 방법을 정의한 타입이다. 인터페이스는 상속 관계를 타고 올라갔을 때 다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다.</description></item><item><title>프록시 서버</title><link>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/</link><pubDate>Sun, 13 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84/</guid><description>포워드 프록시(Forward Proxy) 일반적으로, 프록시 서버라고 하면 포워드 프록시를 의미한다. 포워드 프록시란 클라이언트와 인터넷 사이에 프록시가 위치해서 클라이언트 대신 서버에 요청을 보내주는 형태를 말한다.
포워드프록시를 통해 얻는 이점은 다음과 같다.
로컬 네트워크와 인터넷 사이 오가는 트래픽을 제어할 수 있다. 예를 들어 초등학교 안에서 학생들이 부적절한 콘텐츠를 브라우징하는 것을 막기 위해서 포워드 프록시를 사용할 수 있다. 포워드 프록시는 대개 캐싱 기능이 있으므로 어떤 콘텐츠가 빈번하게 사용된다면 월등한 성능 향상을 가져올 수 있다.</description></item><item><title>Dependency Inversion Principle</title><link>https://youngeun-in.github.io/dependency-inversion-principle/</link><pubDate>Wed, 09 Mar 2022 14:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dependency-inversion-principle/</guid><description>DIP(Dependency Inversion Principle) 우리가 다루는 모듈은 고수준 모듈과 저수준 모듈로 나눌 수 있다. 고수준 모듈이란 의미있는 단일 기능을 제공하는 모듈이며, 저수준 모듈은 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현인 모듈이다. Layered Architecture 상에서 Application 및 Domain 등의 고수준 모듈은 Infrastructure라는 저수준 모듈을 의존한다. 그 결과, 구현 부분의 변경에 유연하지 못하고 테스트하기 어렵다는 문제점이 발생한다.
DIP(Dependency Inversion Principle)이란 의존 관계를 역전시켜서 저수준 모듈이 고수준 모듈에 의존하도록 구현하는 것을 의미한다.</description></item><item><title>디미터의 법칙(Law of Demeter)</title><link>https://youngeun-in.github.io/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/</link><pubDate>Tue, 08 Mar 2022 15:11:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99law-of-demeter/</guid><description>디미터의 법칙(Law of Demeter) 디미터의 법칙은 “Object-Oriented Programming: An Objective Sense of Style” 에서 처음으로 소개되었다. Demeter라는 프로젝트를 진행하던 개발자들은 어떤 객체가 다른 객체에 대해 지나치게 많이 알다보니, 결합도가 높아지고 좋지 못한 설계를 야기한다는 것을 발견하였다. 그래서 이를 개선하고자 객체에게 자료를 숨기는 대신 함수를 공개하도록 하였는데, 이것이 바로 디미터의 법칙이다.
즉, 디미터의 법칙은 다른 객체가 어떠한 자료를 갖고 있는지 속사정을 몰라야 한다는 것을 의미하며, 이러한 이유로 Don’t Talk to Strangers(낯선 이에게 말하지 마라) 또는 Principle of least knowledge(최소 지식 원칙) 으로도 알려져 있다.</description></item><item><title>캡슐화</title><link>https://youngeun-in.github.io/%EC%BA%A1%EC%8A%90%ED%99%94/</link><pubDate>Tue, 08 Mar 2022 13:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%BA%A1%EC%8A%90%ED%99%94/</guid><description>객체지향과 캡슐화 객체는 캡슐화된 상태와 외부에 노출되어 있는 행동을 갖고 있으며, 다른 객체와 메시지를 주고 받으면서 협력한다. 객체는 메시지를 받으면 객체 그에 따른 로직(행동)을 수행하게 되고, 필요하다면 객체 스스로 내부의 상태값도 변경한다. 간단히 말해서 객체지향 프로그래밍은 객체가 스스로 일을 하도록 하는 프로그래밍이다.
상태를 가지는 객체를 추가했다면 객체가 제대로 된 역할을 하도록 구현해야 한다. 즉 객체가 로직을 구현하도록 한다. 상태 데이터를 꺼내 로직을 처리하도록 구현하지 말고 객체에 메시지를 보내 일을 하도록 해야한다.</description></item><item><title>자바의 Proxy 구현</title><link>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/</link><pubDate>Mon, 07 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-proxy-%EA%B5%AC%ED%98%84/</guid><description><![CDATA[Pure Java, JDK Dynamic Proxy, CGLib Dynamic Proxy를 이용하여 문자열을 대문자로 변환하는 프록시를 구현해보도록 하자. 인터페이스와 타겟 클래스는 다음과 같다.
1 2 3 4 5  public interface Hello { String sayHello(String name); String sayHi(String name); String sayThankyou(String name); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class HelloTarget implements Hello { @Override public String sayHello(String name) { return &#34;Hello &#34; + name; } @Override public String sayHi(String name) { return &#34;Hi &#34; + name; } @Override public String sayThankyou(String name) { return &#34;Thankyou &#34; + name; } }   예상 결과는 다음과 같다.]]></description></item><item><title>Dependency Injection</title><link>https://youngeun-in.github.io/dependency-injection/</link><pubDate>Sat, 05 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dependency-injection/</guid><description>Dependency Injection Dependency Injection은 말 그대로 의존성 주입을 말한다. 이는 객체 간의 의존성을 외부에서 주입하여 관리하겠다라는 개념이다.
의존성이 높으면 코드의 재사용성이 떨어지고 변경에 유연하지 못하며 테스트 코드를 작성하기 어려워진다.
외부에서 의존을 주입받으면 의존을 내부에서 정의하지 않기 때문에 객체 간의 의존성을 줄여주고 코드의 재사용성도 증가하며 변화에 민감하지 않을 수 있다. 이때 변화에 민감하다는 말은 객체 자신이 아니라 의존하고 있는 다른 객체의 변경으로부터 민감한 정도를 말한다. 의존의 정도가 작을수록 의존 객체의 변경에 크게 영향을 받지 않는다.</description></item><item><title>DTO vs VO</title><link>https://youngeun-in.github.io/dto-vs-vo/</link><pubDate>Fri, 04 Mar 2022 09:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dto-vs-vo/</guid><description>DTO Data Transfer Object의 약자로 계층(Layer) 간 데이터를 전달하는 객체이다.
조금 더 쉽게 말하면, 데이터를 담아서 전달하는 바구니라고 할 수 있다.
Controller는 View와 도메인 Model의 데이터를 주고 받을 때 별도의 DTO 를 주로 사용한다. 도메인 객체를 View에 직접 전달할 수 있지만, 민감한 도메인 비즈니스 기능이 노출될 수 있으며 Model과 View 사이에 의존성이 생기기 때문이다.
DTO는 데이터 접근 메서드(Getter, Setter), 생성자 외에 기능을 갖지 않는다. (정렬, 직렬화 등 데이터 표현을 위한 기능은 가질 수 있다.</description></item><item><title>volatile</title><link>https://youngeun-in.github.io/volatile/</link><pubDate>Thu, 03 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/volatile/</guid><description>volatile란? volatile 키워드는 java 변수를 Main Memory에 저장하겠다라는 것을 명시한다. 즉 매번 변수의 값을 읽을 때마다 CPU cache에 저장된 값이 아닌 Main Memory에서 읽는 것이다. 또한 변수의 값을 쓸 때마다 Main Memory까지 작성한다.
volatile 키워드의 필요성 멀티쓰레드 어플리케이션에서의 non-volatile 변수에 대한 작업은 성능상의 이유로 CPU 캐시를 이용한다. 둘 이상의 CPU가 탑재된 컴퓨터에서 어플리케이션을 실행한다면, 각 쓰레드는 변수를 각 CPU의 캐시로 복사하여 읽어들인다.
쓰레드가 변경한 값이 메인 메모리에 저장되지 않아서 다른 쓰레드가 이 값을 볼 수 없는 상황을 &amp;lsquo;가시성&amp;rsquo; 문제라 한다.</description></item></channel></rss>