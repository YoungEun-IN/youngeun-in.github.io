<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title/><link>https://youngeun-in.github.io/</link><description>About LoveIt Theme</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 04 Mar 2022 09:12:26 +0900</lastBuildDate><atom:link href="https://youngeun-in.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>DTO vs VO</title><link>https://youngeun-in.github.io/dto-vs-vo/</link><pubDate>Fri, 04 Mar 2022 09:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/dto-vs-vo/</guid><description>DTO Data Transfer Object의 약자로 계층(Layer) 간 데이터를 전달하는 객체이다.
조금 더 쉽게 말하면, 데이터를 담아서 전달하는 바구니라고 할 수 있다.
Controller는 View와 도메인 Model의 데이터를 주고 받을 때 별도의 DTO 를 주로 사용한다. 도메인 객체를 View에 직접 전달할 수 있지만, 민감한 도메인 비즈니스 기능이 노출될 수 있으며 Model과 View 사이에 의존성이 생기기 때문이다.
DTO는 데이터 접근 메서드(Getter, Setter), 생성자 외에 기능을 갖지 않는다. (정렬, 직렬화 등 데이터 표현을 위한 기능은 가질 수 있다.</description></item><item><title>volatile</title><link>https://youngeun-in.github.io/volatile/</link><pubDate>Thu, 03 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/volatile/</guid><description>volatile란? volatile 키워드는 java 변수를 Main Memory에 저장하겠다 라는 것을 명시한다. 즉 매번 변수의 값을 읽을 때마다 CPU cache에 저장된 값이 아닌 Main Memory에서 읽는 것이다. 또한 변수의 값을 쓸 때마다 Main Memory까지 작성한다.
volatile 키워드의 필요성 멀티쓰레드 어플리케이션에서의 non-volatile 변수에 대한 작업은 성능상의 이유로 CPU 캐시를 이용한다. 둘 이상의 CPU가 탑제된 컴퓨터에서 어플리케이션을 실행한다면, 각 쓰레드는 변수를 각 CPU의 캐시로 복사하여 읽어들인다.
쓰레드가 변경한 값이 메인 메모리에 저장되지 않아서 다른 쓰레드가 이 값을 볼 수 없는 상황을 &amp;lsquo;가시성&amp;rsquo; 문제라 한다.</description></item><item><title>싱글톤 패턴 구현</title><link>https://youngeun-in.github.io/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/</link><pubDate>Thu, 03 Mar 2022 10:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84/</guid><description>싱글톤 패턴은 프로세스(Java에서는 JVM) 내에 1개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역 접근점을 제공하는 패턴이다.
Eager Initialization 싱글톤 패턴을 가장 단순하게 구현하는 방법은 외부에서 해당 클래스의 인스턴스를 생성할 수 없도록 private 생성자를 만들고, 1개의 인스턴스만을 초기화(public static final)하여 이에 대한 접근을 제공하는 방식이다.
1 2 3 4 5 6 7 8 public class SimpleSingleton { //public static final으로 1개의 인스턴스만을 초기화하여 접근점을 제공하고, 2개 이상의 인스턴스를 못 만들게 한다.</description></item><item><title>HashMap vs HashTable vs ConcurrentHashMap</title><link>https://youngeun-in.github.io/hashmap-vs-hashtable-vs-concurrenthashmap/</link><pubDate>Thu, 03 Mar 2022 09:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/hashmap-vs-hashtable-vs-concurrenthashmap/</guid><description>각 자료구조는 필요에 따라 선택되고 활용된다. Map 인터페이스의 구현체로는 HashMap, HashTable, ConcurrentHashMap 등이 있다. Map 인터페이스를 구현하면, &amp;lt;Key, Value&amp;gt; 형태를 띈다. 그렇다면 이 셋은 무슨 특징을 가지고, 서로 어떤 차이가 있을까? 이번 글에서 해당 구현체를 비교하며 확인해보자.
HashMap key와 value에 null을 허용한다. 동기화를 보장하지 않는다. HashMap은 thread-safe하지 않아, 싱글 쓰레드 환경에서 사용하는 게 좋다. 한편, 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다. 결국 HashTable과 ConcurrentHashMap보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어진다.</description></item><item><title>자바의 Reflection</title><link>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/</link><pubDate>Wed, 02 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/%EC%9E%90%EB%B0%94%EC%9D%98-reflection/</guid><description>Reflection API란? 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메서드, 타입, 변수 등등)에 접근할 수 있게 해주는 자바 API다.
아래와 같이 Car 클래스가 존재한다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Car { private final String name; private int position; public Car(String name, int position) { this.name = name; this.position = position; } public void move() { this.</description></item><item><title>Java 실행 과정</title><link>https://youngeun-in.github.io/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/</link><pubDate>Tue, 01 Mar 2022 16:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/java-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/</guid><description>Java 컴파일 과정 자바 소스 파일(*.java)을해당 파일을 Java Compiler가 JVM이 해석할 수 있는 파일인 Java ByteCode (*.class)파일로 변환한다. Java Compiler는 Java 설치 시 Javac.exe라는 실행 파일 형태로 존재한다.
Java 바이트 코드란? Java 바이트 코드란 Java Source File을 Java Compiler가 컴파일해 만든 파일이다. Java Compiler에 의해 변환되는 코드의 명령어 크기가 1byte이기 때문에 Java 바이트코드라고 불린다. Java 바이트 코드는 JVM이 해석할 수 있는 언어이며 *.class 확장자를 가진다.
Java 실행 과정 Java Compiler를 통해 만들어진 Java Bytecode (*.</description></item><item><title>JVM의 구성요소</title><link>https://youngeun-in.github.io/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/</link><pubDate>Tue, 01 Mar 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/</guid><description>JVM의 구성요소 JVM은 크게 Class loader, Runtime Data Areas, Excution Engine 3가지로 구성된다.
Class Loader(클래스 로더) Java 컴파일러로 컴파일된 Java 바이트 코드를 Runtime 시점에 JVM내로 가져오고 Runtime Data Area(JVM 메모리 영역)에 배치해주는 역할을 한다.
Runtime Data Area JVM의 메모리 영역에 해당하며 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 세분화된다.
Method Area : Class, Interface, Method, Field, Static, Final 변수 등을 보관하는 영역 Heap Area : new 키워드로 생성된 객체나 배열 인스턴스를 보관하는 영역, Runtime 시 동적으로 생성되고 JVM이 사용여부를 판단 후 Garbage Collection을 하는 영역 Stack Area : Heap Area에 동적으로 생성되어 보관되있는 객체(참조 타입)의 래퍼런스를 보관하는 영역, 기본 타입의 경우 직접 Stack Area에 보관됨 PC Register : Thread가 생성될 때 생성되는 영역으로서 Thread마다 하나의 영역을 가진다.</description></item><item><title>Redis</title><link>https://youngeun-in.github.io/redis/</link><pubDate>Mon, 28 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/redis/</guid><description>캐시란 cache란 사용자의 입장에서 데이터의 원래 소스보다 더 빠르게 그리고 더 효율적으로 액세스할 수 있는 임시 데이터 저장소를 뜻한다. 대부분의 애플리케이션에서 속도 향상을 위해 cache를 사용하고 있다. 캐시에 데이터나 계산된 결과 값의 복사본을 저장해 둠으로써 전체적인 처리 속도를 향상시킨다.
캐시를 사용하는 경우는 다음과 같다.
데이터에 직접적으로 접근하는 데 걸리는 시간이 오래 걸릴 때 데이터가 잘 변하지 않는 경우 반복적으로 동일한 결과를 돌려주는 경우 (이미지와 썸네일 등) Redis란 레디스는 전 세계에서 가장 유명한 caching 솔루션이다.</description></item><item><title>Etag</title><link>https://youngeun-in.github.io/etag/</link><pubDate>Sun, 27 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/etag/</guid><description>HTTP 캐시 Static file(js, css, image) 뿐만 아니라 API와 같은 Dynamic content에도 간단하게 Cache기능을 사용하게 설정하면 API속도도 증가되고 유저 입장에서는 네트웍 트래픽을 줄일 수 있다. API와 같이 언제 바뀔지 모르는 데이터의 Cache는 쉽지 않은데, Etag를 이용하면 서버에서 새로운 데이터를 먼저 확인하고 줄 수 있기 때문에 API에도 충분히 적용가능하다.
Etag API데이터의 MD5 Hash를 ETag로 사용하게 되면 DB부하를 줄일 순 없지만, Response 시간을 줄이는데 도움이 될 수 있다. Response에 다음과 같은 Etag 헤더를 추가해주면, 다음 동일한 API를 부르면 아래와 같은 Request 헤더에 체크하는 헤더가 추가된다.</description></item><item><title>DB 인덱스</title><link>https://youngeun-in.github.io/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</link><pubDate>Fri, 25 Feb 2022 15:12:26 +0900</pubDate><author>Author</author><guid>https://youngeun-in.github.io/db-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</guid><description><![CDATA[인덱스의 종류 클러스터형 인덱스(Clustered Index)  영어 사전처럼 책의 내용 자체가 순서대로 정렬되어 있어서 인덱스 자체가 책의 내용과 같은 것 테이블 당 한 개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하는지에 따라서 시스템의 성능이 달라질 수 있다. 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 신중하게 생각해야 한다. 보조 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다.  보조 인덱스(Secondary Index)  &lt;찾아보기&gt;가 별도로 있고, &lt;찾아보기&gt;를 찾은 후에 그 옆에 표시된 페이지로 가야 실제 찾는 내용이 있는 것 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다.]]></description></item></channel></rss>